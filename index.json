[{"content":"リクエストを送信する際に、ネットワークの問題やサーバーエラーなどによりリクエストが失敗することがあります。そのような場合にリトライ機構を組み込むことは、アプリケーションの信頼性向上に寄与します。Pythonではrequestsライブラリとurllib3.util.retryモジュールを使用して、シンプルで効果的なRetry Request Utilityを作成することができます。\n1. 必要なライブラリのインストール まず、以下のコマンドを使用して必要なライブラリをインストールします。\npip install requests urllib3 2. 使用するライブラリのインポート import urllib3 from urllib3.util.retry import Retry from requests.adapters import HTTPAdapter 3. retry_request.pyの作成 import requests from requests.adapters import HTTPAdapter from urllib3.util.retry import Retry @contextlib.contextmanager def request_session(): max_retries = Retry(total=3, backoff_factor=1, status_forcelist=[k for k in range(400, 600)]) headers = { \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\u0026#34; } s = requests.session() try: s.headers.update(headers) s.mount(\u0026#34;http://\u0026#34;, HTTPAdapter(max_retries=max_retries)) s.mount(\u0026#34;https://\u0026#34;, HTTPAdapter(max_retries=max_retries)) yield s finally: s.close() 使用例 from retry_request import request_session def main(): with request_session() as s: r = s.get(\u0026#34;http://example.com\u0026#34;) print(r.status_code) print(r.text) if __name__ == \u0026#34;__main__\u0026#34;: main() ","permalink":"https://seiri-blog.github.io/posts/python_retry_request/","summary":"リクエストを送信する際に、ネットワークの問題やサーバーエラーなどによりリクエストが失敗することがあります。そのような場合にリトライ機構を組み","title":"PythonでRetry Request Utilityを作成する方法"},{"content":"EXCEPT 句とは EXCEPT句は、2 つのクエリの結果セットを比較し、左側のクエリの結果から右側のクエリの結果を差し引く操作を行います。つまり、2 つの結果セットの差分を求める際に利用されます。EXCEPT句は、セット（集合）としての考え方に基づいており、重複する行を自動的に削除してくれます。\n使い方 EXCEPT句の基本的な構文は以下の通りです。\nSELECT 列1, 列2, ... FROM テーブル1 WHERE 条件1 EXCEPT SELECT 列1, 列2, ... FROM テーブル2 WHERE 条件2; この構文では、テーブル1から取得された結果セットから、テーブル2から取得された結果セットを差し引いています。重要な点として、EXCEPT句の前後の 2 つのクエリは同じ列の数と型を持っている必要があります。\n具体例 例を通じてEXCEPT句の使い方を理解しましょう。以下は、従業員テーブルとマネージャーテーブルがある場合の例です。\n-- マネージャーがいる従業員 SELECT EmployeeID FROM Employee WHERE ManagerID IS NOT NULL EXCEPT -- マネージャーテーブルのマネージャー SELECT ManagerID FROM Manager; この例では、Employeeテーブルからマネージャーがいる従業員の一覧から、Managerテーブルのマネージャーの一覧を差し引いています。結果として、マネージャーではない従業員の一覧が得られます。\n注意点  EXCEPT句は左側のクエリの結果から右側のクエリの結果を差し引くため、左側にしか存在しないデータが残ります。 列の数やデータ型が一致しない場合、エラーが発生します。 EXCEPTはセット演算子なので、重複した行は 1 度だけ結果に含まれます。  まとめ EXCEPT句は、2 つの結果セットの差分を求める際に非常に便利な SQL の機能です。セットとしての操作を理解し、データの比較や差分抽出に活用してみてください。\n関連記事 SQL UNION と UNION ALL の使い方\n","permalink":"https://seiri-blog.github.io/posts/sql-excepct/","summary":"EXCEPT 句とは EXCEPT句は、2 つのクエリの結果セットを比較し、左側のクエリの結果から右側のクエリの結果を差し引く操作を行います。つまり、2 つの","title":"SQLのEXCEPTの詳細な説明と使い方"},{"content":"SOQL とは SOQL（Salesforce Object Query Language）は、Salesforce のデータをクエリするために特別に設計されたクエリ言語です。SQL（Structured Query Language）に似ていますが、Salesforce のデータモデルに合わせて調整されています。SOQL を使用すると、Salesforce オブジェクトからデータを取得できます。これには、Account などの標準オブジェクトやユーザーが作成したカスタムオブジェクトが含まれます。\n以下は SOQL の主な特徴と概念です：\n  SELECT 文： SOQL クエリでは、指定した Salesforce オブジェクトから取得するフィールドを指定するために SELECT 文が使用されます。例：\nSELECT Id, Name FROM Account   WHERE 句を使用したフィルタリング： WHERE 句を使用してレコードをフィルタリングできます。例：\nSELECT Name FROM Contact WHERE AccountId = \u0026#39;001xx000003DGb2AAG\u0026#39;   関連オブジェクトのクエリ： SOQL は関連するオブジェクトのクエリをサポートしています。例：\nSELECT Name, (SELECT LastName FROM Contacts) FROM Account   集計関数： SOQL では、COUNT、SUM、AVG、MAX、MIN などの集計関数を使用できます。例：\nSELECT AVG(Amount) FROM Opportunity WHERE StageName = \u0026#39;Closed Won\u0026#39;   結果のソートおよび制限： ORDER BY を使用して結果をソートし、LIMIT を使用して返されるレコード数を制限できます。\nSELECT Name, CloseDate FROM Opportunity ORDER BY CloseDate DESC LIMIT 10   日付の形式と関数： SOQL では、DAY_ONLY()、MONTH()、CALENDAR_MONTH()など、日付を操作するための関数が提供されています。例：\nSELECT Id, CloseDate FROM Opportunity WHERE CALENDAR_MONTH(CloseDate) = 12   参考  SOQL リファレンス  ","permalink":"https://seiri-blog.github.io/posts/salesforce-soql-introduction/","summary":"SOQL とは SOQL（Salesforce Object Query Language）は、Salesforce のデータをクエリするために特別に設計されたクエリ言語です。","title":"【Salesforce】SOQL入門"},{"content":"SOQL のサブクエリ SOQL では、条件中にサブクエリを使用して親オブジェクトと子オブジェクトの関連を確認することができます。以下は、条件中でのサブクエリの例です。\n例えば、取引先責任者（Contact）オブジェクトの中で、関連するアカウント（Account）が「Gold」プランに属するものを取得する場合：\nSELECT Id, FirstName, LastName FROM Contact WHERE Account.Plan__c = \u0026#39;Gold\u0026#39; この例では、Account.Plan__c がサブクエリとなり、条件中で関連するアカウントのプランが \u0026ldquo;Gold\u0026rdquo; である取引先責任者を取得しています。\nもう一つの例として、アカウント（Account）オブジェクトの中で、関連する取引先責任者（Contact）が「主要な連絡先」にマークされているものを取得する場合：\nSELECT Id, Name FROM Account WHERE Id IN (SELECT AccountId FROM Contact WHERE IsPrimaryContact = true) この例では、アカウントの条件中で Id IN (SELECT AccountId FROM Contact WHERE IsPrimaryContact = true) を使用して、関連する取引先責任者が主要な連絡先になっているアカウントを取得しています。\nこれらは基本的な例であり、実際のデータモデルや関連によっては、より複雑なクエリを構築する必要があります。サブクエリを使用する際は、データモデルとクエリのパフォーマンスに留意することが重要です。\nカスタムオブジェクトのサブクエリ カスタムオブジェクトでも、標準オブジェクトと同様に SOQL サブクエリを使用して関連するデータをクエリすることができます。以下は、カスタムオブジェクトに対するサブクエリの例です。\n例えば、カスタムオブジェクト \u0026ldquo;CustomObjectc\u0026rdquo; とその子オブジェクト \u0026ldquo;ChildObjectc\u0026rdquo; の関連データを取得する場合：\nSELECT Id, Name, (SELECT Id, ChildField__c FROM ChildObjects__r) FROM CustomObject__c このクエリでは、CustomObject__c の各レコードに関連する ChildObject__c オブジェクトのサブクエリが含まれています。ChildObjects__r は関連名であり、実際の関連名はデータモデルに基づいて決まります。\nまた、条件を追加してカスタムオブジェクトの特定のデータを絞り込むことも可能です。例えば、特定の条件を持つ子オブジェクトを持つカスタムオブジェクトのデータを取得する場合：\nSELECT Id, Name, (SELECT Id, ChildField__c FROM ChildObjects__r WHERE ChildField__c = \u0026#39;SomeValue\u0026#39;) FROM CustomObject__c このクエリでは、ChildField__c フィールドが \u0026lsquo;SomeValue\u0026rsquo; である子オブジェクトを持つ CustomObject__c レコードを取得しています。\nSOQL サブクエリは、標準オブジェクトとカスタムオブジェクトの双方で同様に使用できます。\n","permalink":"https://seiri-blog.github.io/posts/salesforce-soql-sub-query/","summary":"SOQL のサブクエリ SOQL では、条件中にサブクエリを使用して親オブジェクトと子オブジェクトの関連を確認することができます。以下は、条件中でのサブクエリ","title":"【Salesforce】SOQLのサブクエリ"},{"content":"Apexバッチとは Apexバッチは、Salesforce プラットフォーム上で大量のデータを効率的に処理するための仕組みです。バッチ処理は非同期で実行され、大規模なデータセットに対して操作を行うことができます。Apexバッチは Database.Batchable インターフェースを実装することで定義されます。\n以下は、Apexバッチの主な構成要素や特徴です：\n  Database.Batchable インターフェース:\n Apexバッチは、Database.Batchable インターフェースを実装します。このインターフェースには、start、execute、finish の 3 つのメソッドが含まれています。  global class MyBatchClass implements Database.Batchable\u0026lt;sObject\u0026gt; { global Database.QueryLocator start(Database.BatchableContext BC) { // バッチ処理の開始前に実行される処理  // ...  } global void execute(Database.BatchableContext BC, List\u0026lt;sObject\u0026gt; scope) { // バッチ処理のメインロジック  // ...  } global void finish(Database.BatchableContext BC) { // バッチ処理の終了時に実行される処理  // ...  } }   start メソッド:\n バッチ処理の最初に一度だけ呼び出され、処理の準備などを行います。このメソッドは Database.QueryLocator を返す必要があります。 Database.QueryLocatorで取得可能なレコード数の上限が5000万件にまで拡張されます。    execute メソッド:\n バッチ処理のメインロジックを記述するメソッドです。データセットを受け取り、それに対して処理を行います。このメソッドが実行されるごとに新しいトランザクションが開始されます。    finish メソッド:\n バッチ処理が完了した際に一度だけ呼び出され、後処理などを行います。通常、ログの出力やレポートの生成などがここで行われます。    Apexバッチの中に他のバッチを呼び出す方法 Apexバッチから別のバッチを呼び出すには、finish メソッド内しか呼び出すことができませんので、\nfinish メソッド内で Database.executeBatch を使用して、別のバッチを実行できます。\nglobal class MyBatchClass implements Database.Batchable\u0026lt;sObject\u0026gt; { global Database.QueryLocator start(Database.BatchableContext BC) { // バッチ処理の開始  // ...  } global void execute(Database.BatchableContext BC, List\u0026lt;sObject\u0026gt; scope) { // バッチ処理の実行  // ...  } global void finish(Database.BatchableContext BC) { // バッチ処理の終了  // ...  // 別のバッチを非同期に実行  AnotherBatchClass anotherBatch = new AnotherBatchClass(); Database.executeBatch(anotherBatch); } } ","permalink":"https://seiri-blog.github.io/posts/apex-batch-call-another-batch/","summary":"Apexバッチとは Apexバッチは、Salesforce プラットフォーム上で大量のデータを効率的に処理するための仕組みです。バッチ処理は非同","title":"Apexバッチの中に他のバッチを呼び出す方法"},{"content":"Vue Router は、Vue.js アプリケーションに対する公式のルーティングライブラリです。Vue Router を使用すると、シングルページアプリケーション（SPA）内でページ間のナビゲーションを簡単に設定できます。以下では、Vue Router の基本的な使用法を説明します。\nVue Router の導入 Vue CLI を使用してプロジェクトを作成した場合、Vue Router は既にセットアップされているか、プロジェクトの作成時に選択肢として提供されることが一般的です。もしそうでない場合は、以下のコマンドで Vue Router をプロジェクトに追加できます：\nvue add router 基本的な Vue Router の設定  src/components ディレクトリ内に Home.vue と About.vue の 2 つのコンポーネントを作成します   src/components/Home.vue\n \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Home Page\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Welcome to the Home Page!\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt;  src/components/About.vue\n \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;About Page\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is the About Page!\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; ファイルを作成して Vue Router を設定する   src/router/index.js\n import { createRouter, createWebHistory } from \u0026#34;vue-router\u0026#34;; import Home from \u0026#34;@/views/Home.vue\u0026#34;; import About from \u0026#34;@/views/About.vue\u0026#34;; const routes = [ { path: \u0026#34;/\u0026#34;, name: \u0026#34;Home\u0026#34;, component: Home, }, { path: \u0026#34;/about\u0026#34;, name: \u0026#34;About\u0026#34;, component: About, }, ]; const router = createRouter({ mode: \u0026#34;history\u0026#34;, history: createWebHistory(process.env.BASE_URL), routes, }); export default router; Vue Router を使って定義したルートは、\u0026lt;router-view\u0026gt; コンポーネントを使用して表示される\nまた、\u0026lt;router-link\u0026gt; コンポーネントを使用すると、ルート間をナビゲートするためのリンクを作成でる。   src/App.vue\n \u0026lt;template\u0026gt; \u0026lt;router-link to=\u0026#34;/\u0026#34;\u0026gt;Home\u0026lt;/router-link\u0026gt;| \u0026lt;router-link to=\u0026#34;/about\u0026#34;\u0026gt;About\u0026lt;/router-link\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/template\u0026gt; これにより、ユーザーは「Home」および「About」リンクをクリックして、それぞれのルートに移動できます。\nリンクではなくボタンにしたい場合は、下記ように実装すればよいです。   src/App.vue\n \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;goHome\u0026#34;\u0026gt;Home\u0026lt;/button\u0026gt;| \u0026lt;button @click=\u0026#34;goAbout\u0026#34;\u0026gt;About\u0026lt;/button\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { methods: { goHome() { this.$router.push(\u0026#34;/\u0026#34;); }, goAbout() { this.$router.push(\u0026#34;/about\u0026#34;); }, }, }; \u0026lt;/script\u0026gt; 実際の動作  リンクで画面遷移：\n\nボタンで画面遷移：\n\n","permalink":"https://seiri-blog.github.io/posts/vue3-router/","summary":"Vue Router は、Vue.js アプリケーションに対する公式のルーティングライブラリです。Vue Router を使用すると、シングルページアプリケーション（SPA）","title":"Vue3 画面遷移"},{"content":"vue/multi-word-component-names エラーについて Vue.js の規約では、コンポーネント名は常に複数の単語で構成するべきで、それに従っていない場合、Linter（コードの品質を確認するツール）が警告を出すことがあります。エラーメッセージ Component name should always be multi-word は、コンポーネント名が単語を複数含まない場合に表示される警告です。\nしたがって、例えば以下のようなコンポーネント名を使うとエラーが表示される可能性があります：\n// エラーが発生する例 Vue.component(\u0026#34;user\u0026#34;, { // ... }); この場合、user は単語が 1 つしか含まれていないので、下記のようなエラーメッセージが表示されます。\n\\test-vue-demo\\src\\components\\XXXXX.vue 1:1 error Component name \u0026quot;XXXXX\u0026quot; should always be multi-word vue/multi-word-component-names ✖ 1 problem (1 error, 0 warnings) これを解決するには、複数の単語を含む名前を使う必要があります。\n// 正しい例 Vue.component(\u0026#34;user-profile\u0026#34;, { // ... }); user-profile のように、複数の単語をハイフンでつないだ形式を使用すると、この規約に従っていることになり、Linter からの警告が解消されるでしょう。これにより、コードが読みやすく、保守しやすくなります。\nルールを無効化する方法 例えば、Vue.js のコンポーネント名の Linter エラーを無視したい場合、次のように設定できます。\n1. package.jsonのeslintConfigセクションで無効化する package.json ファイルに eslintConfig セクションを追加します（もしくは既存の eslintConfig セクションを編集します）。\n例：\n{ \u0026#34;eslintConfig\u0026#34;: { \u0026#34;rules\u0026#34;: { \u0026#34;vue/multi-word-component-names\u0026#34;: \u0026#34;off\u0026#34; } } } 2. .eslintrc ファイルでルールを無効化する プロジェクトのルートディレクトリに .eslintrc もしくは .eslintrc.js ファイルを作成し、特定のルールを無効にすることができます。\n例：\n{ \u0026#34;rules\u0026#34;: { \u0026#34;vue/multi-word-component-names\u0026#34;: \u0026#34;off\u0026#34; } } 3. コメントでルールを一時的に無効にする 特定の行やブロックにおいて、Linter のルールを一時的に無効にすることができます。\n例：\n/* eslint-disable vue/multi-word-component-names */ // この行のコードはルールを無視します  /* eslint-enable vue/multi-word-component-names */ 4. .eslintignore ファイルを使用する .eslintignore ファイルをプロジェクトのルートに作成し、特定のファイルやディレクトリを Linter の対象外にすることができます。\n例：\n# .eslintignore ignoreThisFile.js ignoreThisDirectory/ 5. 特定のファイルに対してのみルールを変更する .eslintrc ファイルで、特定のファイルパスに対してのみルールを変更することができます。\n例：\n{ \u0026#34;overrides\u0026#34;: [ { \u0026#34;files\u0026#34;: [\u0026#34;specificFile.js\u0026#34;], \u0026#34;rules\u0026#34;: { \u0026#34;vue/multi-word-component-names\u0026#34;: \u0026#34;off\u0026#34; } } ] } 上記の設定は、vue/multi-word-component-names のルールが特定の Linter エラーをプロジェクト全体で無視するか、特定の場所でのみ無視することができます。\n","permalink":"https://seiri-blog.github.io/posts/vue-multi-word-component-names/","summary":"vue/multi-word-component-names エラーについて Vue.js の規約では、コンポーネント名は常に複数の単語で構成するべきで、それに従っていない場合、Linter（コードの品質を確認する","title":"vue/multi-word-component-namesエラーについて"},{"content":"Vue3 での環境構築 Vue.js 3 プロジェクトを開始するための環境を構築する方法はいくつかありますが、最も一般的な方法は Vue CLI（Command Line Interface）を使用することです。Vue CLI は、Vue.js アプリケーションを迅速に設定し、開発を効率化するための公式ツールです。以下に、Vue CLI を使用した Vue.js 3 プロジェクトの環境構築手順を示します。\n1. Node.js のインストール: Vue CLI は Node.js と npm（または Yarn）に依存しています。まず、Node.js の公式ウェブサイトから Node.js をダウンロードしてインストールしてください。インストールが完了したら、ターミナルまたはコマンドプロンプトで以下のコマンドを入力して、Node.js と npm のバージョンを確認します。\nnode -v npm -v 2. Vue CLI のインストール: Node.js と npm がインストールされたら、Vue CLI をグローバルにインストールします。以下のコマンドを実行します。\nnpm install -g @vue/cli これにより、システム全体で Vue CLI が利用できるようになります。\n3. Vue.js 3 プロジェクトの作成: Vue CLI がインストールされたら、新しい Vue.js 3 プロジェクトを作成できます。適当なディレクトリで以下のコマンドを実行します。\nvue create my-vue-app 上記のコマンドは、\u0026ldquo;my-vue-app\u0026quot;という名前の新しい Vue.js プロジェクトを作成します。Vue CLI はプロジェクトのセットアップに必要な依存関係を解決し、必要なファイルとフォルダを生成します。\n4. プロジェクトのディレクトリに移動してサーバーを起動: プロジェクトが作成されたら、プロジェクトのディレクトリに移動します。\ncd my-vue-app その後、開発サーバーを起動して Vue.js アプリケーションをローカルで実行できます。\nnpm run serve 上記のコマンドを実行すると、開発用のサーバーが起動し、デフォルトではhttp://localhost:8080でアプリケーションにアクセスできるようになります。\n以上で、Vue.js 3 プロジェクトの基本的な環境が構築されました。必要に応じて、プロジェクトの設定やコードを編集して、Vue.js アプリケーションの開発を開始できます。\nVue3 プロジェクトの例 Vue.js のコンポーネントを定義します。src/components ディレクトリ内に CounterVue.vue という名前のファイルを作成します：\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Vue.js Counter Demo\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Count: {{ count }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;decrement\u0026#34;\u0026gt;Decrement\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { count: 0, }; }, methods: { increment() { this.count++; }, decrement() { this.count--; }, }, }; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; /* スタイルはここに */ \u0026lt;/style\u0026gt; 上記のコードは、Vue.jsのコンポーネントを定義しています。このコンポーネントはカウンターの値を保持し、increment メソッドと decrement メソッドを使用して値を増減させます。\n次に、src/App.vue ファイルを編集して、先ほど作成したカウンターコンポーネントを表示します：\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;CounterVue /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import CounterVue from \u0026#34;./components/CounterVue.vue\u0026#34;; export default { components: { CounterVue, }, }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; /* スタイルはここに */ \u0026lt;/style\u0026gt; サーバを起動し、画面を確認する\nnpm run serve \nこれで、簡単なVue.jsのデモアプリケーションが完成しました。カウンターアプリケーションは非常にシンプルですが、Vue.jsの基本的な構文やコンポーネントの作成方法を学ぶのに適しています。必要に応じて、このデモを拡張したり、他のVue.jsの機能を追加してみることで、より複雑なアプリケーションを作成できます。\n","permalink":"https://seiri-blog.github.io/posts/vue3-quick-start/","summary":"Vue3 での環境構築 Vue.js 3 プロジェクトを開始するための環境を構築する方法はいくつかありますが、最も一般的な方法は Vue CLI（Command Line Inter","title":"Vue3入門"},{"content":"Vue3 とは Vue.js 3（または Vue3）は、Vue.js の最新のメジャーバージョンであり、Vue.js のコアチームによって開発されました。Vue.js 3 は、パフォーマンスの向上、TypeScript サポートの向上、コンポジション API の導入など、多くの新機能と改善を提供しています。\n以下は、Vue.js 3 の主な特徴と変更点です：\n  パフォーマンスの向上: Vue.js 3 は、仮想 DOM の再描画パフォーマンスを向上させるために、より効率的なリアクティブシステムを導入しています。これにより、アプリケーションのパフォーマンスが向上し、よりスムーズなユーザーエクスペリエンスを提供できます。\n  Composition API の導入: Composition API は、コンポーネントのロジックをより再利用可能で構造化された形で書けるようにする新しい API です。これにより、コードの可読性と保守性が向上し、大規模なアプリケーションの開発が容易になります。\n  TypeScript サポートの向上: Vue.js 3 は、TypeScript との統合を向上させ、より型安全なコードを書くことができるようになっています。これにより、開発プロセスがより安全で効率的になります。\n  Fragments と Portals のサポート: Vue.js 3 では、Fragments（フラグメント）と Portals（ポータル）のサポートが追加されました。これにより、より柔軟なコンポーネント構造を実現できます。\n  新しいディレクティブ: Vue.js 3 では、いくつかの新しいディレクティブが導入されました。例えば、v-model ディレクティブがより柔軟になり、v-if と v-for を同時に使用できるようになりました。\n  パッケージの分割: Vue.js 3 は、コアライブラリを小さく保ちつつ、追加の機能やライブラリをパッケージとして提供することで、柔軟性を高めています。これにより、プロジェクトの必要に応じて必要な機能を選んで利用することができます。\n  Vue.js 3 の公式ドキュメントや GitHub リポジトリから、最新の情報や詳細な使用方法を確認できます。Vue.js 3 は、より現代的でパワフルな Web アプリケーションを開発するための優れた選択肢となっています。\nVue3 と Vue2 の区別 Vue.js 2 とVue.js 3の主な違いを理解することで、どちらを選ぶかを決定するのが役立ちます。以下に、Vue.js 2とVue.js 3の主な違いを示します：\nVue.js 2:   成熟度と安定性: Vue.js 2は非常に成熟したライブラリであり、多くのプロジェクトで広く使用されています。安定性が求められるプロジェクトに適しています。\n  生態系とプラグイン: Vue.js 2には豊富なプラグインとコミュニティサポートがあります。多くのサードパーティのライブラリやツールが Vue.js 2 向けに開発されています。\n  簡潔な構文: Vue.js 2はシンプルでわかりやすい構文を提供しており、初学者にとっても学びやすいです。\n  Vue.js 3:   パフォーマンス: Vue.js 3は、仮想 DOM の再描画パフォーマンスが向上しています。これにより、大規模なアプリケーションでも高いパフォーマンスを実現できます。\n  Composition API: Vue.js 3は Composition API を導入し、コンポーネントのロジックをより構造化された形で書くことができます。これにより、大規模なプロジェクトの開発が容易になります。\n  TypeScript サポート: Vue.js 3は、TypeScript との統合を向上させ、型安全なコードを書くことができます。これにより、開発プロセスが安全かつ効率的になります。\n  新しい機能: Vue.js 3には、新しいディレクティブや機能が導入されています。また、パッケージの分割により、必要な機能のみを利用できるようになっています。\n  おすすめ:   新規プロジェクト: 新しいプロジェクトを開始する場合は、Vue.js 3 を選ぶことをおすすめします。最新の機能とパフォーマンスの向上が利用できます。\n  既存のプロジェクト: 既存のプロジェクトであれば、Vue.js 2 を継続して使用することが適切かもしれません。特に、既存のプロジェクトで安定して動作している場合は、アップグレードの必要性をよく検討してください。\n  最終的な選択は、プロジェクトの要件、チームのスキルセット、および将来の拡張性を考慮して行うべきです。\n","permalink":"https://seiri-blog.github.io/posts/vue3-and-vue2-difference/","summary":"Vue3 とは Vue.js 3（または Vue3）は、Vue.js の最新のメジャーバージョンであり、Vue.js のコアチームによって開発されました。Vue.js 3","title":"Vue3とVue2の違い"},{"content":".gitignore 説明 .gitignoreファイルは、Git リポジトリ内で管理されないファイルやディレクトリを指定するための設定ファイルです。このファイルにリストされたファイルやディレクトリは、Git のバージョン管理から除外されます。.gitignoreファイルを使用することで、不要なファイルやディレクトリがリポジトリに含まれないようにすることができ、Git 操作をより効果的に管理できます。\n以下は.gitignoreファイルの主なポイントと説明です。\n  ファイルとディレクトリの無視: .gitignoreファイルでは、特定のファイルやディレクトリを無視するためのパターンを指定します。これらのパターンは、リポジトリ内のファイルパスに一致するものが無視対象となります。\n  コメント: #文字で始まる行はコメント行であり、説明を追加するために使用します。コメント行は無視されます。\n  パターンの書き方: .gitignoreファイルに指定するパターンは、次のように書きます。\n 単純な一致: ファイル名やディレクトリ名をそのまま記述します。例: myfile.txt ワイルドカード: ワイルドカード文字（*や?）を使用してパターンを指定できます。例: *.log（すべての.log ファイルを無視）、test?.txt（test1.txt や test2.txt を無視） ディレクトリ: ディレクトリを無視する場合、ディレクトリ名の末尾にスラッシュ(/)を付けます。例: /build/（build ディレクトリとその中身を無視）    優先順位: .gitignoreファイル内のパターンは、上から下に評価されます。より上位に記述されたパターンが優先されます。したがって、より具体的な無視ルールを上に配置し、一般的なルールを下に配置することが一般的です。\n  サブディレクトリへの適用: .gitignoreファイルは、そのファイルが存在するディレクトリ内およびそのサブディレクトリに適用されます。したがって、特定の無視ルールはサブディレクトリにも影響を与えます。\n  .gitignoreの共有: .gitignoreファイルは Git リポジトリ内に保存され、他の開発者と共有できます。共有することで、プロジェクト全体で同じ無視ルールが適用されます。\n  .gitignoreファイルの作成とカスタマイズは、プロジェクトの要件に合わせて行われるべきであり、不要なファイルやディレクトリをリポジトリに含めないための重要なツールです。\n.gitignore 作成方法 以下は、.gitignore ファイルを作成する方法のステップです。\n  テキストエディタを開く:\n.gitignore ファイルを作成するために、お好みのテキストエディタを開きます。コマンドライン上でテキストエディタを使うことも、グラフィカルなテキストエディタを使うこともできます。\n  .gitignore ファイルを作成する:\nテキストエディタを開いたら、新しいファイルを作成し、ファイル名を.gitignoreとします。このファイル名は、ドットで始まる名前であるため、隠しファイルとして扱われます。ファイル名に拡張子は不要です。\n  無視するファイルやディレクトリのパターンを追加:\n.gitignore ファイルに、無視したいファイルやディレクトリのパターンを追加します。以下は、一般的な.gitignore ファイルの例です。\n# ディレクトリを無視する例 /bin/ /obj/ # 特定のファイルを無視する例 debug.log secret.txt この例では、/bin/ディレクトリと/obj/ディレクトリを無視し、debug.log ファイルと secret.txt ファイルを無視します。ファイルやディレクトリのパスは、Git リポジトリのルートからの相対パスで指定します。\n  .gitignore ファイルを保存:\nパターンを追加したら、ファイルを保存します。\n  Git リポジトリにコミット:\n.gitignore ファイルを Git リポジトリにコミットします。これにより、他のチームメンバーやクローンしたリポジトリでも無視されるファイルやディレクトリの設定が共有されます。\n  .gitignore ファイルは、プロジェクトごとに異なるものにすることができ、特定のファイルやディレクトリを無視して、リポジトリ内の不要なデータを削減できます。プロジェクトのニーズに合わせてカスタマイズしてください。\n参考 下記は Github のテンプレートのコレクションとなります。\n https://github.com/github/gitignore  ","permalink":"https://seiri-blog.github.io/posts/how-to-make-gitignore/","summary":".gitignore 説明 .gitignoreファイルは、Git リポジトリ内で管理されないファイルやディレクトリを指定するための設定ファイルです。このファイルに","title":"gitignoreの説明と作成方法"},{"content":"ダークモード作成の流れ ダークモードを実装する一般的な流れは以下の通りです。この流れは、HTML、CSS、JavaScriptを使用してウェブサイトやアプリにダークモードを統合する一般的な手順です。\n1. プロジェクトの準備：\n プロジェクトのファイル構造をセットアップし、必要なファイルを作成します（HTML、CSS、JavaScript）。  2. スタイルの設計：\n 通常モードおよびダークモードのためのスタイルを設計します。スタイルはCSSで管理されます。  3. HTMLの構築：\n ウェブページの基本構造をHTMLで構築します。ダークモードを切り替えるためのトグルボタンを用意します。  4. CSSの設定：\n 通常モードおよびダークモードのスタイルをCSSで設定します。ダークモードのスタイルは通常モードのスタイルから別に管理されます。  5. JavaScriptの統合：\n ダークモードの切り替え機能をJavaScriptで実装します。トグルボタンのクリックイベントを処理して、ダークモードのスタイルを切り替えます。  6. ダークモード切り替えの処理：\n トグルボタンがクリックされたときの処理を実装します。JavaScriptでトグルボタンの状態に応じて、ダークモードのスタイルを適用するかどうかを判断します。  7. カラーパレットの選択：\n ダークモードに使用するカラーパレットを選択します。テキスト、背景、ボタンなどの要素の色を調整します。  8. CSSクラスの切り替え：\n JavaScriptでHTML要素にダークモード用のCSSクラスを追加または削除して、ダークモードのスタイルを切り替えます。  9. 動作確認とテスト：\n ウェブサイトやアプリがダークモードと通常モードで正しく動作するかをテストします。さまざまなデバイスやブラウザでテストを行います。  10. ユーザーの選択肢の提供：\n ダークモードの切り替えをユーザーに提供するためのUI要素（トグルボタンなど）を表示します。  11. リリースと改善：\n ダークモードを実装し、テストしたら、プロジェクトをリリースします。ユーザーからのフィードバックを受けて、必要に応じて改善を行います。  スタイルの設計（色の選択） ダークモードの色を選択する際には、見やすさ、美しさ、一貫性などを考慮して慎重に決定する必要があります。以下に、ダークモードの色を選ぶ際のいくつかのポイントと具体的なカラーパレットの例を挙げてみましょう。\n1. 見やすさが重要： ダークモードでも情報が見やすく、読みやすいことが大切です。文字と背景のコントラストを保つことで、文字が明瞭に浮き上がるようにします。\n2. カラーコントラストの考慮： ダークモードでは、白いテキストを暗い背景に対比させることが一般的です。コントラスト比が高く、テキストがはっきりと読み取れるカラーパレットを選びましょう。\n3. ソフトな色： 鮮やかすぎない色や、彩度を抑えた色を選ぶことで、ダークモードが視覚的にやさしく感じられます。\n4. 一貫性を保つ： ダークモードの色選択は、通常モードの色と一貫性を持つことも大切です。ブランドのアイデンティティやデザイン方針に合致するように調整しましょう。\n5. 複数のテーマを提供： ユーザーによって好みが異なるため、ダークモードだけでなく複数のダークカラーパレットを提供することを検討してみてください。\n以下は、ダークモードの色選択のための一般的なカラーパレットの例です。これらはガイドラインであり、具体的なプロジェクトに合わせて調整することが重要です。\nダークモードカラーパレットの例:\n  デフォルトのダークモード:\n 背景: #121212 テキスト: #FFFFFF リンク: #2196F3    ダークグレーカラーパレット:\n 背景: #1E1E1E テキスト: #CCCCCC 強調カラー: #FFA500    青基調のカラーパレット:\n 背景: #101C29 テキスト: #E0E0E0 強調カラー: #42A5F5    地中海風のカラーパレット:\n 背景: #17202A テキスト: #F0FFFF 強調カラー: #17A589    ダークモード作成する例 以下はHTML、CSS、JavaScriptを使用してダークモードを作成する例です。\n HTMLのセットアップ： まず、ウェブページの基本構造をHTMLで作成します。ダークモードを切り替えるためのトグルボタンを用意します。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;css/styles.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;js/script.js\u0026#34; defer\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;title\u0026gt;Night Mode Example\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;My Awesome Website\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;toggle-container\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;toggle\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;nightModeToggle\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;slider\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Welcome to my website. This is an example of a beautiful night mode design.\u0026lt;/p\u0026gt; \u0026lt;button class=\u0026#34;cta-button\u0026#34;\u0026gt;Learn More\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; CSSの設定： ダークモードと通常モードの外観を設定します。ダークモードでは背景色、文字色、ボタンスタイルなどを変更します。  body { font-family: \u0026#39;Helvetica\u0026#39;, sans-serif; transition: background-color 0.3s, color 0.3s; margin: 0; padding: 0; } header { background-color: #2C3E50; color: #ECF0F1; padding: 20px; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); } .content { background-color: #FFFFFF; color: #34495E; padding: 40px; text-align: center; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); } .night-mode { background-color: #34495E; color: #ECF0F1; } .cta-button { background-color: #3498DB; color: #FFFFFF; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s; } .cta-button:hover { background-color: #2980B9; } .toggle-container { display: flex; align-items: center; } .toggle { position: relative; display: inline-block; width: 50px; height: 24px; } .toggle input[type=\u0026#34;checkbox\u0026#34;] { opacity: 0; width: 0; height: 0; } .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: 0.4s; border-radius: 12px; } .slider:before { position: absolute; content: \u0026#34;\u0026#34;; height: 20px; width: 20px; left: 2px; bottom: 2px; background-color: white; transition: 0.4s; border-radius: 50%; } input:checked + .slider { background-color: #2196F3; } input:checked + .slider:before { transform: translateX(26px); } JavaScriptのセットアップ： JavaScriptを使用して、トグルボタンがクリックされたときにダークモードのクラスを切り替えます。  const nightModeToggle = document.getElementById(\u0026#34;nightModeToggle\u0026#34;); const content = document.querySelector(\u0026#34;.content\u0026#34;); nightModeToggle.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { content.classList.toggle(\u0026#34;night-mode\u0026#34;); }); \n\n 例サイト\nhttps://ryuseiri.github.io/night-mode/  ","permalink":"https://seiri-blog.github.io/posts/night-mode-developer/","summary":"ダークモード作成の流れ ダークモードを実装する一般的な流れは以下の通りです。この流れは、HTML、CSS、JavaScriptを使用してウェブ","title":"ダークモードの開発"},{"content":"mainfest の定義(必須) manifest.json は、Chrome 拡張機能を定義するためのファイルです。\nこのファイルは、拡張機能の基本的な情報、設定、権限、リソースなどを指定します。\n拡張機能を作成する際には、必ず manifest.json を作成し、拡張機能の動作を制御します。\n以下は、典型的な manifest.json の例です：\n// manifest.json  { \u0026#34;manifest_version\u0026#34;: 3, \u0026#34;name\u0026#34;: \u0026#34;My Extension\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;This is a description of my extension.\u0026#34;, \u0026#34;icons\u0026#34;: { \u0026#34;48\u0026#34;: \u0026#34;icon.png\u0026#34;, \u0026#34;128\u0026#34;: \u0026#34;icon128.png\u0026#34; }, \u0026#34;action\u0026#34;: { \u0026#34;default_popup\u0026#34;: \u0026#34;popup.html\u0026#34;, \u0026#34;default_icon\u0026#34;: { \u0026#34;48\u0026#34;: \u0026#34;icon.png\u0026#34;, \u0026#34;128\u0026#34;: \u0026#34;icon128.png\u0026#34; } }, \u0026#34;permissions\u0026#34;: [\u0026#34;activeTab\u0026#34;, \u0026#34;tabs\u0026#34;], \u0026#34;content_scripts\u0026#34;: [ { \u0026#34;matches\u0026#34;: [\u0026#34;https://*/*\u0026#34;], \u0026#34;js\u0026#34;: [\u0026#34;content_script.js\u0026#34;] } ], \u0026#34;background\u0026#34;: { \u0026#34;service_worker\u0026#34;: \u0026#34;background.js\u0026#34; }, \u0026#34;browser_action\u0026#34;: { \u0026#34;default_popup\u0026#34;: \u0026#34;popup.html\u0026#34; } } 主なフィールドの意味を以下に解説します：  manifest_version: 使用するマニフェストバージョンを指定します。バージョン 3 の場合は 3 を指定します。 name: 拡張機能の名前を指定します。 version: 拡張機能のバージョンを指定します。 description: 拡張機能についての簡単な説明を指定します。 icons: 拡張機能のアイコンを指定します。さまざまなサイズのアイコンを提供することができます。 action: ブラウザアクションを定義します。アクション（ボタンなど）がある場合に指定します。 permissions: 拡張機能が必要とする権限を指定します。例えば、特定のウェブサイトにアクセスするために \u0026quot;https://*/*\u0026quot; を指定するなどがあります。 content_scripts: コンテンツスクリプトを指定します。特定のウェブページで実行するスクリプトを定義します。 background: バックグラウンドスクリプト（またはサービスワーカー）を指定します。拡張機能の背後で動作するスクリプトをここに定義します。 browser_action: ブラウザアクションを使用してポップアップページを指定します。  これは一般的な例であり、より複雑な拡張機能ではさらに多くのフィールドや設定を追加することができます。\n拡張機能の動作や外観をカスタマイズするために、適切なフィールドを追加してください。\nbackgournd の定義 background.js（または background.html など）は、Chrome 拡張機能の一部として使用される JavaScript ファイルです。\n拡張機能の背後で動作し、拡張機能全体のライフサイクルとブラウザイベントを管理します。\n拡張機能のバックグラウンドスクリプトとして実行されるため、ページ上で直接アクセスできない特権を持ちます。\nbackground.js の主な役割は以下のとおりです：\n  イベントのリスニング: background.js は、拡張機能に関連するブラウザイベント（例：ブラウザ起動時、タブの更新、拡張機能のインストール）をリッスンすることができます。これにより、特定のイベントに応答して適切なアクションを実行できます。\n  ロングランニングな操作: background.js は常にバックグラウンドで実行されるため、長時間かかる操作や継続的なタスクを処理するのに適しています。例えば、新しいタブのページを事前に読み込んでおくなどがあります。\n  データの保持: background.js は拡張機能がインストールされている間ずっと動作しているため、データの保持に適しています。これにより、拡張機能の設定や状態を保持し、他のコンポーネント（ポップアップ、コンテンツスクリプトなど）とデータを共有することができます。\n  ブラウザ API の使用: background.js は、ブラウザ API へのアクセスを持ちます。例えば、新しいタブの作成、ウィンドウの管理、ストレージの使用、ネットワークリクエストの送信などが可能です。\n  background.js は他のコンポーネント（ポップアップ、コンテンツスクリプトなど）と情報をやり取りする手段として、Chrome 拡張機能のアーキテクチャにおいて重要な役割を果たしています。ただし、拡張機能が複雑でない場合やデータ共有が不要な場合は、background.js を持たないシンプルな拡張機能も作成できます。\npopup の定義 popup.html（または popup.js など） は、Chrome 拡張機能において、アイコンをクリックしたときに表示される小さなウィンドウのことを指します。このウィンドウは、ユーザーが拡張機能と対話したり、機能を提供したりするために使用されます。通常、ポップアップウィンドウには簡単なユーザーインターフェースやコントロールが含まれており、拡張機能の操作や設定の変更が行えるようになっています。\nポップアップウィンドウは、特にユーザーに情報を提供したり、ユーザーからの入力を受け付けたりする場合に便利です。たとえば、拡張機能が現在のページの情報を表示したり、特定の動作を制御するためのボタンを提供したりすることができます。\nブラウザ拡張 3.0 作成例 ブラウザ拡張機能の作成例として、Chrome 拡張機能の基本的な機能を実装する方法を以下に示します。具体的には、ウェブページの要素を変更する簡単なカスタム機能を作成する例です。\nこの例では、Chrome の拡張機能を作成しますが、他のブラウザでも同様のコンセプトで拡張機能を作成できる場合があります。\n マニフェストファイル (manifest.json) の作成:\nまず、拡張機能の設定と必要な権限を定義するマニフェストファイルを作成します。  // manifest.json  { \u0026#34;manifest_version\u0026#34;: 3, \u0026#34;name\u0026#34;: \u0026#34;カスタム変更拡張\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;ウェブページの要素をカスタム変更する拡張機能\u0026#34;, \u0026#34;permissions\u0026#34;: [\u0026#34;activeTab\u0026#34;], \u0026#34;action\u0026#34;: { \u0026#34;default_popup\u0026#34;: \u0026#34;popup.html\u0026#34; }, \u0026#34;icons\u0026#34;: { \u0026#34;48\u0026#34;: \u0026#34;icon.png\u0026#34; }, \u0026#34;content_scripts\u0026#34;: [ { \u0026#34;matches\u0026#34;: [\u0026#34;https://*/*\u0026#34;, \u0026#34;http://*/*\u0026#34;], \u0026#34;js\u0026#34;: [\u0026#34;content_script.js\u0026#34;] } ] } ポップアップページ (popup.html) の作成:\nこのファイルは、ブラウザアイコンをクリックしたときに表示されるポップアップウィンドウの内容を定義します。  \u0026lt;!-- popup.html --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;カスタム変更拡張\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;popup.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;ウェブページの要素をカスタム変更\u0026lt;/h1\u0026gt; \u0026lt;button id=\u0026#34;changeButton\u0026#34;\u0026gt;要素を変更する\u0026lt;/button\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ポップアップページ用の JavaScript ファイル (popup.js) の作成:\nこのファイルは、ポップアップページでのボタンクリックなどの動作を定義します。  // popup.js  document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function () { document .getElementById(\u0026#34;changeButton\u0026#34;) .addEventListener(\u0026#34;click\u0026#34;, changeElement); }); function changeElement() { chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) { chrome.scripting.executeScript({ target: { tabId: tabs[0].id }, function: modifyPage, }); }); } function modifyPage() { // ウェブページの要素をカスタム変更する例  // ここではすべての段落 (\u0026lt;p\u0026gt;) 要素のテキストを変更します  const paragraphs = document.getElementsByTagName(\u0026#34;p\u0026#34;); for (let p of paragraphs) { p.textContent = \u0026#34;ここがカスタム変更されたテキストです！\u0026#34;; } } コンテンツスクリプト用の JavaScript ファイル (content_script.js) の作成:\nこのファイルは、実際にウェブページのコンテンツに干渉するスクリプトを定義します。  // content_script.js  // このファイルは、コンテンツスクリプトとしてウェブページのすべてのフレームに注入されます // この例では、コンテンツスクリプトは特定の動作を行いません これで、簡単なブラウザ拡張機能が完成しました。拡張機能を使用するには、以下の手順を実行します。\n 上記のコードをコピーして、それぞれのファイルに保存します。 Chrome ブラウザのアドレスバーに chrome://extensions を入力し、拡張機能の管理ページにアクセスします。 ページの右上にある「デベロッパーモード」を有効にします。 「パッケージ化されていない拡張機能を読み込む」ボタンをクリックし、保存したファイルがあるフォルダを選択します。 拡張機能がリストに表示されるので、それを有効にします。  これで、拡張機能が有効になり、Chrome のアイコンをクリックするとポップアップが表示され、「要素を変更する」ボタンをクリックすると、現在のページ内のすべての段落のテキストがカスタム変更されます。\n参考サイト   https://developer.chrome.com/docs/extensions/\n  https://developer.chrome.com/docs/extensions/samples/\n  https://github.com/GoogleChrome/chrome-extensions-samples\n  ","permalink":"https://seiri-blog.github.io/posts/chrome-extension-developer/","summary":"mainfest の定義(必須) manifest.json は、Chrome 拡張機能を定義するためのファイルです。 このファイルは、拡張機能の基本的な情報、設定、権限、リソースなどを指","title":"Chrome拡張機能開発の入門"},{"content":"intra-martとは Intra-mart（イントラマート）は、日本のサイボウズ株式会社が提供しているエンタープライズポータルおよび業務アプリケーションの統合プラットフォームです。企業内の業務プロセスを効率化し、情報共有やコラボレーションを促進することを目的としています。\nIntra-martは、Webベースのシステムであり、主に企業内の様々な業務アプリケーション（経費精算、勤怠管理、人事管理など）を1つのポータルから統合的に利用できるようにします。また、ワークフロー機能やドキュメント管理、グループウェアなどの豊富な機能を提供しています。\nこのプラットフォームは、社内の情報共有やコミュニケーションを強化し、業務の効率化を図ることで、企業の生産性向上や意思決定の迅速化などを支援します。また、カスタマイズや拡張が比較的容易であるため、企業のニーズに合わせてカスタムアプリケーションを開発することも可能です。\nただし、ここで述べた情報は私の知識のカットオフ（2021年9月）時点のものであり、その後のIntra-martのバージョンや機能の変更については含まれていない可能性があります。最新の詳細については、サイボウズ株式会社の公式ウェブサイトや関連情報源を参照してください。\nintra-martのメリットとデメリット Intra-martの利用には、以下のようなメリットとデメリットがあります。\nメリット:\n  業務効率の向上: Intra-martは企業内の業務プロセスを統合し、1つのポータルからアクセスできるため、作業の効率化が図れます。情報の共有やコラボレーションが簡単に行えるため、業務の進行や意思決定が迅速化します。\n  カスタマイズ可能: Intra-martはカスタマイズや拡張が比較的容易であり、企業のニーズに合わせてカスタムアプリケーションを開発できます。これにより、特定の業務プロセスに適したアプリケーションを作成することが可能です。\n  グループウェア機能: Intra-martにはグループウェア機能が含まれており、社内のコミュニケーションやスケジュール管理が容易になります。チーム間のコミュニケーションを促進し、情報共有を強化します。\n  ワークフロー管理: ワークフロー機能により、業務プロセスの進捗を可視化し、タスクの進行状況を追跡できます。これにより、業務のスムーズな進行やタスクの割り当てが容易になります。\n  デメリット:\n  導入コスト: Intra-martはエンタープライズ向けの統合プラットフォームであるため、導入コストがかかることがあります。サーバーの導入やライセンス料などが必要となる場合があります。\n  学習コスト: Intra-martを適切に活用するためには、従業員に対してトレーニングや学習の機会を提供する必要があります。新しいシステムの導入に伴う学習コストが発生する可能性があります。\n  システム統合の課題: 既存のシステムとIntra-martを統合する場合、データの移行やシステムの整合性などに関連する課題が生じることがあります。特に、複数のレガシーシステムとの統合が必要な場合は、一定の工数を要する場合があります。\n  カスタマイズの複雑さ: カスタムアプリケーションを開発する際には、適切なスキルや専門知識が必要となる場合があります。適切なカスタマイズを行わないと、システムのパフォーマンスやセキュリティに問題が生じる可能性があります。\n  これらのメリットとデメリットを考慮して、企業は自社のニーズと予算に合った判断を行い、Intra-martを導入するかどうかを決定することが重要です。\nintra-martはどう使う？ Intra-martは企業内の業務プロセスを効率化し、情報共有やコラボレーションを促進するための統合プラットフォームです。以下に、Intra-martの一般的な使用方法と活用例をいくつか紹介します。\n  ワークフロー管理: Intra-martはワークフロー機能を提供しています。従業員は申請や承認、決裁などの業務プロセスをシステム上で進めることができます。例えば、経費精算や休暇申請などのプロセスがワークフローで管理され、タスクの進行状況が可視化されます。\n  グループウェア機能: Intra-martにはグループウェア機能が含まれており、チーム内のコミュニケーションやスケジュール管理が容易に行えます。メッセージのやりとりやファイルの共有などが可能で、チームの連携を強化します。\n  業務アプリケーションの利用: Intra-martは様々な業務アプリケーションを提供しています。経費精算、勤怠管理、人事管理、顧客管理などのアプリケーションを1つのポータルから利用できます。これにより、従業員は複数のシステムにログインする必要なく、一元的に業務を処理できます。\n  カスタムアプリケーションの開発: Intra-martはカスタマイズや拡張が可能です。企業は自社のニーズに合わせて特定の業務アプリケーションを開発できます。例えば、特定の業界や部門に特化したカスタムアプリケーションを作成することができます。\n  レポートや分析: Intra-martはデータの収集や分析機能を備えています。企業はシステムから得られるデータを活用して、業務の改善や意思決定に役立てることができます。\n  Intra-martの具体的な使い方は、企業の業務ニーズや要件によって異なります。導入前には、従業員のトレーニングやシステムの導入計画を立てることが重要です。また、システムの導入後も定期的な評価や改善を行い、効果的に活用することが成功の鍵となります。\nIntra-martは、サイボウズ株式会社が提供する製品群の中で、「intra-mart Accel Platform」と呼ばれるプラットフォームを指します。このプラットフォームはJavaをベースにしたエンタープライズ向けのWebアプリケーションを開発・運用するためのフレームワークであり、特定の書き方や構成に従ってアプリケーションを開発する必要があります。\n以下は、Intra-mart Accel Platformを使用してIntra-martアプリケーションを開発する一般的な手順の概要です：\n  開発環境のセットアップ: Intra-martを開発するには、Java開発環境が必要です。Java SDKとEclipse IDEをインストールし、Intra-martの開発プラグインを追加する必要があります。\n  プロジェクトの作成: Eclipseで新しいIntra-martアプリケーションのプロジェクトを作成します。\n  データベースの設定: Intra-martアプリケーションは通常、データベースを使用します。データベースの接続情報を設定し、必要なテーブルやカラムを定義します。\n  画面の設計: Intra-martでは画面を作成する際に、フィールドやボタン、テーブルなどのコンポーネントを配置してデザインを構築します。画面はHTMLやIntra-mart独自のタグを使用して作成されます。\n  ビジネスロジックの実装: 画面での入力や操作に対して、アプリケーションのビジネスロジックを実装します。Javaのコードを使用してデータの処理や業務ロジックを記述します。\n  ワークフローの設計（任意）: Intra-martではワークフロー機能を活用して、業務プロセスの流れを定義することができます。ワークフローを設計して業務の自動化や承認プロセスを実現します。\n  テストとデバッグ: 実装したアプリケーションをテストし、動作の確認やバグの修正を行います。\n  デプロイメント: 完成したIntra-martアプリケーションを本番環境にデプロイして運用を開始します。\n  なお、Intra-martの詳細な開発手順や記述方法については公式ドキュメントや開発者向けの情報源を参照することをおすすめします。Intra-martは広範な機能を提供しており、それに応じて開発手法や記述方法も異なる場合があります。\n","permalink":"https://seiri-blog.github.io/posts/what-is-intra-mart/","summary":"intra-martとは Intra-mart（イントラマート）は、日本のサイボウズ株式会社が提供しているエンタープライズポータルおよび業務ア","title":"intra-martの説明"},{"content":"WITH の説明 WITHは、SQLクエリ内で一時的な名前付きクエリ結果セットを作成するための構文です。これにより、複雑なクエリをより簡潔かつ効率的に記述することができます。\nWITH句は通常、サブクエリやビューを作成する代わりに使用されます。クエリ内で定義された一時的な結果セットは、その後のクエリの中で参照されることができます。これにより、クエリの可読性が向上し、複数回同じ結果を計算する必要がなくなります。\nWITH句は次のような形式で使用されます：\nWITH 一時テーブル名 (カラム1, カラム2, ...) AS ( サブクエリ ) SELECT * FROM 一時テーブル名; ここで、一時テーブル名は一時的な結果セットに対する名前です。カラムリストは省略可能で、一時テーブルのカラム名を指定することができます。サブクエリは一時テーブルの定義です。\n以下は、WITH句の使用例です：\nWITH 売上表 AS ( SELECT 商品名, SUM(数量) AS 総数量 FROM 注文テーブル GROUP BY 商品名 ) SELECT * FROM 売上表 WHERE 総数量 \u0026gt; 100; この例では、売上表という名前の一時テーブルを作成し、注文テーブルから商品ごとの総数量を計算します。その後、総数量が100を超える商品のみを選択しています。\nWITH句は、クエリの可読性を向上させ、複雑なクエリをより効率的に記述するための強力な機能です。\n","permalink":"https://seiri-blog.github.io/posts/sql-with/","summary":"WITH の説明 WITHは、SQLクエリ内で一時的な名前付きクエリ結果セットを作成するための構文です。これにより、複雑なクエリをより簡潔かつ効率的に","title":"SQL WITHの使い方"},{"content":"UNIONとは SQLのUNION演算子は、2つのSELECTクエリの結果を結合するために使用されるものです。UNIONを使用することで、2つの結果セットを1つの結果セットに結合し、重複を削除します。\nUNIONの使い方 UNIONの使い方は以下のようになります：\nSELECT column1, column2 FROM table1 UNION SELECT column1, column2 FROM table2; この例では、table1とtable2の2つのテーブルからデータを取得しています。それぞれのSELECTクエリは2つの列を選択していますが、必要に応じて複数の列を選択することができます。ただし、UNION演算子を使用する場合、選択される列数とデータ型は一致している必要があります。\nUNION ALLの使い方 また、UNION ALL演算子もあります。UNION ALLを使用する場合、重複を削除せずに2つの結果セットを結合します。\nSELECT column1, column2 FROM table1 UNION ALL SELECT column1, column2 FROM table2; UNION ALLは、重複を考慮しない場合やパフォーマンスが重要な場合に使用されます。\n2つテーブルの列名が違う時 SELECTの列名が異なる場合、UNION演算子を使用することはできますが、列名は最初のSELECT文の列名が適用されます。すなわち、結果セットの列名は最初のSELECT文の列名に基づいて命名されます。\n例を示します：\nテーブルA（column1, column2）：\n+----------+----------+ | column1 | column2 | +----------+----------+ | 1 | A | | 2 | B | +----------+----------+ テーブルB（column3, column4）：\n+----------+----------+ | column3 | column4 | +----------+----------+ | X | Y | | Z | W | +----------+----------+ 列名が異なる場合のUNIONの例：\nSELECT column1, column2 FROM tableA UNION SELECT column3, column4 FROM tableB; 結果セット：\n+----------+----------+ | column1 | column2 | +----------+----------+ | 1 | A | | 2 | B | | X | Y | | Z | W | +----------+----------+ 最初のSELECT文がテーブルAの列名を持っているため、結果セットの列名が「column1」と「column2」となります。テーブルBの列名は無視されます。\nもし、結果セットの列名を変更したい場合は、エイリアスを使用して列名を指定することができます。以下は、エイリアスを使用した例です：\nSELECT column1, column2 FROM tableA UNION SELECT column3 AS column1, column4 AS column2 FROM tableB; このクエリでは、テーブルBの列にエイリアスを付けてテーブルAの列名と合わせています。結果セットは次のようになります：\n+----------+----------+ | column1 | column2 | +----------+----------+ | 1 | A | | 2 | B | | X | Y | | Z | W | +----------+----------+ このように、エイリアスを使うことで、異なる列名を持つテーブルをUNIONする際に、結果セットの列名を自由に変更できます。\n","permalink":"https://seiri-blog.github.io/posts/sql-union/","summary":"UNIONとは SQLのUNION演算子は、2つのSELECTクエリの結果を結合するために使用されるものです。UNIONを使用することで、2つ","title":"SQL UNIONとUNION ALLの使い方"},{"content":"LWC 標準の日付選択コンポーネントは\u0026lt;lightning-input type=\u0026quot;date\u0026quot;\u0026gt;となりますが、カスタマイズことが出来かねますので、今回 LWC で 日付選択コンポーネントを作る方法を共有します。\n実装方法  customCalendar  \u0026lt;template\u0026gt; \u0026lt;div tabindex=\u0026#34;-1\u0026#34; class=\u0026#34;slds-datepicker slds-dropdown slds-dropdown_right date-picker-postion\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;slds-datepicker__filter slds-grid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-datepicker__filter_month slds-grid slds-grid_align-spread slds-grow\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;slds-align-middle\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;slds-button slds-button_icon slds-button_icon-container\u0026#34; title=\u0026#34;Previous Month\u0026#34; onclick=\u0026#34;{prev}\u0026#34; \u0026gt; \u0026lt;label\u0026gt; \u0026lt;lightning-icon icon-name=\u0026#34;utility:left\u0026#34; size=\u0026#34;x-small\u0026#34;\u0026gt; \u0026lt;/lightning-icon\u0026gt; \u0026lt;span class=\u0026#34;slds-assistive-text\u0026#34;\u0026gt;Previous Month\u0026lt;/span\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h2 class=\u0026#34;slds-align-middle\u0026#34;\u0026gt;{currentMonth}\u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;slds-align-middle\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;slds-button slds-button_icon slds-button_icon-container\u0026#34; title=\u0026#34;Next Month\u0026#34; onclick=\u0026#34;{next}\u0026#34; \u0026gt; \u0026lt;label\u0026gt; \u0026lt;lightning-icon icon-name=\u0026#34;utility:right\u0026#34; size=\u0026#34;x-small\u0026#34;\u0026gt; \u0026lt;/lightning-icon\u0026gt; \u0026lt;span class=\u0026#34;slds-assistive-text\u0026#34;\u0026gt;Next Month\u0026lt;/span\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;slds-shrink-none\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-select_container\u0026#34;\u0026gt; \u0026lt;select class=\u0026#34;slds-select\u0026#34; onchange=\u0026#34;{yearSelectChange}\u0026#34;\u0026gt; \u0026lt;template for:each=\u0026#34;{selectYearList}\u0026#34; for:item=\u0026#34;item\u0026#34; for:index=\u0026#34;index\u0026#34; \u0026gt; \u0026lt;template if:true=\u0026#34;{item.selected}\u0026#34;\u0026gt; \u0026lt;option key=\u0026#34;{item.value}\u0026#34; value=\u0026#34;{item.value}\u0026#34; selected\u0026gt; {item.value} \u0026lt;/option\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template if:false=\u0026#34;{item.selected}\u0026#34;\u0026gt; \u0026lt;option key=\u0026#34;{item.value}\u0026#34; value=\u0026#34;{item.value}\u0026#34;\u0026gt; {item.value} \u0026lt;/option\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;table class=\u0026#34;slds-datepicker__month\u0026#34; role=\u0026#34;grid\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th scope=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;abbr title=\u0026#34;Sunday\u0026#34;\u0026gt;Sun\u0026lt;/abbr\u0026gt; \u0026lt;/th\u0026gt; \u0026lt;th scope=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;abbr title=\u0026#34;Monday\u0026#34;\u0026gt;Mon\u0026lt;/abbr\u0026gt; \u0026lt;/th\u0026gt; \u0026lt;th scope=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;abbr title=\u0026#34;Tuesday\u0026#34;\u0026gt;Tue\u0026lt;/abbr\u0026gt; \u0026lt;/th\u0026gt; \u0026lt;th scope=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;abbr title=\u0026#34;Wednesday\u0026#34;\u0026gt;Wed\u0026lt;/abbr\u0026gt; \u0026lt;/th\u0026gt; \u0026lt;th scope=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;abbr title=\u0026#34;Thursday\u0026#34;\u0026gt;Thu\u0026lt;/abbr\u0026gt; \u0026lt;/th\u0026gt; \u0026lt;th scope=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;abbr title=\u0026#34;Friday\u0026#34;\u0026gt;Fri\u0026lt;/abbr\u0026gt; \u0026lt;/th\u0026gt; \u0026lt;th scope=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;abbr title=\u0026#34;Saturday\u0026#34;\u0026gt;Sat\u0026lt;/abbr\u0026gt; \u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;template for:each=\u0026#34;{dayList}\u0026#34; for:item=\u0026#34;items\u0026#34; for:index=\u0026#34;index\u0026#34;\u0026gt; \u0026lt;tr key=\u0026#34;{items.id}\u0026#34;\u0026gt; \u0026lt;template for:each=\u0026#34;{items.value}\u0026#34; for:item=\u0026#34;item\u0026#34; for:index=\u0026#34;idx\u0026#34;\u0026gt; \u0026lt;template lwc:if=\u0026#34;{item.adjacentMonth}\u0026#34;\u0026gt; \u0026lt;td class=\u0026#34;slds-day_adjacent-month\u0026#34; key=\u0026#34;{item.day}\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;slds-day\u0026#34; data-value=\u0026#34;{item.value}\u0026#34; onclick=\u0026#34;{dateSelectChange}\u0026#34; \u0026gt; {item.day} \u0026lt;/span\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template lwc:elseif=\u0026#34;{item.selected}\u0026#34;\u0026gt; \u0026lt;td class=\u0026#34;slds-is-selected\u0026#34; key=\u0026#34;{item.day}\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;slds-day\u0026#34; data-value=\u0026#34;{item.value}\u0026#34; onclick=\u0026#34;{dateSelectChange}\u0026#34; \u0026gt; {item.day} \u0026lt;/span\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template lwc:elseif=\u0026#34;{item.today}\u0026#34;\u0026gt; \u0026lt;td class=\u0026#34;slds-is-today\u0026#34; key=\u0026#34;{item.day}\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;slds-day\u0026#34; data-value=\u0026#34;{item.value}\u0026#34; onclick=\u0026#34;{dateSelectChange}\u0026#34; \u0026gt; {item.day} \u0026lt;/span\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template lwc:else\u0026gt; \u0026lt;td key=\u0026#34;{item.day}\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;slds-day\u0026#34; data-value=\u0026#34;{item.value}\u0026#34; onclick=\u0026#34;{dateSelectChange}\u0026#34; \u0026gt; {item.day} \u0026lt;/span\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;button class=\u0026#34;slds-button slds-align_absolute-center slds-text-link\u0026#34; onclick=\u0026#34;{todayClickHandler}\u0026#34; \u0026gt; \u0026lt;label\u0026gt;Today\u0026lt;/label\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, track, api } from \u0026#34;lwc\u0026#34;; import { dateFormat } from \u0026#34;c/utils\u0026#34;; export default class CustomCalendar extends LightningElement { //今日  today = new Date(); //内部値  @track _value; //年選択リスト  @track selectYearList = []; //日選択リスト  @track dayList = []; //現在年  @track currentYear; //現在月  @track currentMonth; //現在日  @track currentDay; /** * 値取得 */ @api get value() { return this._value; } /** * 値設定 */ set value(val) { this._value = val; if (val) { this.showDate = val; } else { this.showDate = dateFormat(this.today, \u0026#34;YYYY-mm-dd\u0026#34;); } //年  this.currentYear = Number(this.showDate.substring(0, 4)); //月  this.currentMonth = Number(this.showDate.substring(5, 7)); //日  this.currentDay = Number(this.showDate.substring(8, 10)); //カレンダー作成  this.createCalendar(this.currentYear, this.currentMonth); //プルダウン年を作成  this.createYearOption( 1900, this.today.getFullYear() + 100, this.currentYear ); } /** * 前の月表示 * @param {*} e イベント */ prev(e) { e.preventDefault(); if (this.currentMonth === 1) { this.currentMonth = 12; if (this.currentYear === 1900) { this.currentYear = 1900; } else { this.currentYear -= 1; } } else { this.currentMonth -= 1; } this.createCalendar(this.currentYear, this.currentMonth); //プルダウン年を作成  this.createYearOption( 1900, this.today.getFullYear() + 100, this.currentYear ); } /** * 次の月表示 * @param {*} e イベント */ next(e) { e.preventDefault(); if (this.currentMonth === 12) { this.currentMonth = 1; this.currentYear += 1; } else { this.currentMonth += 1; } this.createCalendar(this.currentYear, this.currentMonth); //プルダウン年を作成  this.createYearOption( 1900, this.today.getFullYear() + 100, this.currentYear ); } /** * カレンダー作成 * @param {*} year 年 * @param {*} month 月 */ createCalendar(year, month) { let count = 0; let startDayOfWeek = new Date(year, month, 1).getDay(); let endDate = new Date(year, month + 1, 0).getDate(); let lastMonthEndDate = new Date(year, month, 0).getDate(); let row = Math.ceil((startDayOfWeek + endDate) / 7); this.dayList = []; let selectedYear; let selectedMonth; if (this.value) { //年  selectedYear = Number(this.showDate.substring(0, 4)); //月  selectedMonth = Number(this.showDate.substring(5, 7)); } // 1行ずつ設定  for (let i = 0; i \u0026lt; row; i++) { this.dayList.push({ value: [], id: i }); // 1colum単位で設定  for (let j = 0; j \u0026lt; 7; j++) { if (i === 0 \u0026amp;\u0026amp; j \u0026lt; startDayOfWeek) { // 1行目で1日まで先月の日付を設定  this.dayList[i].value.push({ adjacentMonth: true, today: false, selected: false, day: lastMonthEndDate - startDayOfWeek + j + 1, value: `${this.currentYear}-${(this.currentMonth - 1) .toString() .padStart(2, \u0026#34;0\u0026#34;)}-${(lastMonthEndDate - startDayOfWeek + j + 1) .toString() .padStart(2, \u0026#34;0\u0026#34;)}`, }); } else if (count \u0026gt;= endDate) { // 最終行で最終日以降、翌月の日付を設定  count++; this.dayList[i].value.push({ adjacentMonth: true, today: false, selected: false, day: count - endDate, value: `${this.currentYear}-${(this.currentMonth + 1) .toString() .padStart(2, \u0026#34;0\u0026#34;)}-${(count - endDate) .toString() .padStart(2, \u0026#34;0\u0026#34;)}`, }); } else { // 当月の日付を曜日に照らし合わせて設定  count++; if ( this.value \u0026amp;\u0026amp; year === selectedYear \u0026amp;\u0026amp; month === selectedMonth \u0026amp;\u0026amp; count === this.currentDay ) { this.dayList[i].value.push({ adjacentMonth: false, today: false, selected: true, day: count, value: `${this.currentYear}-${this.currentMonth .toString() .padStart(2, \u0026#34;0\u0026#34;)}-${count.toString().padStart(2, \u0026#34;0\u0026#34;)}`, }); } else if ( year === this.today.getFullYear() \u0026amp;\u0026amp; month === this.today.getMonth() + 1 \u0026amp;\u0026amp; count === this.today.getDate() ) { this.dayList[i].value.push({ adjacentMonth: false, today: true, selected: false, day: count, value: `${this.currentYear}-${this.currentMonth .toString() .padStart(2, \u0026#34;0\u0026#34;)}-${count.toString().padStart(2, \u0026#34;0\u0026#34;)}`, }); } else { this.dayList[i].value.push({ adjacentMonth: false, today: false, selected: false, day: count, value: `${this.currentYear}-${this.currentMonth .toString() .padStart(2, \u0026#34;0\u0026#34;)}-${count.toString().padStart(2, \u0026#34;0\u0026#34;)}`, }); } } } } } /** * セレクトボックスの中にオプションを生成する * @param {number} startNum オプションを生成する最初の数値 * @param {number} endNum オプションを生成する最後の数値 * @param {number} currentYear 現在の日付にマッチする数値 */ createYearOption(startNum, endNum, currentYear) { for (let year = startNum; year \u0026lt;= endNum; year++) { this.selectYearList.push({ value: year, selected: year === currentYear, }); } } /** * 年を選択 * @param {*} e */ yearSelectChange(e) { e.preventDefault(); let selectedIndex = e.target.selectedIndex; this.currentYear = e.target.options[selectedIndex].value; this.createCalendar(this.currentYear, this.currentMonth); } /** * CSSスタイル削除 */ removeCurrentlySelectedDateAttributes() { const element = this.template.querySelector( \u0026#34;td[class*=\u0026#39;slds-is-selected\u0026#39;]\u0026#34; ); if (element) { element.classList.remove(\u0026#34;slds-is-selected\u0026#34;); } } /** * 日付を選択 * @param {*} e */ dateSelectChange(e) { e.preventDefault(); let target = e.target; this.removeCurrentlySelectedDateAttributes(); target.parentElement.classList.add(\u0026#34;slds-is-selected\u0026#34;); let dateStr = target.dataset.value; this.dispatchEvent( new CustomEvent(\u0026#34;select\u0026#34;, { detail: dateStr, }) ); } /** * 今日を選択 * @param {*} e */ todayClickHandler(e) { e.preventDefault(); this.dispatchEvent( new CustomEvent(\u0026#34;select\u0026#34;, { detail: dateFormat(this.today, \u0026#34;YYYY-mm-dd\u0026#34;), }) ); } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;55.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;false\u0026lt;/isExposed\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt;  customDatePicker  \u0026lt;template\u0026gt; \u0026lt;div tabindex=\u0026#34;-1\u0026#34; class=\u0026#34;slds-form-element__control slds-size_1-of-1 slds-dropdown-trigger slds-dropdown-trigger_click slds-is-open\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;custom-input-label\u0026#34;\u0026gt; \u0026lt;template if:true=\u0026#34;{required}\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;required-mark\u0026#34;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; {label} \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;slds-form-element__control slds-size_1-of-1 slds-input-has-icon slds-input-has-icon_right\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;{inputClass}\u0026#34;\u0026gt; \u0026lt;input class=\u0026#34;slds-input\u0026#34; onfocus=\u0026#34;{focusHandler}\u0026#34; onclick=\u0026#34;{clickHandler}\u0026#34; onchange=\u0026#34;{changeHandler}\u0026#34; value=\u0026#34;{value}\u0026#34; /\u0026gt; \u0026lt;div class=\u0026#34;slds-button slds-button_icon slds-input__icon slds-input__icon_right\u0026#34; title=\u0026#34;Select a date\u0026#34; \u0026gt; \u0026lt;lightning-icon icon-name=\u0026#34;utility:event\u0026#34; size=\u0026#34;x-small\u0026#34;\u0026gt; \u0026lt;/lightning-icon\u0026gt; \u0026lt;span class=\u0026#34;slds-assistive-text\u0026#34;\u0026gt;Select a date\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template lwc:if=\u0026#34;{isHasError}\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-has-error\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-form-element__help slds-show\u0026#34;\u0026gt;{errorMessage}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template lwc:if=\u0026#34;{_open}\u0026#34;\u0026gt; \u0026lt;c-custom-calendar onselect=\u0026#34;{calendarSelectHandler}\u0026#34; value=\u0026#34;{calendarVal}\u0026#34; onmouseover=\u0026#34;{handleMouseOver}\u0026#34; onmouseout=\u0026#34;{handleMouseOut}\u0026#34; \u0026gt;\u0026lt;/c-custom-calendar\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, api, track } from \u0026#34;lwc\u0026#34;; import { toDate } from \u0026#34;c/utils\u0026#34;; /** * 日付選択コンポーネント */ export default class CustomDatePicker extends LightningElement { //ラベル  @api label; //必須  @api required; //名  @api name; //最小値  @api min; //最大値  @api max; //最大値超えるメッセージ  @api messageWhenRangeOverflow = \u0026#34;The number is too high.\u0026#34;; //最小値以下のメッセージ  @api messageWhenRangeUnderflow = \u0026#34;The number is too low.\u0026#34;; //必須メッセージ  @api messageWhenValueMissing = \u0026#34;Complete this field.\u0026#34;; //エラーありフラグ  @track isHasError = false; //値  @track _value = \u0026#34;\u0026#34;; //カレンダー選択値  @track calendarVal; //エラーメッセージ  @track errorMessage; _open = false; _over = false; @api get value() { return this._value; } set value(val) { if (val.length \u0026gt;= 8) { //年  const year = val.substring(0, 4); //月  const month = val.substring(5, 7); //日  const day = val.substring(8, 10); this._value = `${month}/${day}/${year}`; this.calendarVal = val; } } /** * CSSスタイル */ get inputClass() { if (this.isHasError) { return \u0026#34;slds-input-has-icon slds-input-has-icon_right slds-has-error\u0026#34;; } return \u0026#34;slds-input-has-icon slds-input-has-icon_right\u0026#34;; } /** * エラーがあるかどうかをチェックする */ hasError() { const reg = new RegExp(/^[0-9]{2}\\/[0-9]{2}\\/[0-9]{4}$/); if (this.max \u0026amp;\u0026amp; this.value \u0026amp;\u0026amp; toDate(this.value) \u0026gt; toDate(this.max)) { this.isHasError = true; this.errorMessage = this.messageWhenRangeOverflow; } else if ( this.min \u0026amp;\u0026amp; this.value \u0026amp;\u0026amp; toDate(this.value) \u0026lt; toDate(this.min) ) { this.isHasError = true; this.errorMessage = this.messageWhenRangeUnderflow; } else if (this.required \u0026amp;\u0026amp; !this.value) { this.errorMessage = this.messageWhenValueMissing; this.isHasError = true; this._value = null; } else if (this.value \u0026amp;\u0026amp; !reg.exec(this.value)) { this.errorMessage = this.messageWhenValueMissing; this.isHasError = true; this._value = null; } else if (this.value \u0026amp;\u0026amp; reg.exec(this.value)) { this.errorMessage = this.messageWhenValueMissing; this.isHasError = false; } else if (!this.value) { this.errorMessage = this.messageWhenValueMissing; this.isHasError = false; } } /** * チェンジイベントハンドラ * @param {*} event */ changeHandler(event) { this.closeDropdown(); this._value = event.target.value; this.hasError(); } /** * 入力チェック * @returns チェック結果 */ @api checkValidity() { this.hasError(); return !this.isHasError; } /** * カレンダー選択 * @param {*} event */ calendarSelectHandler(event) { event.preventDefault(); const value = event.detail; this.template.host.value = value; this.calendarVal = value; this.hasError(); this.dispatchEvent( new CustomEvent(\u0026#34;select\u0026#34;, { detail: value, }) ); this.closeDropdown(); } /* * following pair of functions are a clever way of handling a click outside, * despite us not having access to the outside dom. * see: https://salesforce.stackexchange.com/questions/255691/handle-click-outside-element-in-lwc */ focusHandler(event) { //prevent firing more than once per focus (too many listeners get added)  if (this._open) { return; } event.cancelBubble = true; event.stopPropagation(); event.preventDefault(); this.openDropdown(); setTimeout(() =\u0026gt; { document.addEventListener(\u0026#34;click\u0026#34;, this.handleClose, false); }, 100); } clickHandler(event) { event.cancelBubble = true; event.stopPropagation(); event.preventDefault(); } /** * * @param {*} event * @returns */ handleClose = (event) =\u0026gt; { if (this._over) { return; } event.stopPropagation(); this.closeDropdown(); document.removeEventListener(\u0026#34;click\u0026#34;, this.handleClose, false); }; /** * */ openDropdown() { this._open = true; this._over = false; } /** * */ closeDropdown() { this._open = false; this._over = false; } /** * */ handleMouseOver() { this._over = true; } /** * */ handleMouseOut() { this._over = false; } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;55.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;false\u0026lt;/isExposed\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt;  customDatePickerContainer  \u0026lt;template\u0026gt; \u0026lt;c-custom-date-picker onselect=\u0026#34;{selectHandler}\u0026#34;\u0026gt;\u0026lt;/c-custom-date-picker\u0026gt; date: {date} \u0026lt;/template\u0026gt; import { LightningElement, track } from \u0026#34;lwc\u0026#34;; export default class CustomDatePickerContainer extends LightningElement { @track date; selectHandler(event) { this.date = event.detail; } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;55.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;true\u0026lt;/isExposed\u0026gt; \u0026lt;targets\u0026gt; \u0026lt;target\u0026gt;lightning__Tab\u0026lt;/target\u0026gt; \u0026lt;/targets\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt; 動作確認 \n\n\n参考 https://github.com/RyuSeiri/salesforce-custom-lwc-component/tree/main/lwc-custom-date-picker\n","permalink":"https://seiri-blog.github.io/posts/lwc-how-to-make-a-custom-date-picker/","summary":"LWC 標準の日付選択コンポーネントは\u0026lt;lightning-input type=\u0026quot;date\u0026quot;\u0026gt;となりますが、カスタ","title":"【Salesforce】LWCで日付選択コンポーネントを作る"},{"content":"lightning/modal モジュール 「lightning/modal」はSalesforceのLightningコンポーネントフレームワークにおけるモーダルダイアログ（またはモーダルウィンドウ）のコンポーネントです。モーダルダイアログは、ユーザーに情報を表示したり、アクションを実行したりするためのポップアップウィンドウを表示するために使用されます。以下は「lightning/modal」の主な特徴と使用法です：\n  情報の表示: モーダルダイアログは、重要な情報や通知をユーザーに提示するのに便利です。例えば、レコードの詳細情報を表示したり、更新を確認するためのポップアップを表示したりするのに使えます。\n  アクションの実行: ユーザーからの入力を受け付けるためのフォームを表示し、それに基づいて特定のアクションを実行することができます。例えば、レコードを新規作成するフォームを表示し、ユーザーが情報を入力して保存するといったことができます。\n  カスタマイズ可能: 「lightning/modal」はカスタマイズ可能で、外観や振る舞いを調整できます。スタイリングやボタンの配置、コンテンツの表示方法などを調整できます。\n  コンポーネントの統合: SalesforceのLightningコンポーネントと統合しやすく、他のLightningコンポーネントと連携して使用できます。データの受け渡しやアクションのトリガーなど、他のコンポーネントと連携してモーダルを活用できます。\n  以下は「lightning/modal」を使用する基本的な例です（JavaScriptコントローラを含む）：\n\u0026lt;template\u0026gt; \u0026lt;lightning-modal-header label=\u0026#34;My Modal Heading\u0026#34;\u0026gt;\u0026lt;/lightning-modal-header\u0026gt; \u0026lt;lightning-modal-body\u0026gt; Content: {content} \u0026lt;/lightning-modal-body\u0026gt; \u0026lt;lightning-modal-footer\u0026gt; \u0026lt;lightning-button label=\u0026#34;OK\u0026#34; onclick=\u0026#34;{handleOkay}\u0026#34;\u0026gt;\u0026lt;/lightning-button\u0026gt; \u0026lt;/lightning-modal-footer\u0026gt; \u0026lt;/template\u0026gt; import { api } from \u0026#34;lwc\u0026#34;; import LightningModal from \u0026#34;lightning/modal\u0026#34;; export default class MyModal extends LightningModal { @api content; handleOkay() { this.close(\u0026#34;okay\u0026#34;); } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;55.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;false\u0026lt;/isExposed\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt; モーダルを表示するラッパー\n\u0026lt;template\u0026gt; \u0026lt;lightning-button onclick=\u0026#34;{handleClick}\u0026#34; aria-haspopup=\u0026#34;dialog\u0026#34; label=\u0026#34;Open My Modal\u0026#34; \u0026gt; \u0026lt;/lightning-button\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement } from \u0026#34;lwc\u0026#34;; import MyModal from \u0026#34;c/myModal\u0026#34;; export default class MyApp extends LightningElement { async handleClick() { const result = await MyModal.open({ size: \u0026#34;large\u0026#34;, description: \u0026#34;Accessible description of modal\u0026#39;s purpose\u0026#34;, content: \u0026#34;Passed into content api\u0026#34;, }); } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;55.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;true\u0026lt;/isExposed\u0026gt; \u0026lt;targets\u0026gt; \u0026lt;target\u0026gt;lightning__Tab\u0026lt;/target\u0026gt; \u0026lt;target\u0026gt;lightning__RecordPage\u0026lt;/target\u0026gt; \u0026lt;target\u0026gt;lightning__AppPage\u0026lt;/target\u0026gt; \u0026lt;target\u0026gt;lightning__HomePage\u0026lt;/target\u0026gt; \u0026lt;/targets\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt; 動作確認 \n\n参考 https://developer.salesforce.com/docs/component-library/bundle/lightning-modal/documentation\nhttps://developer.salesforce.com/docs/component-library/bundle/lightning-modal-body/documentation\nhttps://developer.salesforce.com/docs/component-library/bundle/lightning-modal-footer/documentation\nhttps://developer.salesforce.com/docs/component-library/bundle/lightning-modal-header/documentation\n","permalink":"https://seiri-blog.github.io/posts/lwc-lightning-modal/","summary":"lightning/modal モジュール 「lightning/modal」はSalesforceのLightningコンポーネントフレームワークにおけるモーダルダイアロ","title":"【Salesforce】LWC の Lightning モーダル"},{"content":"lightning/confirm モジュール lightning/confirm モジュールを使用すると、コンポーネントに確認モードを作成できます。コンポーネントで LightningConfirm を使用して、続行する前にユーザーが応答するようにします。\nwindow.confirm() ではなく、LightningConfirm.open()を使用すると、より一貫したユーザーエクスペリエンスが得られます。同様の機能がありますが、LightningConfirm.open()はクロスソース iframe で動作し、Chrome と Safari は confrm()メソッドをサポートしていません。window.confrm()と異なり、LightningConfirm.open()はページ上の実行を停止せず、Promise に戻ります。閉じた後に実行するコードを確認するには、async/await または.then()を使用します。\n確認モードを起動するコンポーネントの lightning/confirm モジュールから LightningConfirm をインポートし、必要な属性を使用して LightningConform.open()を呼び出します。\nこの例では、2 つのボタン、OK、キャンセル を含むヘッダなし確認モードを作成します。.open()関数は promise を返します。OKをクリックすると promise は true に解析され、キャンセル をクリックすると false に解析されます。\n\u0026lt;template\u0026gt; \u0026lt;lightning-button onclick=\u0026#34;{onDeleteAllFilesButtonClick}\u0026#34; label=\u0026#34;Open Confirm Modal\u0026#34; \u0026gt; \u0026lt;/lightning-button\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, api } from \u0026#34;lwc\u0026#34;; import LightningConfirm from \u0026#34;lightning/confirm\u0026#34;; export default class recordCardQuickFiles extends LightningElement { @api recordId; async onDeleteAllFilesButtonClick() { const confirmation = await LightningConfirm.open({ message: \u0026#34;Are you sure you want to delete all files?\u0026#34;, variant: \u0026#34;headerless\u0026#34;, label: \u0026#34;Are you sure you want to delete all files?\u0026#34;, // setting theme would have no effect  }); if (confirmation) { //... proceed with  //... Apex Logic to delete Files.  //... We will not check this comment.  } } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;55.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;true\u0026lt;/isExposed\u0026gt; \u0026lt;targets\u0026gt; \u0026lt;target\u0026gt;lightning__Tab\u0026lt;/target\u0026gt; \u0026lt;target\u0026gt;lightning__RecordPage\u0026lt;/target\u0026gt; \u0026lt;target\u0026gt;lightning__AppPage\u0026lt;/target\u0026gt; \u0026lt;target\u0026gt;lightning__HomePage\u0026lt;/target\u0026gt; \u0026lt;/targets\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt; コンポーネントスタイル LightningConfirm  は次の属性をサポートしています。\n  message：アラートに表示されるメッセージテキスト。\n  label：タイトルテキスト、アリアラベルとしても使用されます。デフォルトの文字列はConfirmです。\n  variant：2 つの値、header、および headerless。デフォルトは header です。\n  theme：ヘッダーの色のテーマ。プロパティは、SLDS で次のオプションをサポートしています。\n default: white shade: gray inverse: dark blue alt-inverse: darker blue success: green info: gray-ish blue warning: yellow error: red offline: ​black  無効な値が指定されている場合、LightningConfirm  はデフォルトのテーマを使用します。\n  動作確認 \n\n参考 https://developer.salesforce.com/docs/component-library/bundle/lightning-confirm/documentation\n","permalink":"https://seiri-blog.github.io/posts/lwc-lightning-confirm/","summary":"lightning/confirm モジュール lightning/confirm モジュールを使用すると、コンポーネントに確認モードを作成できます。コンポーネントで LightningConfirm を使用して、続行する前にユーザーが応答する","title":"【Salesforce】LWC の Lightning Confirm"},{"content":"lightning/alert モジュール lightning/alert モジュールを使用すると、コンポーネントに警報モードを作成できます。機能やページだけでなく、コンポーネント上で LightningAlert を使用してシステム全体に影響を与える状態を伝えます。\nwindow.alert() ではなく、LightningAlert.open()を使用すると、より一貫したユーザーエクスペリエンスが得られます。同様の機能がありますが、LightningAlert.open()はクロスソース iframe で動作し、Chrome と Safari は alert()メソッドをサポートしていません。window.alert()と異なり、LightningAlert.open()はページ上の実行を停止せず、Promise に戻ります。アラートが閉じた後に実行するコードの場合は、async/await または.then()を使用します。\nimport LightningAlert from the 'lightning/alert' でコンポーネントにalertは開始します、必要な属性を使用して LightningAlert.open()を呼び出します。\nこの例では、エラー・メッセージと OK ボタンを使用したアラート・モードを作成します。open()関数は、OKをクリックしたときに解析される promise を返します。\n\u0026lt;template\u0026gt; \u0026lt;lightning-button onclick=\u0026#34;{handleAlertClick}\u0026#34; label=\u0026#34;show alert\u0026#34;\u0026gt; \u0026lt;/lightning-button\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement } from \u0026#34;lwc\u0026#34;; import LightningAlert from \u0026#34;lightning/alert\u0026#34;; export default class MyAlert extends LightningElement { async handleAlertClick() { await LightningAlert.open({ message: \u0026#34;this is the alert message\u0026#34;, theme: \u0026#34;error\u0026#34;, // a red theme intended for error states  label: \u0026#34;Error!\u0026#34;, // this is the header text  }); //Alert has been closed  } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;55.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;true\u0026lt;/isExposed\u0026gt; \u0026lt;targets\u0026gt; \u0026lt;target\u0026gt;lightning__Tab\u0026lt;/target\u0026gt; \u0026lt;target\u0026gt;lightning__RecordPage\u0026lt;/target\u0026gt; \u0026lt;target\u0026gt;lightning__AppPage\u0026lt;/target\u0026gt; \u0026lt;target\u0026gt;lightning__HomePage\u0026lt;/target\u0026gt; \u0026lt;/targets\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt; コンポーネントスタイル LightningAlert は次の属性をサポートしています。\n  message：アラートに表示されるメッセージテキスト。\n  label：タイトルテキスト、アリアラベルとしても使用されます。デフォルトの文字列はAlertです。\n  variant：2 つの値、header、および headerless。デフォルトは header です。\n  theme：ヘッダーの色のテーマ。プロパティは、SLDS で次のオプションをサポートしています。\n default: white shade: gray inverse: dark blue alt-inverse: darker blue success: green info: gray-ish blue warning: yellow error: red offline: ​black    無効な値が指定されている場合、LightningAlert はデフォルトのテーマを使用します。\n動作確認 \n\n参考 https://developer.salesforce.com/docs/component-library/bundle/lightning-alert/documentation\n","permalink":"https://seiri-blog.github.io/posts/lwc-lightning-alert/","summary":"lightning/alert モジュール lightning/alert モジュールを使用すると、コンポーネントに警報モードを作成できます。機能やページだけでなく、コンポーネント上で LightningAlert を使用してシステ","title":"【Salesforce】LWC のLightning Alert"},{"content":"二分探索木（Binary Search Tree）とは 二分探索木（Binary Search Tree）は、効率的なデータの挿入、検索、削除を可能にするデータ構造です。二分探索木は、各ノードが最大 2 つの子ノードを持ち、以下の性質を満たす特殊な木構造です。\n 左の子ノードの値は、親ノードの値よりも小さい（または等しい）。 右の子ノードの値は、親ノードの値よりも大きい。\nこの性質により、二分探索木では効率的な探索が可能になります。要素の追加や検索、削除において、各操作は木の高さに比例する時間で実行されます。木がバランスしている場合、操作の時間計算量は O(log n)となります。  以下に、二分探索木の例を示します。\n8 / \\ 3 10 / \\ \\ 1 6 14 / \\ / 4 7 13 この二分探索木では、根ノードの値が 8 であり、左の子ノードの値は 3、右の子ノードの値は 10 です。さらに左の子ノードの左の子ノードは 1、左の子ノードの右の子ノードは 6 といった具合に、各ノードが左右に分岐していきます。\n二分探索木では、要素の挿入や検索は再帰的な操作で行われます。挿入する要素は、木の適切な位置に追加されます。検索では、根ノードから始めて探している要素と比較し、左の子ノードまたは右の子ノードに進んでいきます。目的の要素が見つかるまで、再帰的に探索を続けます。\n二分探索木の利点は、効率的なデータの挿入や検索が可能な点です。ただし、木のバランスが崩れてしまうと、操作の時間計算量が最悪の場合 O(n)となることがあります。バランスを保つためには、平衡二分探索木（AVL 木や赤黒木など）を使用することが推奨されます。\nJavaScript で二分探索木（Binary Search Tree）を実装例 // ノードの定義 class Node { constructor(value) { this.value = value; this.left = null; this.right = null; } } // 二分探索木の定義 class BinarySearchTree { constructor() { this.root = null; } // 要素の挿入  insert(value) { var newNode = new Node(value); if (this.root === null) { this.root = newNode; } else { this.insertNode(this.root, newNode); } } insertNode(node, newNode) { if (newNode.value \u0026lt; node.value) { if (node.left === null) { node.left = newNode; } else { this.insertNode(node.left, newNode); } } else { if (node.right === null) { node.right = newNode; } else { this.insertNode(node.right, newNode); } } } // 要素の検索  search(value) { return this.searchNode(this.root, value); } searchNode(node, value) { if (node === null) { return false; } if (value \u0026lt; node.value) { return this.searchNode(node.left, value); } else if (value \u0026gt; node.value) { return this.searchNode(node.right, value); } else { return true; } } } // 使用例 var bst = new BinarySearchTree(); bst.insert(8); bst.insert(3); bst.insert(10); bst.insert(1); bst.insert(6); console.log(bst.search(6)); // true console.log(bst.search(9)); // false この実装では、Node クラスと BinarySearchTree クラスを定義しています。Node クラスは二分探索木の各ノードを表し、value（ノードの値）、left（左の子ノードへの参照）、right（右の子ノードへの参照）のプロパティを持ちます。\nBinarySearchTree クラスは二分探索木自体を表し、root プロパティが根ノードを指します。insert メソッドは新しい要素を挿入するためのもので、insertNode メソッドを再帰的に呼び出して適切な位置に新しいノードを挿入します。\nsearch メソッドは指定された値を探索するためのもので、searchNode メソッドを再帰的に呼び出して探索を行います。指定された値が存在する場合は true を返し、存在しない場合は false を返します。\n","permalink":"https://seiri-blog.github.io/posts/javascript-binary-search-tree/","summary":"二分探索木（Binary Search Tree）とは 二分探索木（Binary Search Tree）は、効率的なデータの挿入、検索、削除を可能にするデータ構造です。","title":"Javascriptで二分探索木"},{"content":"バブルソート（Bubble Sort）とは バブルソート（Bubble Sort）は、アルゴリズムの中でも比較的単純なソート方法の一つです。要素の比較と交換を繰り返し、配列を昇順または降順に整列します。\n以下に、バブルソートの手順を説明します。\n 配列の先頭から順番に隣接する要素を比較します。 左側の要素が右側の要素より大きい（または小さい）場合、両方の要素を交換します。 配列の最後まで比較と交換を行い、最大（または最小）の要素が配列の末尾に移動します。 末尾に移動した要素を除いて、残りの要素に対して再び 1 から 3 の手順を繰り返します。 ソート済みの範囲が配列の末尾に移動していくため、比較と交換の回数が減少します。 ソート済みの範囲が配列の先頭まで到達するまで繰り返し、全体の配列がソートされます。  バブルソートの特徴は、要素の交換が頻繁に行われることです。大きなデータセットに対しては効率が悪く、最悪の場合の時間計算量は O(n^2)です。しかし、実装が比較的単純で理解しやすいため、小規模なデータや部分的にソートされたデータに対しては効果的なソートアルゴリズムとして使われることもあります。\nJavaScript でのバブルソートの実装例 function bubbleSort(arr) { var len = arr.length; var swapped; do { swapped = false; for (var i = 0; i \u0026lt; len - 1; i++) { if (arr[i] \u0026gt; arr[i + 1]) { var temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; swapped = true; } } } while (swapped); return arr; } // 使用例 var array = [5, 3, 8, 4, 2]; console.log(bubbleSort(array)); // [2, 3, 4, 5, 8] この実装では、まず swapped という変数を用意し、ループ内で要素の交換が行われたかどうかを記録します。その後、do\u0026hellip;while ループを使って、配列を走査しながら隣接する要素を比較し、必要なら交換を行います。交換が行われた場合は swapped を true にして、再度ループを実行します。交換が行われなくなるまで繰り返すことで、配列がソートされます。\n上記の例では、配列[5, 3, 8, 4, 2]をバブルソートで昇順にソートしています。結果は[2, 3, 4, 5, 8]となります。\nただし、バブルソートは効率の面ではあまり優れていないため、大きなデータセットに対しては遅くなる可能性があります。他の高速なソートアルゴリズムを使用することが推奨されます。\n","permalink":"https://seiri-blog.github.io/posts/javascript-bubble-sort/","summary":"バブルソート（Bubble Sort）とは バブルソート（Bubble Sort）は、アルゴリズムの中でも比較的単純なソート方法の一つです。要素の","title":"Javascriptでバブルソート"},{"content":"PreChat とは Salesforce では、PreChat（事前チャット）機能を提供しています。この機能を使用すると、チャット会話を開始する前に顧客とのやり取りを行うことができます。PreChat 機能では、顧客情報を収集し、顧客の状況に基づいてチャット体験をカスタマイズすることができます。以下に Salesforce の PreChat の概要を説明します。\n  PreChat 設定: PreChat を有効にするためには、Salesforce Live Agent の設定で構成する必要があります。これには、顧客から収集したい PreChat フォームのフィールドを定義することが含まれます。例えば、名前、メールアドレス、または必要なカスタム情報などです。\n  PreChat フォーム: 顧客がウェブサイトを訪れてチャットを開始すると、PreChat フォームが表示され、必要な情報を収集します。フォームは、組織のブランディングや特定の要件に合わせてカスタマイズすることができます。\n  データ収集: 顧客が PreChat フォームに入力すると、提供されたデータはチャットのトランスクリプトとしてキャプチャされます。特定のフィールドが必須かオプションかを指定することができます。\n  ルーティングとカスタマイズ: PreChat フォームが送信されると、Salesforce Live Agent は収集された情報を使用してチャットリクエストのルーティング方法を決定します。たとえば、顧客の入力に基づいてチャットを特定のエージェントや部門にルーティングすることができます。\n  パーソナライズ: PreChat データを使用して、エージェントに顧客情報を表示することで、チャット体験をパーソナライズすることができます。これにより、会話が始まる前にエージェントが顧客の問い合わせや懸念についての文脈を把握することができ、全体的な顧客体験が向上します。\n  統合: 収集された PreChat データは、他の Salesforce の機能や機能と統合することができます。たとえば、PreChat 情報に基づいて Salesforce CRM でリード、コンタクト、ケースを自動的に作成することができます。\n  チャット後のアクション: チャットセッションが終了すると、PreChat データとチャットのトランスクリプトは、さらなる分析や報告、顧客へのフォローアップに使用することができます。\n  PreChat フォームのカスタマイズ Salesforce Experience Cloud における PreChat（事前チャット）のカスタマイズ方法について説明します。\n PreChat（事前チャット）フォームのカスタマイズ:   PreChat（事前チャット）フォームは、顧客から収集したい情報を入力するためのフォームです。フォームの外観やフィールドの設定をカスタマイズすることができます。 フォームの外観やスタイルをカスタマイズするには、CSS（カスケーディングスタイルシート）を使用してフォームのスタイルを変更します。 フォームに表示するフィールドをカスタマイズするには、PreChat（事前チャット）フォームの設定画面で必要なフィールドを追加・削除したり、フィールドの表示順序を変更したりすることができます。  PreChat（事前チャット）フィールドのバリデーション:   PreChat（事前チャット）フィールドに対してバリデーションルールを設定することができます。これにより、顧客が正しい形式や必要な情報を入力するように制限することができます。 バリデーションルールは、必須フィールドの設定や特定のフィールドの入力パターンのチェックなど、顧客が正しい情報を提供することができるようにサポートします。  PreChat（事前チャット）ルーティングのカスタマイズ:   PreChat（事前チャット）ルーティングは、チャットリクエストを適切なエージェントやグループに割り当てるためのルールを設定するものです。このルーティングの条件や基準をカスタマイズすることができます。 ルーティング条件として、PreChat（事前チャット）フォームで収集した情報やチャットリクエストの属性を活用することができます。例えば、特定のキーワードや選択肢に基づいてルーティングを行ったり、特定のエージェントやグループに優先的に割り当てることができます。  LWC で PreChat フォームのカスタマイズ Salesforce Lightning Web Component（LWC）を使用して Chat フォームをカスタマイズする手順を説明します。\nSalesforce Developer Console や Salesforce CLI を使用して、新しい LWC コンポーネントを作成します。例えば、chatForm という名前の LWC コンポーネントを作成します。\n chatForm.html  \u0026lt;template\u0026gt; \u0026lt;template if:true=\u0026#34;{backgroundImgURL}\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;{backgroundImgURL}\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;lightning-card title=\u0026#34;Prechat Form\u0026#34;\u0026gt; \u0026lt;template class=\u0026#34;slds-m-around_medium\u0026#34; for:each=\u0026#34;{fields}\u0026#34; for:item=\u0026#34;field\u0026#34;\u0026gt; \u0026lt;div key=\u0026#34;{field.name}\u0026#34;\u0026gt; \u0026lt;lightning-input key=\u0026#34;{field.name}\u0026#34; name=\u0026#34;{field.name}\u0026#34; label=\u0026#34;{field.label}\u0026#34; value=\u0026#34;{field.value}\u0026#34; max-length=\u0026#34;{field.maxLength}\u0026#34; required=\u0026#34;{field.required}\u0026#34; \u0026gt;\u0026lt;/lightning-input\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/lightning-card\u0026gt; \u0026lt;lightning-button label=\u0026#34;{startChatLabel}\u0026#34; title=\u0026#34;{startChatLabel}\u0026#34; onclick=\u0026#34;{handleStartChat}\u0026#34; class=\u0026#34;slds-m-left_x-small\u0026#34; \u0026gt; \u0026lt;/lightning-button\u0026gt; \u0026lt;/template\u0026gt;  chatForm.js  import BasePrechat from \u0026#34;lightningsnapin/basePrechat\u0026#34;; import { api, track } from \u0026#34;lwc\u0026#34;; import startChatLabel from \u0026#34;@salesforce/label/c.StartChat\u0026#34;; export default class ChatForm extends BasePrechat { @api prechatFields; @api backgroundImgURL; @track fields; @track namelist; startChatLabel; /** * Set the button label and prepare the prechat fields to be shown in the form. */ connectedCallback() { this.startChatLabel = startChatLabel; this.fields = this.prechatFields.map((field) =\u0026gt; { const { label, name, value, required, maxLength } = field; return { label, value, name, required, maxLength }; }); this.namelist = this.fields.map((field) =\u0026gt; field.name); } /** * Focus on the first input after this component renders. */ renderedCallback() { this.template.querySelector(\u0026#34;lightning-input\u0026#34;).focus(); } /** * On clicking the \u0026#39;Start Chatting\u0026#39; button, send a chat request. */ handleStartChat() { this.template.querySelectorAll(\u0026#34;lightning-input\u0026#34;).forEach((input) =\u0026gt; { this.fields[this.namelist.indexOf(input.name)].value = input.value; }); if (this.validateFields(this.fields).valid) { this.startChat(this.fields); } else { // Error handling if fields do not pass validation.  } } }  chatForm.css  :host { display: flex; flex-direction: column; } lightning-button { padding-top: 1em; }  chatForm.js-meta.xml  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;48.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;true\u0026lt;/isExposed\u0026gt; \u0026lt;targets\u0026gt; \u0026lt;target\u0026gt;lightningSnapin__PreChat\u0026lt;/target\u0026gt; \u0026lt;/targets\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt; LWC で PreChat カスタム項目の保存  カスタム項目を保存するために、chatForm のソースを修正  import BasePrechat from \u0026#34;lightningsnapin/basePrechat\u0026#34;; import { api, track } from \u0026#34;lwc\u0026#34;; import startChatLabel from \u0026#34;@salesforce/label/c.StartChat\u0026#34;; export default class ChatForm extends BasePrechat { @api prechatFields; @api backgroundImgURL; @track fields; @track namelist; startChatLabel; /** * Set the button label and prepare the prechat fields to be shown in the form. */ connectedCallback() { this.startChatLabel = startChatLabel; this.fields = this.prechatFields.map((field) =\u0026gt; { const { label, name, value, required, maxLength } = field; return { label, value, name, required, maxLength }; }); this.namelist = this.fields.map((field) =\u0026gt; field.name); } /** * Focus on the first input after this component renders. */ renderedCallback() { this.template.querySelector(\u0026#34;lightning-input\u0026#34;).focus(); } /** * On clicking the \u0026#39;Start Chatting\u0026#39; button, send a chat request. */ handleStartChat() { this.template.querySelectorAll(\u0026#34;lightning-input\u0026#34;).forEach((input) =\u0026gt; { this.fields[this.namelist.indexOf(input.name)].value = input.value; + this.dispatchCustomEvent(input.name, input.value);  }); if (this.validateFields(this.fields).valid) { this.startChat(this.fields); } else { // Error handling if fields do not pass validation. } } + /** + * dispatchCustomEvent + */ + dispatchCustomEvent(label, value) { + const preChatEvent = new CustomEvent(\u0026#39;setCustomField\u0026#39;, { + detail: { + customFieldLabel: label, + customFieldValue: value + } + }); + document.dispatchEvent(preChatEvent); + } } コミュニティでスニペット設定を使用するためのスニペット設定ファイルの作成   JavaScript を使用してスニペット設定ファイルを作成する  chatEnhancedSettings.jsという名前のファイルを作成する\nwindow._snapinsSnippetSettingsFile = (function(){ //保存するカスタム項目を宣言  var fields = [ { label: \u0026#39;Email\u0026#39;, transcriptFields: [\u0026#39;Email__c\u0026#39;] }, ... // ⇐ ここは複数定義可能  ]; embedded_svc.snippetSettingsFile.extraPrechatFormDetails = fields; //カスタムイベント監視  document.addEventListener( \u0026#39;setCustomField\u0026#39;, function(event) { embedded_svc.snippetSettingsFile.extraPrechatFormDetails.forEach(element =\u0026gt; { if(element.label === event.detail.customFieldLabel) { element.value = event.detail.customFieldValue; } }); }, false ); });  ファイルを静的リソースにアップロードする  静的リソースの名前はchatEnhancedSettingsに入力し、ファイルをchatEnhancedSettings.jsを選択し、[公開] を選択してから保存する\n 組み込みチャットコンポーネントの設定でファイルを参照する  エクスペリエンスビルダーで、[スニペット設定ファイル] 項目に静的リソース名 chatEnhancedSettingsを入力して、エクスペリエンスクラウドを公開する\n上記の手順に従って操作すれば、カスタム項目を ChatTranscript(LiveChatTranscript)に保存することができます。\n参考 https://help.salesforce.com/s/articleView?id=sf.live_agent_and_omni_compare_routing.htm\u0026amp;type=5\nhttps://help.salesforce.com/s/articleView?id=sf.snapins_chat_customize_prechat_form.htm\u0026amp;type=5\nhttps://developer.salesforce.com/docs/component-library/bundle/lightningsnapin-base-prechat/documentation\nhttps://developer.salesforce.com/docs/atlas.ja-jp.snapins_web_dev.meta/snapins_web_dev/snapins_web_snippet_settings_file.htm\n","permalink":"https://seiri-blog.github.io/posts/salesforce-prechat-cutom-feilds-to-chattranscript/","summary":"PreChat とは Salesforce では、PreChat（事前チャット）機能を提供しています。この機能を使用すると、チャット会話を開始する前に顧客とのやり取りを行うこと","title":"PreChatフォームのカスタマイズとカスタム項目保存"},{"content":"pip アップデータ Python の pip パッケージマネージャを使用して、インストールされているパッケージを最新バージョンにアップデートする方法はいくつかあります。以下にいくつかの方法を説明します。\n コマンドラインからアップデート:\nターミナルやコマンドプロンプトを開き、次のコマンドを入力します。  pip install --upgrade パッケージ名 例えば、requests パッケージをアップデートするには、次のように入力します。\npip install --upgrade requests パッケージリストをアップデートしてからアップデート:\nターミナルやコマンドプロンプトを開き、まずパッケージリストを最新の状態にアップデートします。  pip install --upgrade pip その後、次のコマンドですべてのパッケージをアップデートできます。\npip freeze --local | grep -v \u0026#39;^-e\u0026#39; | cut -d = -f 1 | xargs -n1 pip install -U requirements.txt ファイルを使用してアップデート:\nプロジェクトのルートディレクトリにある requirements.txt ファイルには、必要なパッケージとそのバージョンが記述されている場合があります。このファイルを使用して、すべてのパッケージをアップデートすることもできます。以下のコマンドを使用します。  pip install --upgrade -r requirements.txt どの方法を選ぶかは、状況やプロジェクトの要件によって異なります。\n最も一般的な方法は、コマンドラインから直接パッケージをアップデートする方法です。\n","permalink":"https://seiri-blog.github.io/posts/python-pip-upgrade/","summary":"pip アップデータ Python の pip パッケージマネージャを使用して、インストールされているパッケージを最新バージョンにアップデートする方法はいくつかあります","title":"Pythonのpipアップデータ方法"},{"content":"Salesforce のデバッグ方法   デバッグログの有効化: Salesforce のセットアップで、デバッグログを有効にすることができます。デバッグログは、Apex コードやトリガーの実行情報、SOQL クエリ、DML 操作などの詳細な情報を提供します。デバッグログは開発者コンソールまたはログのリストビューからアクセスできます。\n  System.debug メソッドの使用: Apex コード内で System.debug メソッドを使用して変数の値やメッセージを出力することができます。これにより、実行中のコードのステップバイステップのトレースが可能になります。\n  エクセプションのキャッチと処理: Apex コード内で例外をキャッチして、エラーメッセージや関連するデータを取得し、適切な処理を行うことができます。例外の情報は、デバッグログやメール通知などの方法で記録・表示できます。\n  開発者コンソールの使用: 開発者コンソールは Salesforce の統合開発環境（IDE）であり、Apex コードの実行、デバッグログの表示、SOQL クエリの実行などが可能です。また、開発者コンソールには便利なデバッグツールやログ監視ツールも備わっています。\n  デバッグログレベル Salesforce では、デバッグログを有効にする際に、異なるデバッグログレベルを選択することができます。以下に、一般的なデバッグログレベルを示します。\n  None: デバッグログは無効化されます。このレベルでは、デバッグログは生成されず、保存されません。\n  Error: エラーメッセージだけが記録されます。Apex コード内で発生した例外やエラーに関連する情報がログに表示されます。\n  Warn: エラーと警告メッセージが記録されます。警告は、実行中に問題が発生したが、処理は続行される場合に記録されます。\n  Info: インフォメーションメッセージも含めて記録されます。このレベルでは、Apex コードの実行情報や SOQL クエリの詳細な情報などがログに表示されます。\n  Debug: デバッグログの最も詳細なレベルです。エラー、警告、インフォメーションメッセージに加えて、さらに詳細なトレース情報がログに含まれます。\nこのレベルでは、Apex コード内のすべてのステップや変数の値などが表示されます。\n  Apex Replay Debugger Apex Replay Debugger の設定\n VS Code で Salesforce DX プロジェクトを開きます。 Salesforce DX プロジェクトにまだ .vscode/launch.json ファイルパスを設定した JSON ファイルがない場合は、そのファイル (と必要に応じてフォルダ) を作成します。 .vscode/launch.json ファイルを開きます。 Launch Apex Replay Debugger という設定を追加します。  { // Use IntelliSense to learn about possible attributes.  // Hover to view descriptions of existing attributes.  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387  \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Launch Apex Replay Debugger\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;apex-replay\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;logFile\u0026#34;: \u0026#34;${command:AskForLogFileName}\u0026#34;, \u0026#34;stopOnEntry\u0026#34;: true, \u0026#34;trace\u0026#34;: true } ] } ブレークポイントとチェックポイントの設定 生デバッグ用のデバッグログを生成する前に、ブレークポイントとチェックポイントを設定します。\n  行ブレークポイントを設定するには、.cls または .trigger ファイルを開き、行番号の左側にある列をクリックします。\n  行ブレークポイントが提供する量よりも情報が多い場合は、チェックポイントを追加します。コード行の実行時にヒープダンプを取得するチェックポイントを最大 5 つ設定できます。ローカル変数、静的変数、トリガコンテキスト変数はすべて、チェックポイントに役立つ情報があります。トリガコンテキスト変数はログに存在せず、チェックポイント場所でのみ使用できます。\nVisual Studio Code で、チェックポイントはブレークポイントの一種です。ログからの再生デバッグ時に、チェックポイントはブレークポイントのように機能します。Apex Replay Debugger セッションを開始する前に、チェックポイントを設定してアップロードします。\n Apex クラスまたはトリガの最大 5 つの行にチェックポイントを設定します。 チェックポイントを設定するコード行をクリックします。 コマンドパレットを開きます (Windows、Linux は Ctrl+Shift+P キー、macOS は Cmd+Shift+P キーを押します)。 [SFDX: Toggle Checkpoint (SFDX: チェックポイントを切り替え)] を実行します。  または、行番号の左側の溝を右クリックして、条件付きブレークポイントの追加 (Add Conditional Breakpoint) | 式 (Expression) を選択し、式を ブレークポイント に設定します。 または、既存のブレークポイントをチェックポイントに変換するには、そのブレークポイントを右クリックして、 ブレークポイントの編集 (Edit Breakpoint) | 式 (Expression) を選択します。 式を チェックポイント に設定します。\nチェックポイントを組織にアップロードしてヒープダンプ情報を収集するには、コマンドパレットを開き、[SFDX: Update Checkpoints in Org (SFDX: 組織のチェックポイントを更新)] を実行します。   チェックポイントを組織にアップロードしてヒープダンプ情報を収集するには、コマンドパレットを開き、[SFDX: Update Checkpoints in Org (SFDX: 組織のチェックポイントを更新)] を実行します。    スクラッチ組織またはデフォルトの開発組織の Apex Replay Debugger セッションの設定 スクラッチ組織、または Sandbox あるいは VS Code でデフォルト組織として設定した DE 組織で問題をデバッグする場合は、再生するデバッグログを生成するツールが用意されています。ログを有効にして問題を再現し、組織からデバッグログを取得したうえで、デバッグセッションを開始します。\n  ログを有効にするには、VS Code から、コマンドパレットを開き (Windows、Linux は Ctrl+Shift+P キー、macOS は Cmd+Shift+P キー)、[SFDX: Turn On Apex Debug Log for Replay Debugger (SFDX: Replay Debugger の Apex デバッグログをオン)] を実行します。\n  組織のデバッグログのリストを取得するには、[SFDX: Get Apex Debug Logs (SFDX: Apex デバッグログを取得)] を実行します。\n  再生するログをクリックします。VS Code にログがダウンロードされて開きます。\n  [SFDX: Launch Apex Replay Debugger with Current File (SFDX: 現在のファイルを使用して Apex Replay Debugger を起動)] を実行します。\n  参考 https://developer.salesforce.com/tools/vscode/ja/apex/replay-debugger\n","permalink":"https://seiri-blog.github.io/posts/salesforce-apex-debug/","summary":"Salesforce のデバッグ方法 デバッグログの有効化: Salesforce のセットアップで、デバッグログを有効にすることができます。デバッグログは、Apex コードやトリガーの","title":"【Salesforce】Apexデバッグ方法"},{"content":"Salesforce テストクラスは、Apex コードのユニットテストを実行するために使用されます。\n以下は、Salesforce テストクラスの作成手順の概要です。\n テストクラスの作成   開発環境（Salesforce 開発コンソールや統合開発環境など）を開きます。 新しい Apex クラスを作成し、テストクラスとしてマークします。  テストメソッドの作成:   テストクラス内に、テストメソッドを作成します。 メソッド名を test キーワードで始め、テスト対象のコードをカバーするようにメソッドを実装します。  テストデータの作成:   テストメソッド内で、テストデータを作成します。 テストデータは、テスト対象のコードが期待どおりに動作するかを確認するために使用されます。  テストケースの実行:   テストメソッド内で、テスト対象のコードを呼び出します。 テストケースが期待どおりに実行され、正常な結果が得られることを確認します。  アサーションの使用:   テストメソッド内で、アサーションを使用してテスト結果を検証します。 期待される結果と実際の結果を比較し、一致しない場合はテストが失敗するようにします。  テストクラスの実行:   テストクラス全体を実行し、すべてのテストメソッドが実行されることを確認します。 テスト結果を確認し、テストが成功したかどうかを判断します。  カバレッジの確認:   テストクラスの実行によってカバレッジが計算されます。 カバレッジレポートを確認し、テスト対象のコードが十分なカバレッジを持っていることを確認します。  具体的な例 以下は、具体的な例として、Salesforce のテストクラスを作成する手順とコードの一例です。この例では、アカウントオブジェクトのカスタムロジックをテストするためのテストクラスを作成します。\n テストクラスの作成:  @isTest public class AccountTestClass { // テストメソッドをここに追加していきます } テストメソッドの作成:  @isTest public class AccountTestClass { @isTest static void testAccountLogic() { // テストメソッドの実装  } } テストデータの作成:  @isTest public class AccountTestClass { @isTest static void testAccountLogic() { // アカウントレコードの作成  Account acc = new Account(Name = \u0026#39;Test Account\u0026#39;); insert acc; // その他のテストデータの作成や設定  } } テストケースの実行:  @isTest public class AccountTestClass { @isTest static void testAccountLogic() { Account acc = new Account(Name = \u0026#39;Test Account\u0026#39;); insert acc; // テスト対象のコードの呼び出し  // テスト対象のコードに対するアサーション  } } アサーションの使用:  @isTest public class AccountTestClass { @isTest static void testAccountLogic() { Account acc = new Account(Name = \u0026#39;Test Account\u0026#39;); insert acc; // テスト対象のコードの呼び出し  // 例: ロジックが正しく動作していることを確認するアサーション  System.assertEquals(\u0026#39;Expected Value\u0026#39;, acc.CustomField__c); } } テストクラスの実行:  @isTest public class AccountTestClass { @isTest static void testAccountLogic() { Account acc = new Account(Name = \u0026#39;Test Account\u0026#39;); insert acc; Test.startTest(); // テスト対象のメソッドの呼び出し  AccountClass.myMethod(acc.Id); // 例: カスタムロジックを実行するメソッドの呼び出し  Test.stopTest(); // 結果の検証  // 非同期処理の結果を検証するため、Test.stopTest() の後にアサーションを記述  Contact contact = [SELECT Id FROM Contact WHERE AccountId = :acc.Id LIMIT 1]; System.assertNotEquals(null, contact); } } Test.startTest()とTest.stopTest() メソッドは テストメソッド内で Test.startTest() を呼び出し、その後のコードを Test.startTest() と Test.stopTest() の間に配置することで、以下のようなテストのフローを実現できます。\n Test.startTest() の呼び出し:   Test.startTest() メソッドを呼び出すことで、テストの実行コンテキストが開始されます。この時点で、トランザクションが開始され、クエリリセットとクエリカウントの制限がリセットされます。  テストデータの作成:   Test.startTest() の後に、必要なテストデータを作成します。これには、テスト対象のオブジェクトや関連レコードの作成などが含まれます。  テスト対象のコードの実行:  テスト対象のコードを呼び出し、実行します。これには、Apex クラスやトリガーのメソッドの呼び出し、DML 操作、非同期プロセスの起動などが含まれます。\nTest.stopTest() の呼び出し:   Test.stopTest() メソッドを呼び出すことで、非同期プロセスやバッチ処理の実行をトリガーします。これにより、テスト実行中の非同期プロセスやバッチ処理が同期的に実行され、その結果が利用可能になります。  結果の検証:   Test.stopTest() の後に、アサーションを使用してテスト結果を検証します。これにより、テスト対象のコードが期待どおりの結果を生成するかを確認できます  Test.startTest() と Test.stopTest() の組み合わせは、非同期プロセスやバッチ処理の実行を同期化し、テストの結果を正確に検証するための重要な手法です。この方法を使用することで、非同期操作の完了を待機し、その結果をテスト内でアサーションできます\n","permalink":"https://seiri-blog.github.io/posts/salesforce-apex-test-class/","summary":"Salesforce テストクラスは、Apex コードのユニットテストを実行するために使用されます。 以下は、Salesforce テストクラスの作成手順の概要です。","title":"【Salesforce】Apexテストクラス作成する方法"},{"content":"ログアウト方法 1 \u0026lt;site_name\u0026gt;/secur/logout.jspへ遷移し、ログアウトする方法 lwc:logout \u0026lt;template\u0026gt; \u0026lt;lightning-button label=\u0026#34;ログアウト\u0026#34; title=\u0026#34;ログアウト\u0026#34; icon-position=\u0026#34;right\u0026#34; icon-name=\u0026#34;utility:logout\u0026#34; onclick=\u0026#34;{handleLogout}\u0026#34; \u0026gt;\u0026lt;/lightning-button\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, api } from \u0026#34;lwc\u0026#34;; export default class Logout extends LightningElement { /** * ログアウト */ handleLogout() { window.location.href = \u0026#34;\u0026lt;site_name\u0026gt;/secur/logout.jsp\u0026#34;; } } ログアウト方法 2 Aura コンポーネントの$A.get(e.force:logout).fire();を通じて、ログアウトする方法 lwc:logout \u0026lt;template\u0026gt; \u0026lt;lightning-button label=\u0026#34;ログアウト\u0026#34; title=\u0026#34;ログアウト\u0026#34; icon-position=\u0026#34;right\u0026#34; icon-name=\u0026#34;utility:logout\u0026#34; onclick=\u0026#34;{handleLogout}\u0026#34; \u0026gt;\u0026lt;/lightning-button\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, api } from \u0026#34;lwc\u0026#34;; export default class Logout extends LightningElement { /** * ログアウト */ handleLogout() { this.dispatchEvent(new CustomEvent(\u0026#34;logout\u0026#34;)); } } aura:logoutContainer \u0026lt;aura:component implements=\u0026#34;forceCommunity:availableForAllPageTypes\u0026#34; access=\u0026#34;global\u0026#34; \u0026gt; \u0026lt;c:customLogoutButton onlogout=\u0026#34;{!c.handleLogout}\u0026#34; /\u0026gt; \u0026lt;/aura:component\u0026gt; ({ handleLogout : function(component, event, helper) { $A.get(e.force:logout).fire(); } }) 参考 https://developer.salesforce.com/docs/atlas.en-us.exp_cloud_lwr.meta/exp_cloud_lwr/advanced_custom_logout.htm?q=Logout\n","permalink":"https://seiri-blog.github.io/posts/lwc-and-aura-experience-cloud-logout/","summary":"ログアウト方法 1 \u0026lt;site_name\u0026gt;/secur/logout.jspへ遷移し、ログアウトする方法 lwc:logout \u0026lt;template\u0026gt; \u0026lt;lightning-button label=\u0026#34;","title":"【Salesforce】LWCでExperience Cloudログアウトする方法"},{"content":"利用者情報の取得 利用者情報の取得 当サイトが利用者の個人情報を取得することはありません。\n利用者情報の利用 当サイトが利用者の個人情報を利用することはありません。\n利用者情報の第三者提供 当サイトが利用者の個人情報を第三者へ提供することはありません。\n著作権  当サイトに掲載されたコンテンツの著作権は、当サイトに帰属します。 当サイトに掲載されたコンテンツを無断で複製、再配布することは禁止します。 当サイトに掲載されたコンテンツに関する問い合わせや報告がある場合には、当サイトの連絡先までお問い合わせください。  免責事項  当サイト掲載されたコンテンツを利用したことによって生じた損害やトラブルについて、当サイトは一切の責任を負いません。 当サイトは掲載されたコンテンツについて、常に正確かつ完全な情報を提供するように努めていますが、その正確性や完全性について保証するものではありません。  使用ツール 当サイトでは、分析ツールとして Google Analytics(Google Inc.)を使用しており、Google Analytics が利用者の情報を自動取得する場合があります。\n取得する情報、利用目的、第三者への提供等につきましては、分析事業者のプライバシーポリシーよりご確認ください。\n連絡先 当サイトに関する問い合わせや報告がある場合には、コメントでお問い合わせください。\n","permalink":"https://seiri-blog.github.io/policy/","summary":"利用者情報の取得 利用者情報の取得 当サイトが利用者の個人情報を取得することはありません。 利用者情報の利用 当サイトが利用者の個人情報を利用するこ","title":"プライバシーポリシー"},{"content":"LWC での画面遷移  LWC の中にNavigationMixinを提供しています、それを利用して、画面を遷移することができます、今回はNavigationMixinを利用して 、ExperienceCloud サイト専用の画面遷移 Util を作成します。  this[NavigationMixin.Navigate]({ type: 'comm__namedPage' attributes: { pageName: '画面名' } }) 実装例 以下は、画面遷移 Util の実装例\nimport { NavigationMixin } from \u0026#34;lightning/navigation\u0026#34;; /** * 画面遷移(パラメータ無し) * @apram {*} that this * @param {*} pageName ページ名 */ export const navigationPage = (that, pageName) =\u0026gt; { that[NavigationMixin.Navigate]({ type: \u0026#39;comm__namedPage\u0026#39; attributes: { pageName: pageName } }) }; /** * 画面遷移(パラメータ有り) * @apram {*} that this * @param {*} pageName ページ名 * @param {*} param パラメータ */ export const navigationPage = (that, pageName, param) =\u0026gt; { that[NavigationMixin.Navigate]({ type: \u0026#39;comm__namedPage\u0026#39; attributes: { pageName: pageName }, state: param }) }; 参考 https://developer.salesforce.com/docs/component-library/documentation/ja-jp/lwc/lwc.use_navigate_basic\nhttps://developer.salesforce.com/docs/component-library/documentation/ja-jp/lwc/lwc.use_navigate_add_params_url\nhttps://developer.salesforce.com/docs/component-library/documentation/ja-jp/lwc/lwc.use_navigate_page_types\n","permalink":"https://seiri-blog.github.io/posts/salesforce-lwc-navagation-common-util/","summary":"LWC での画面遷移 LWC の中にNavigationMixinを提供しています、それを利用して、画面を遷移することができます、今回はNavigatio","title":"【Salesforce】ExperienceCloudサイト画面遷移Utilを自分で作る"},{"content":"       👋 Hi , I\u0026rsquo;m Seiri 現在 AWS と Salesforce を専念しています。 スキル   OS\n Win / Linux    開発言語\n Java Python JavaScript React Vue.js Apex LWC VBA    クラウド経験\n AWS Salesforce Oracle Cloud Infrastructure（OCI）    資格\n Salesforce Certified Administrator Salesforce Certified JavaScript Developer I Salesforce Certified Platform Developer I Salesforce Certified Platform Developer II Salesforce Certified Data Architect    ","permalink":"https://seiri-blog.github.io/profile/","summary":"👋 Hi , I\u0026rsquo;m Seiri 現在 AWS と Salesforce を専念しています。 スキル OS Win / Linux 開発言語 Java Python JavaScript React Vue.js Apex LWC VBA クラウド経験 AWS Salesforce Oracle Cloud Infrastructure（OCI） 資格 Salesforce","title":"プロファイル"},{"content":"環境構築 今回は Win11 システムでの環境構築方法を説明致します。\n  下記 URL で hugo をダウロードする\nhttps://github.com/gohugoio/hugo/releases/download/v0.111.3/hugo_extended_0.111.3_windows-amd64.zip\n※上記ダウンロードできない場合直接 https://github.com/gohugoio/hugo/releases にアクセスして、Windows のバージョンをダウンロードしてくだい。\n  ダウンロードしたファイルを解凍する\n  Cドライブに c:/hugo/bin フォルダを作成する\n  解凍したファイルに hugo.exe を c:/hugo/bin に移動する\n\n  システム環境変数設定を開いて、Path にc:/hugo/binを追加して保存する\n\n  最後は cmdを起動していhugo versionを実行する\n\n  ロカールサーバを立ち上がり 下記コマンド順序で実行して、最後ブラウザにhttp://localhost:1313にアクセスする\n$ hugo new site sitename $ cd sitename $ git init $ git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke themes/ananke $ echo \u0026#34;theme = \u0026#39;ananke\u0026#39;\u0026#34; \u0026gt;\u0026gt; config.toml $ hugo server 記事追加 下記コマンドを実行すると、content/postsフォルダに MD 記事ファイルを追加することができます\n$ hugo new posts/my-post.md 内容は Markdown 形式で書けます\n例：\n--- title: \u0026#34;my-Post\u0026#34; date: 2022-11-20T09:03:20-08:00 draft: true --- ## 目出し  内容内容内容内容内容内容内容 ビルド 下記コマンドを実行すると、public フォルダにビルドファイルが自動生成できます\n$ hugo Github に公開用のリポジトリを作成 リポジトリは Public に設定し、作成します\n\nビルド後のファイルをリポジトリにプッシュ public フォルダにすべてファイルをリポジトリにプッシュします\nGithub サイトを公開 リポジトリの[Setting][pages]Branchをmainに選択し、保存する。publish は一分ぐらいがかかります\n\n関連記事  Hugo と Hexo の違い  ","permalink":"https://seiri-blog.github.io/posts/create-hugo-site/","summary":"環境構築 今回は Win11 システムでの環境構築方法を説明致します。 下記 URL で hugo をダウロードする https://github.com/gohugoio/hugo/releases/download/v0.111.3/hugo_extended_0.111.3_windows-amd64.zip ※上記ダウンロードできない場合直接 https://github.com/gohugoio/hugo/releases にアクセスして、Wi","title":"Githubを利用してhugoサイト構築する方法"},{"content":"サイトポリシーとは サイトポリシーとは、ウェブサイトの運営者が訪問者に対して示す、サイトのルールや方針をまとめたページのことです。一般的に、サイトポリシーには以下のような情報が含まれます。\n  プライバシーポリシー\nウェブサイトがどのような個人情報を収集しているか、収集した情報をどのように使用しているか、そして情報を第三者とどのように共有しているかなどが明記されています。\n  著作権情報\nウェブサイトで使用している画像やコンテンツの著作権情報が明記されています。他者の著作物を無断で使用することは違法行為になりますので、著作権情報の明示が必要です。\n  免責事項\nウェブサイトで提供される情報の正確性や信頼性を保証することはできません。そこで、サイトポリシーには、提供される情報の正確性についての免責事項が記載されています。\n  利用規約\nウェブサイトの利用規約について説明されています。たとえば、サイトの利用条件、禁止事項、アカウント停止についての条件などが記載されます。\n  連絡先情報\nウェブサイト運営者の連絡先情報が明記されています。訪問者がウェブサイトについての質問や苦情、その他の問題を報告する場合、運営者と簡単に連絡を取ることができます。\n  サイトポリシーは、ウェブサイトを運営するうえで非常に重要な役割を果たします。訪問者に信頼を与えるとともに、法的な問題からウェブサイトを守るためにも、適切な内容を記載しておくことが必要です。\n以下は、ウェブサイトにおけるポリシーページの具体的な例です。  利用規約   ユーザーは、当サイトの提供するツールを利用する際に、以下のルールを守ることとします。 当サイトの提供するツールを無断で改変、複製、再配布することは禁止します。 当サイトの提供するツールを利用したことによって生じた損害について、当サイトは一切の責任を負いません。  プライバシーポリシー   当サイトは、ユーザーの個人情報を取り扱う場合には、適切に保護することを約束します。 当サイトは、ユーザーから提供された個人情報を、ユーザーの同意がない限り、第三者に提供しません。 当サイトは、個人情報を適切に管理することで、情報漏洩や不正アクセスなどのリスクを軽減します。  著作権に関するポリシー   当サイトに掲載されたコンテンツの著作権は、当サイトに帰属します。 当サイトに掲載されたコンテンツを無断で複製、再配布することは禁止します。 当サイトに掲載されたコンテンツに関する問い合わせや報告がある場合には、当サイトの連絡先までお問い合わせください。  免責事項   当サイトの提供するツールを利用したことによって生じた損害やトラブルについて、当サイトは一切の責任を負いません。 当サイトは、提供するツールについて、常に正確かつ完全な情報を提供するように努めていますが、その正確性や完全性について保証するものではありません。  連絡先   当サイトに関する問い合わせや報告がある場合には、以下の連絡先までお問い合わせください。 メールアドレス: example@example.com 住所: 東京都渋谷区 ○○○○○○○○○○○○○○  ","permalink":"https://seiri-blog.github.io/posts/site-policy-template/","summary":"サイトポリシーとは サイトポリシーとは、ウェブサイトの運営者が訪問者に対して示す、サイトのルールや方針をまとめたページのことです。一般的に、サ","title":"サイトポリシーテンプレート"},{"content":"VSCode の環境構築 今回に関しては設定は詳しく説明しません、やり方のみ詳しく説明させていただきます。\n 下記リンクを開いて、自分の PC にダウンロードする  https://github.com/RyuSeiri/Salesforce-Source-Format\n VSCode を開いて、Crl + Shift + Pキー打つ、create Project with Manifestを選択し、新しいプロジェクトを作成  \n\n\n 最初ダウロードしたファイルを全部さっき作成したプロジェクトフォルダの下にコピーする  \n VSCode のターミナルでnpm install --saveを実行する  \n .vscode/extensions.json中の拡張機能を全部インストールする  \n VSCode を開いて、Crl + Shift + Pキー打つ、Reload Windowを選択、プロジェクトをリロードする  \n動作確認  保存する時自動的にソースをフォーマットする SOQL もフォーマットでできる  フォーマット前 - public with sharing class test { - @AuraEnabled - public static string methodName(){ - try { - Account acc = [select Id, - Name from Account]; - return acc[0].Name; - } catch (Exception e) { - throw new AuraHandledException(e.getMessage()); - } - } - }  フォーマット後 + public with sharing class test { + @AuraEnabled + public static string methodName() { + try { + Account acc = [ + SELECT Id, Name + FROM Account + ]; + return acc[0].Name; + } catch (Exception e) { + throw new AuraHandledException(e.getMessage()); + } + } + }  参考\nhttps://developer.salesforce.com/tools/vscode/ja/user-guide/prettier\n","permalink":"https://seiri-blog.github.io/posts/salesforce-source-code-format/","summary":"VSCode の環境構築 今回に関しては設定は詳しく説明しません、やり方のみ詳しく説明させていただきます。 下記リンクを開いて、自分の PC にダウンロードする https://github.com/RyuSeiri/Salesforce-Source-Format","title":"VSCodeでSalesforceのコードフォーマットする方法"},{"content":"Hugo と Hexo は、両方とも静的サイトジェネレーターですが、いくつかの違いがあります。   開発言語：Hugo は Go 言語で書かれており、Hexo は JavaScript で書かれています。\n  テンプレートエンジン：Hugo は Go のテンプレートエンジンを使用していますが、Hexo は Swig という JavaScript のテンプレートエンジンを使用しています。\n  プラグインの数：Hexo は多くのプラグインがあり、機能の追加や拡張が容易です。一方、Hugo にも多数のプラグインがありますが、Hexo ほど多くはありません。\n  パフォーマンス：Hugo は非常に高速で、大規模なサイトでもスムーズに動作します。Hexo も高速ですが、Hugo ほど高速ではありません。\n  コミュニティの規模：Hexo のコミュニティは非常に活発で、質問やサポートが豊富にあります。Hugo のコミュニティも活発ですが、Hexo ほどではありません。\n  どちらが優れているかは、使用目的や個人の好みによって異なります。Hugo は高速でパフォーマンスが高いため、大規模なサイトを構築する場合に適しています。一方、Hexo は JavaScript で書かれているため、フロントエンド開発者にとって親しみやすく、豊富なプラグインがあるため、開発の拡張性が高いです。\n  Hugo のメリットとデメリット   Hugo のメリット：\n Hugo は非常に高速なビルドが可能で、大規模なサイトでもスムーズに動作します。 Go 言語で開発されているため、Go のコンパイラが必要な場合以外は簡単にインストールでき、高速で安全なコードを書くことができます。 Hugo には多くのプラグインがあり、機能の拡張が容易です。 シンプルなディレクトリ構造を使用しているため、プロジェクトの管理が容易です。    Hugo のデメリット：\n Hugo は Go のテンプレートエンジンを使用しており、テンプレートの学習コストが高くなることがあります。 テーマの変更が難しい場合があります。 管理画面がないため、テキストエディタや CLI を使用して編集する必要があります。    Hexo のメリットとデメリット   Hexo のメリット：\n テーマやプラグインの数が豊富で、オープンソースのコミュニティが大きいため、様々な機能を簡単に追加できます。 Markdown と Git の統合が強力であり、Gitを使用してバージョン管理できます。 管理画面があるため、ブログを簡単に投稿できます。 JavaScript はフロントエンド開発者にとって馴染み深い言語であり、開発の拡張性が高いです。    Hexo のデメリット：\n 構築時間が Hugo よりも長いことがあります。 大規模なサイトのビルドに時間がかかることがあります。 JavaScript で書かれているため、Node.js のインストールが必要です。 プラグインの競合が起こる場合があるため、依存関係の管理が必要です。    Hugo の主要な CLI コマンド   hugo new: 新しいコンテンツファイルを作成します。例えば、hugo new posts/my-first-post.mdは、content/posts/my-first-post.mdというファイルを作成します。\n  hugo server: ローカルサーバーを起動し、ウェブサイトをプレビューすることができます。変更を加えると、サイトは自動的に再読み込みされます。\n  hugo build: ウェブサイトをビルドし、静的なファイルを生成します。hugo コマンドを使用すると、自動的にビルドが実行されます。\n  hugo deploy: ウェブサイトを公開するために、ビルドされたファイルをリモートサーバーにアップロードします。リモートサーバーには、FTP、SFTP、GitHub PagesとNetlify などのサポートが含まれます。\n  hugo check: ウェブサイトを検証して、問題を特定します。たとえば、リンク切れや構文エラーを確認することができます。\n  Hexo の主要な CLI コマンド   hexo new: 新しいコンテンツファイルを作成します。例えば、hexo new My New Postは、source/_posts/My-New-Post.mdというファイルを作成します。\n  hexo server: ローカルサーバーを起動し、ウェブサイトをプレビューすることができます。変更を加えると、サイトは自動的に再読み込みされます。\n  hexo generate: ウェブサイトをビルドし、静的なファイルを生成します。hexo generateもしくはhexo g コマンドを使用すると、自動的にビルドが実行されます。\n  hexo deploy: ウェブサイトを公開するために、ビルドされたファイルをリモートサーバーにアップロードします。リモートサーバーには、FTP、SFTP、GitHub PagesとNetlify などのサポートが含まれます。\n  hexo clean: キャッシュや生成されたファイルを削除します。これにより、新しいビルドが正しく実行されます。\n  ","permalink":"https://seiri-blog.github.io/posts/hugo-and-hexo-difference/","summary":"Hugo と Hexo は、両方とも静的サイトジェネレーターですが、いくつかの違いがあります。 開発言語：Hugo は Go 言語で書かれており、Hexo は JavaScript で書かれて","title":"HugoとHexoの違い"},{"content":"GitHub プロファイルを作成するには、以下の手順を実行します。   GitHub にログインし、右上のアイコンをクリックして、ドロップダウンメニューを表示します。\n\n  Your profileをクリックして、プロフィールページに移動します。\n\n  Edit profileをクリックして、プロフィールを編集します。ここで、プロフィール画像、名前、所属、自己紹介などを編集することができます。\n\n\n  Profile READMEを追加するには、新しいリポジトリを作成します。リポジトリ名は\\\u0026lt;username\u0026gt;/\\\u0026lt;username\u0026gt;としてください。例えば、あなたのユーザー名がRyuSeiriの場合、リポジトリ名はRyuSeiri/RyuSeiriとなります。\n\n  Create READMEをクリックして、README ファイルを作成します。README.MD ファイルには、プロフィールの詳細を記述できます。\n\n  リポジトリを公開すると、プロフィールページに README.MD が表示されます。\n\n  GitHub のプロファイルを綺麗に装飾するためのテンプレートは、いくつかのオープンソースのプロジェクトが提供しています。   GitHub Profile README Generator\nhttps://github.com/rahuldkjain/github-profile-readme-generator\nGitHub Profile README Generator は、プロフィール用の README を簡単に作成するためのオンラインツールです。豊富なテンプレートを用意しており、Markdown 形式での出力もサポートしています。\n  awesome-github-profiles\nhttps://github.com/abhisheknaiidu/awesome-github-profile-readme\nawesome-github-profiles は、GitHub のプロフィールを装飾するための多様なテンプレートを提供するリポジトリです。アイコン、バッジ、グラフなどを組み合わせたオリジナルのプロフィールを作成することができます。\n  GitHub Profile README Art\nhttps://github.com/DenverCoder1/github-profile-ascii-art\nGitHub Profile README Art は、アスキーアートを使用したプロフィール用の README テンプレートを提供するリポジトリです。シンプルなデザインで、すぐに使えるアスキーアートも多数用意されています。\n  GitHub Readme Stats\nhttps://github.com/anuraghazra/github-readme-stats\nGitHub Readme Stats は、GitHub のプロフィール用の README テンプレートを提供するリポジトリです。アクティビティ、リポジトリ、フォロワー、フォロー数などの情報を、美しくデザインされたグラフィックで表示することができます。\n  Devcard\nhttps://github.com/msaaddev/devcard\nDevcard は、GitHub のプロフィール用の README テンプレートを提供するリポジトリです。ユーザー名、プロフィール画像、技術スタック、ステータス、リポジトリ、スキルなどを表示することができます。\n  Gitstalk\nhttps://github.com/thelittlewonder/gitstalk\nGitstalk は、GitHub のプロフィール用の README テンプレートを提供するリポジトリです。Gitstalk を使用すると、GitHub 上でのアクティビティやリポジトリなどの情報を表示することができます。\n  プロファイルにバッジを追加できます 例：\n\u0026lt;p\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-Amazon%20AWS-232F3E.svg?logo=amazon-aws\u0026amp;style=flat\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-Salesforce-fff?style=flat\u0026amp;logo=Salesforce\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-git-181717.svg?logo=git\u0026amp;style=flat\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-GitHub-181717.svg?logo=github\u0026amp;style=flat\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-Windows-0078D6.svg?logo=windows\u0026amp;style=flat\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-Nodejs-43853d?style=flat\u0026amp;logo=Node.js\u0026amp;logoColor=white\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-JavaScript-e5cd0c?style=flat\u0026amp;logo=JavaScript\u0026amp;logoColor=000\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-React-555.svg?logo=react\u0026amp;style=flat\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-Vue-555.svg?logo=vue.js\u0026amp;style=flat\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-HTML5-333.svg?logo=html5\u0026amp;style=flat\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-CSS3-1572B6.svg?logo=css3\u0026amp;style=flat\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-Python-F9DC3E.svg?logo=python\u0026amp;style=flat\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-Github_Actions-fff?style=flat\u0026amp;logo=github-actions\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-youtube-red?style=flat\u0026amp;logo=youtube\u0026quot; /\u0026gt; \u0026lt;/p\u0026gt;   バッジ作成するサイト：  Shields.io: https://shields.io/ Badgen: https://badgen.net/ For the Badge: https://forthebadge.com/ Simple Icons: https://simpleicons.org/ Devicon: https://devicons.github.io/devicon/ Flat Icon: https://www.flaticon.com/ IconFinder: https://www.iconfinder.com/ Icons8: https://icons8.com/    以上が、GitHub のプロフィール用のテンプレートの一部です。選択肢が多く、自分に合ったものを選んで、オリジナルのプロフィールを作成してください。\n最後 参考としては自分のプロファイルのソースを貼り付けますので、ご参照いただければと思います。\n\u0026lt;h1 align=\u0026quot;center\u0026quot;\u0026gt;👋 Hi , I'm Seiri\u0026lt;/h1\u0026gt; \u0026lt;h3 align=\u0026quot;center\u0026quot;\u0026gt;現在AWSとSalesforceを専念しています。\u0026lt;/h3\u0026gt; \u0026lt;p align=\u0026quot;center\u0026quot;\u0026gt; \u0026lt;a href=\u0026quot;https://knowstechnic.blogspot.com/\u0026quot;\u0026gt; \u0026lt;img src=\u0026quot;https://komarev.com/ghpvc/?username=Ryuseiri\u0026quot; alt=\u0026quot;Ryuseiri\u0026quot; /\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;http://twitter.com/Seiriryu\u0026quot;\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/twitter/follow/Seiriryu?label=Twitter\u0026amp;logo=twitter\u0026amp;style=flat\u0026quot; /\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;https://github.com/Ryuseiri\u0026quot;\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/github/followers/Ryuseiri?label=follow\u0026amp;logo=github\u0026amp;style=flat\u0026quot; /\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;https://stackoverflow.com/users/21109751/seiriryu\u0026quot;\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/stackexchange/stackoverflow/r/21109751?label=StackOverflow\u0026amp;logo=stack-overflow\u0026amp;style=flat\u0026quot; /\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;http://qiita.com/Seiri\u0026quot;\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://qiita-badge.apiapi.app/s/Seiri/contributions.svg\u0026quot; /\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;http://qiita.com/Seiri\u0026quot;\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://qiita-badge.apiapi.app/s/Seiri/posts.svg\u0026quot; /\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;!-- Label --\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-Amazon%20AWS-232F3E.svg?logo=amazon-aws\u0026amp;style=flat\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-Salesforce-fff?style=flat\u0026amp;logo=Salesforce\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-git-181717.svg?logo=git\u0026amp;style=flat\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-GitHub-181717.svg?logo=github\u0026amp;style=flat\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-Windows-0078D6.svg?logo=windows\u0026amp;style=flat\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-Nodejs-43853d?style=flat\u0026amp;logo=Node.js\u0026amp;logoColor=white\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-JavaScript-e5cd0c?style=flat\u0026amp;logo=JavaScript\u0026amp;logoColor=000\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-React-555.svg?logo=react\u0026amp;style=flat\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-Vue-555.svg?logo=vue.js\u0026amp;style=flat\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-HTML5-333.svg?logo=html5\u0026amp;style=flat\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-CSS3-1572B6.svg?logo=css3\u0026amp;style=flat\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-Python-F9DC3E.svg?logo=python\u0026amp;style=flat\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-Github_Actions-fff?style=flat\u0026amp;logo=github-actions\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-blogger-fff?style=flat\u0026amp;logo=blogger\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-Bilibili-fff?style=flat\u0026amp;logo=Bilibili\u0026quot; /\u0026gt; \u0026lt;img height=\u0026quot;20\u0026quot; src=\u0026quot;https://img.shields.io/badge/-youtube-red?style=flat\u0026amp;logo=youtube\u0026quot; /\u0026gt; \u0026lt;/p\u0026gt; --- \u0026lt;p align=\u0026quot;center\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://github-profile-trophy.vercel.app/?username=Ryuseiri\u0026amp;theme=onedark\u0026amp;row=1\u0026amp;column=7\u0026quot; /\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p align=\u0026quot;center\u0026quot;\u0026gt; \u0026lt;img alt=\u0026quot;Top Langs\u0026quot; height=\u0026quot;150px\u0026quot; src=\u0026quot;https://github-readme-stats.vercel.app/api/top-langs/?username=Ryuseiri\u0026amp;layout=compact\u0026amp;count_private=true\u0026amp;show_icons=true\u0026amp;show_icons=true\u0026amp;theme=onedark\u0026quot;/\u0026gt; \u0026lt;img alt=\u0026quot;github stats\u0026quot; height=\u0026quot;150px\u0026quot; src=\u0026quot;https://github-readme-stats.vercel.app/api?username=Ryuseiri\u0026amp;count_private=true\u0026amp;show_icons=true\u0026amp;show_icons=true\u0026amp;theme=onedark\u0026quot;/\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p align=\u0026quot;center\u0026quot;\u0026gt; \u0026lt;img src=\u0026quot;https://github-readme-streak-stats.herokuapp.com/?user=Ryuseiri\u0026amp;theme=dark\u0026quot; width='50%'/\u0026gt; \u0026lt;/p\u0026gt; ---- \u0026lt;p align=\u0026quot;center\u0026quot;\u0026gt; \u0026lt;img src=\u0026quot;./SalesforceBadge/2021-03_Badge_SF-Certified_Administrator/2021-03_Badge_SF-Certified_Administrator_500x490px.png\u0026quot; width='10%'/\u0026gt; \u0026lt;img src=\u0026quot;./SalesforceBadge/2021-03_Badge_SF-Certified_JavaScript-Developer/2021-03_Badge_SF-Certified_JavaScript-Developer-I_500x490px.png\u0026quot; width='10%'/\u0026gt; \u0026lt;img src=\u0026quot;./SalesforceBadge/2021-03_Badge_SF-Certified_Platform-Developer-I/2021-03_Badge_SF-Certified_Platform-Developer-I_500x490px.png\u0026quot; width='10%'/\u0026gt; \u0026lt;img src=\u0026quot;./SalesforceBadge/2021-03_Badge_SF-Certified_Platform-Developer-II/2021-03_Badge_SF-Certified_Platform-Developer-II_500x490px.png\u0026quot; width='10%'/\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p align=\u0026quot;center\u0026quot;\u0026gt; \u0026lt;a href=\u0026quot;https://www.buymeacoffee.com/Seiri\u0026quot;\u0026gt; \u0026lt;img src=\u0026quot;https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png\u0026quot; height=\u0026quot;50\u0026quot; width=\u0026quot;210\u0026quot; alt=\u0026quot;Seiri\u0026quot; /\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; 👋 Hi , I'm Seiri 現在AWSとSalesforceを専念しています。        ","permalink":"https://seiri-blog.github.io/posts/how-to-setup-github-profile/","summary":"GitHub プロファイルを作成するには、以下の手順を実行します。 GitHub にログインし、右上のアイコンをクリックして、ドロップダウンメニューを表示します。 Your p","title":"Githubのプロファイルを設定する方法"},{"content":"Github とは GitHub は、ソフトウェア開発用のバージョン管理と協力サービスを提供する Web ベースのプラットフォームです。開発者はコードを保存し管理し、変更を追跡し、他のチームメンバーとのプロジェクトに参加することができます。\nGitHub はバグトラッキング、機能リクエスト、プロジェクト管理、Wiki などの他の機能も提供しており、開発者がプロジェクトをより管理するのに役立ちます。\nコアの機能に加えて、GitHub はオープンソースソフトウェア開発のハブとしても使用されており、開発者は多種多様なオープンソースプロジェクトに貢献し共有することができます。\n全体として、GitHub はソフトウェア開発と協力のための人気のあるプラットフォームであり、世界中のあらゆる規模の開発者や組織が使用しています。\n今回の記事の目的 GithubGithub 使いやすいように幾つのコツを紹介しようと思います。\nGithub 高度な検索方法 GitHub はユーザーが探しているコンテンツを素早く見つけることができる高度な検索機能を提供しています。\n 検索修飾子を使用する  検索クエリに修飾子を使用することで、結果を細分化できます。例えば、repo:を使用して特定のリポジトリ内のコードを検索するか、user:を使用して特定のユーザーのコードを検索します。\n引用符を使用する  正確なフレーズを検索したい場合は、\u0026quot;\u0026quot;で囲みます。例：\u0026ldquo;高度な検索\u0026rdquo;。\n論理演算子を使用する  ANDを使用して結果に複数の語句が必要な場合、ORを使用していずれかの語句に一致する結果を含め、NOT を使用して特定の語句に一致する結果を除外することができます。\nワイルドカードを使用する  ワイルドカードとして*を使用して検索での文字列のいかなるシーケンスにも一致します。例：java*は\u0026quot;Java\u0026quot;と\u0026quot;JavaScript\u0026quot;の両方に一致します。\nファイル拡張子フィルターを使用する  extension:を使用して検索結果をファイルタイプでフィルタリングすることができます。例：extension:mdは\u0026quot;.md\u0026quot;拡張子のファイルだけを返します。\n高度検索 https://github.com/search/advanced を直接アクセスすると、Github の高度な検索画面に入れます。この画面では色々の条件を絞り込むことができます。  \n検索方法は下記公式ドキュメントをご参照ください。\n https://docs.github.com/ja/search-github  Github のリポジトリ中にファイルを検索と閲覧方法  リポジトリ中にTキーを押下すると、リポジトリ中のファイルを検索ことができます。  \n\n\nファイル中にLキーを押下すると、指定された行目に移動することができます。  \nファイル中にBキー押下すると、該当ファイルの修正履歴を表示することができます。  \nリポジトリ上で、プロジェクトを直接 VSCode で表示する方法  リポジトリ中に.キーを押下すると、オンラインでプロジェクトを VSCode で表示することができます。\nオンラインの VSCode では一部のプラグインは使うことができないですが、ソース閲覧にはかなり便利だと思います。  \nリポジトリ上で、プロジェクトを起動する方法  リポジトリの URL 前にgitpod.io/を入力してアクセスすると、上記により強い VSCode を表示し、自動的に環境構築し、プロジェクトは自動的に起動します。  \n\n\n起動後の URL をクリックすると、画面が正常に表示された。\n\n最後のコツに関して環境構築はいらない、すごく便利だと思います。\n関連記事  Github 入門  ","permalink":"https://seiri-blog.github.io/posts/how-easy-to-use-github/","summary":"Github とは GitHub は、ソフトウェア開発用のバージョン管理と協力サービスを提供する Web ベースのプラットフォームです。開発者はコードを保存し管理し、変更を追","title":"Github使いやすいコツ"},{"content":"Markdown 記法 見出し 先頭に#をつけることによって見出しになります。見出しのレベルは#の数で表現します。\n# 見出し1 ## 見出し2 ### 見出し3 #### 見出し4 ##### 見出し5 ###### 見出し6 見出し 1 見出し 2 見出し 3 見出し 4 見出し 5 見出し 6 改行記法 空行を挟むことで段落となります。\n``` 内容1 ←　ここは空行です 内容2 ``` 内容1 内容2 改行の前に半角スペースを 2 つつけることで改行することができます。\n内容1(後ろにスペース2つをつける) 内容2 内容１\n内容２\nもしくは\u0026lt;br\u0026gt;で改行することができます。\n内容１\u0026lt;br\u0026gt; 内容２ 内容１\n内容２\nコード記法 バッククオート(` )3 つ、もしくはダッシュ~３つで囲むことで、コードを挿入できます。\n``` print (\u0026#34;hello word!\u0026#34;) ``` print (\u0026#34;hello word!\u0026#34;) Standard バージョン以上であれば、始まりのバッククオート、ダッシュの直後に言語名を記述することで、シンタックスハイライトします。\n```python print (\u0026#34;hello word!\u0026#34;) ``` print (\u0026#34;hello word!\u0026#34;) バッククオートで単語を囲むとインラインコードなります。\n`ここ`を見てください ここを見てください\nテキスト記法 HTML でテキストを装飾できます。\n_italic_ **Blod** ~~打消し線~~ \u0026lt;sup\u0026gt;上付き\u0026lt;/sup\u0026gt; \u0026lt;sub\u0026gt;下付き\u0026lt;/sub\u0026gt; italic\nBlod\n打消し線\n上付き\n下付き\n箇条書き記法 *、 +もしくは-を先頭に記述することで箇条書きとなります。ネストはタブで表現します。\n* リスト1 * リスト2 * 子リスト1 * 子リスト2 * 孫リスト1 * 孫リスト2  リスト 1 リスト 2  子リスト 1 子リスト 2  孫リスト 1 孫リスト 2      箇条書き(番号付)記法 番号.を先頭に記述することで番号付きのリストとなります。\n1. 番号付きリスト1 2. 番号付きリスト2 1. 子番号付きリスト1 2. 子番号付きリスト2 1. 孫番号付きリスト1 2. 孫番号付きリスト2 引用記法 \u0026gt;を先頭に記述することで引用となります。ネストは\u0026gt;を多重に記述します。\n\u0026gt; 引用 \u0026gt; \u0026gt; 多重引用 \u0026gt; \u0026gt; \u0026gt; 多重引用 \u0026gt; \u0026gt; \u0026gt; \u0026gt; 多重引用 \u0026gt; \u0026gt; \u0026gt; \u0026gt; \u0026gt; 多重引用  引用\n 多重引用\n 多重引用\n 多重引用\n 多重引用\n     水平線記法 ---、___、***と\u0026lt;hr\u0026gt;をつけると、水平線となります。\n水平線1 --- 水平線2 ___ 水平線3 *** 水平線4 \u0026lt;hr\u0026gt; 水平線 1 水平線 2\n水平線 3\n水平線 4\n リンク記法 [表示文字](URL)でリンクとなります。\n[Seiriのブログ](https://knowstechnic.blogspot.com/) Seiri のブログ\n定義リンク記法 URL を外部に定義することもできます。URL が長くて読みづらくなる場合に有用です。\n[Seiriのブログ][ブログ] [ブログ]: https://knowstechnic.blogspot.com/ Seiri のブログ\n画像記法 ![alt](画像URL)記載すると、画像挿入できます。\n![alt](画像URL) \nもしくは添付画像は\u0026lt;img src=\u0026quot;url\u0026quot;\u0026gt;で挿入できます。この場合では幅や高を指定できます。\n\u0026lt;img src=\u0026#34;url\u0026#34; width=\u0026#39;500px\u0026#39; height=\u0026#39;300px\u0026#39; \u0026gt; テーブル記法 テーブルの記述は下記となります。\n列1 | 列2 ------- | -------- 内容1 | 内容2    列 1 列 2     内容 1 内容 2    :文字を揃える。\n| 左揃え | 中央揃え | 右揃え | |:-------|:--------:|-------:| |内容1 |内容2 |内容3 |    左揃え 中央揃え 右揃え     内容 1 内容 2 内容 3    折り畳み記法 \u0026lt;details\u0026gt; \u0026lt;summary\u0026gt;ここは折り畳み\u0026lt;/summary\u0026gt; ```py print(\u0026#39;ここは折り畳みです\u0026#39;) ``` \u0026lt;/details\u0026gt;  ここは折り畳み print(\u0026#39;ここは折り畳みです\u0026#39;)  ","permalink":"https://seiri-blog.github.io/posts/markdown-notation/","summary":"Markdown 記法 見出し 先頭に#をつけることによって見出しになります。見出しのレベルは#の数で表現します。 # 見出し1 ## 見出し2 ### 見出し3 #### 見出し4 ##### 見出","title":"Markdown記法"},{"content":"本記事は ul li の点を表示・非表示する方法を紹介します。\n具体的には下記を参照していただければと思います。\nul li の点を非表示する方法 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;内容1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;内容2\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ul { list-style: none; }  実際の結果  \n 左側の Padding があるため、必要に応じて padding-left: 0;を指定する必要があります。  \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;内容1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;内容2\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ul { list-style: none; padding-left: 0; }  実際の結果  \nul li の点を表示する方法 ul li の点を ● に表示する方法 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;内容1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;内容2\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ul { list-style: disc; }  実際の結果  \nul li の点を ○ に表示する方法 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;内容1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;内容2\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ul { list-style: circle; }  実際の結果  \n","permalink":"https://seiri-blog.github.io/posts/show-and-hide-htmlcss-ul-li-point/","summary":"本記事は ul li の点を表示・非表示する方法を紹介します。 具体的には下記を参照していただければと思います。 ul li の点を非表示する方法 \u0026lt;ul\u0026gt; \u0026lt;li\u0026","title":"【HTML/CSS】ul liの点を表示・非表示する方法"},{"content":"Git でのファイル名の大文字・小文字区別の説明 Git はファイル名の大文字・小文字を区別します。\n例えば、「hello.txt」と「Hello.txt」は Git 上では別のファイルとして扱われます。\nこれは、Unix 系の OS ではファイル名の大文字・小文字を区別するためです。\nWindows や macOS では、ファイル名の大文字・小文字を区別しないため、Git でも大文字・小文字を区別しない設定を使用することもできます。\n操作手順 現在 Git 設定を確認する  下記コマンドで Git のコンソール中に実行すると現在の設定が表示される  $ git config -l --local | grep core.ignorecase # 現在の設定は大文字・小文字区別しない core.ignorecase=true # 現在の設定は大文字・小文字区別する core.ignorecase=false 大文字・子文字区別設定  下記コマンドで Git のコンソール中に実行すると大文字・小文字区別するように設定される  $ git config core.ignorecase false 設定確認  もう一度下記コマンドを実行すると現在の設定が表示される  $ git config -l --local | grep core.ignorecase core.ignorecase=false 関連記事  【Git】説明と基本操作方法  ","permalink":"https://seiri-blog.github.io/posts/git-config-core-ignorecase/","summary":"Git でのファイル名の大文字・小文字区別の説明 Git はファイル名の大文字・小文字を区別します。 例えば、「hello.txt」と「Hello.txt」","title":"【Git】ファイル名大文字\u0026小文字を区別する方法"},{"content":"Git の上級操作方法 Git には様々な上級操作がありますが、今回は下記操作方法を説明したいと思います。\nマージ:  master ブランチで最新のソースをプルし、new_feature に切り替えて、master ブランチのソースを master ブランチにマージ  # masterブランチから最新のソースから取得 $ git pull origin master # new_featureブランチに切り替え $ git checkout new_feature # new_featureブランチでの作業を行う # ... # masterブランチをnew_featureブランチにマージ $ git merge master リモートリポジトリの管理:  リモートリポジトリとのやり取りを行うことで、チームでの作業やバックアップを行うことができます。  # リモートリポジトリを追加 $ git remote add origin https://github.com/username/repo.git # リモートリポジトリにプッシュ $ git push origin master # リモートリポジトリからプル $ git pull origin master コミットの履歴の修正:  git rebase や git revert を使って、コミットの履歴を修正することができます。  # コミット履歴を編集 $ git rebase -i HEAD~3 #選択したコミットを取り消す $ git revert [commit hash] ファイルの差分の解析:  git diff を使って、ファイルの差分を解析することができます。  # ファイルの差分を確認 $ git diff path/to/file.txt # 2つのコミット間の差分を確認 $ git diff [commit hash1] [commit hash2] git stash:  作業中の変更を一時的に保存し、別のブランチに切り替えることができます。  #ステージングエリアからの変更を保存 $ git stash save \u0026quot;my changes\u0026quot; #スタッシュから変更を適用 $ git stash apply stash@{0} #スタッシュを削除 $ git stash drop stash@{0} 関連記事  【Git】ファイル名大文字\u0026amp;小文字を区別する方法  ","permalink":"https://seiri-blog.github.io/posts/git-advanced-operation-part1/","summary":"Git の上級操作方法 Git には様々な上級操作がありますが、今回は下記操作方法を説明したいと思います。 マージ: master ブランチで最新のソースをプルし、new","title":"【Git】上級操作方法(その１)"},{"content":"Git の上級操作方法 Git には様々な上級操作がありますが、今回は下記操作方法を説明したいと思います。\nタグの操作:  タグを作成、削除、移動する方法。  # タグの作成 $ git tag \u0026lt;tag_name\u0026gt; # タグの削除 $ git tag -d \u0026lt;tag_name\u0026gt; # タグの移動 $ git tag \u0026lt;new_tag_name\u0026gt; \u0026lt;old_tag_name\u0026gt; bisect の操作:  バグを見つけるために、コミット履歴を二分探索する方法  # bisectを開始するコマンド $ git bisect start # 不具合があるコミットを指定 $ git bisect bad # 不具合がないコミットを指定 $ git bisect good \u0026lt;commit_id\u0026gt; # bisectisectによって判断したいテストスクリプトを実行するコマンド $ git bisect run \u0026lt;script\u0026gt; ログの操作:  ログ表示とログ表示形を指定する方法  # コミットの履歴を表示 $ git log # コミットの差分も表示 $ git log -p # コミットの差分の統計も表示 $ git log --stat # コミットの一覧を1行で表示 $ git log --oneline # コミットのグラフを表示 $ git log --graph コミットの修正:  直前のコミットを修正する方法  # 直前のコミットに変更を加える $ git commit --amend reset の操作:  指定されたコミットに戻す方法  # インデックスを前のコミットに戻す $ git reset # 作業ツリーも前のコミットに戻す $ git reset --hard # 指定したコミットに戻す $ git reset \u0026lt;commit_id\u0026gt; 履歴の検索:  ファイルを修正した人と Commit を探す方法  # ファイルの各行が誰によって編集されたかを表示 $ git blame \u0026lt;file\u0026gt; # 作業ツリー内から指定したパターンに一致する行を検索 $ git grep \u0026lt;pattern\u0026gt; 関連記事  【Git】上級操作方法(その１)  ","permalink":"https://seiri-blog.github.io/posts/git-advanced-operation-part2/","summary":"Git の上級操作方法 Git には様々な上級操作がありますが、今回は下記操作方法を説明したいと思います。 タグの操作: タグを作成、削除、移動する方法。 # タ","title":"【Git】上級操作方法(その２)"},{"content":"Git の上級操作方法 Git には様々な上級操作がありますが、今回は下記操作方法を説明したいと思います。\ngit cherry-pick: git cherry-pick コマンドは、特定のコミットを別のブランチに適用するために使用します。これにより、複数のコミットを一度に適用することができます。\n1.切り替えたいブランチに移動します。git checkout \u0026lt;branch_name\u0026gt; 2.git cherry-pick \u0026lt;commit_id\u0026gt;を実行します。これにより、指定したコミットが現在のブランチに適用されます。\n例えば、特定のコミットを feature ブランチに適用したい場合、以下のようにします。\n$ git checkout feature $ git cherry-pick abcdef これにより、abcdef というコミットが feature ブランチに適用されます。\n注意点として、cherry-pick を使用した場合、新しいコミットが作成されます。\nそのため、cherry-pick を使用した後に push を行う場合は、\u0026ndash;force オプションを使用しなければならないことに注意してください。\nまた、cherry-pick はコミットを取り込むため、取り込んだコミットの変更が既存のコミットと競合する場合、手動で修正を行う必要があります。\ngit archive: git archive コマンドは、リポジトリのアーカイブを作成するために使用します。このコマンドを使用することで、特定のブランチやコミットの状態を圧縮ファイルとして出力することができます。\n使用方法は、以下のようになります。\n1.git archive --format=\u0026lt;format\u0026gt; -o \u0026lt;output_file\u0026gt; \u0026lt;branch_name\u0026gt; : 指定したブランチのアーカイブを作成する 2.git archive --format=\u0026lt;format\u0026gt; -o \u0026lt;output_file\u0026gt; \u0026lt;commit_id\u0026gt; : 指定したコミットの状態のアーカイブを作成する\n例えば、master ブランチのアーカイブを作成し、\u0026ldquo;archive.tar.gz\u0026quot;という名前で保存したい場合、以下のようにします。\n$ git archive --format=tar --prefix=project/ -o archive.tar master これにより、\u0026ldquo;archive.tar\u0026quot;という名前で、master ブランチの状態を圧縮したアーカイブを作成することができます。\ngit archive コマンドには、様々なオプションがあり、アーカイブを作成する際に使用する圧縮形式やファイル名などを指定することができます。これにより、アーカイブを作成する際にカスタマイズすることができます。\ngit remote: git remote コマンドは、リモートリポジトリとの連携や管理を行うために使用します。\n使用方法は、以下のようになります。\n1.git remote : 登録済みのリモートリポジトリ一覧を表示する 2.git remote add \u0026lt;remote_name\u0026gt; \u0026lt;remote_url\u0026gt; : リモートリポジトリを登録する 3.git remote rename \u0026lt;old_name\u0026gt; \u0026lt;new_name\u0026gt; : リモートリポジトリの名前を変更する 4.git remote remove \u0026lt;remote_name\u0026gt; : リモートリポジトリを削除する 5.git remote show \u0026lt;remote_name\u0026gt; : リモートリポジトリの詳細情報を表示する 6.git remote set-url \u0026lt;remote_name\u0026gt; \u0026lt;remote_url\u0026gt; : リモートリポジトリの URL を変更する 7.git remote -v : 登録済みのリモートリポジトリの URL を表示する\n例えば、リモートリポジトリを登録する場合、以下のようにします。\n$ git remote add origin https://github.com/example/repo.git これにより、\u0026ldquo;origin\u0026quot;という名前で、https://github.com/example/repo.gitという URL のリモートリポジトリを登録します。\nリモートリポジトリの名前を変更する場合、以下のようにします。\n$ git remote rename origin upstream これにより、\u0026ldquo;origin\u0026quot;という名前のリモートリポジトリの名前を \u0026ldquo;upstream\u0026quot;に変更します。\nまた、リモートリポジトリの URL を変更する場合、以下のようにします。\ngit remote set-url origin https://github.com/example/repo2.git これにより、\u0026ldquo;origin\u0026quot;という名前のリモートリポジトリの URL を https://github.com/example/repo2.gitに変更します。\nこれらのコマンドを使用することで、リモートリポジトリの管理を行うことができます。\ngit fetch: git fetch コマンドは、リモートリポジトリからローカルリポジトリにデータを取り込むために使用します。このコマンドを使用することで、リモートリポジトリの最新の状態をローカルリポジトリに反映することができます。\n使用方法は、以下のようになります。\n1.git fetch \u0026lt;remote_name\u0026gt; : 指定したリモートリポジトリからデータを取り込む 2.git fetch \u0026lt;remote_name\u0026gt; \u0026lt;branch_name\u0026gt; : 指定したリモートリポジトリのブランチからデータを取り込む\n例えば、origin という名前のリモートリポジトリからデータを取り込む場合、以下のようにします。\n$ git fetch origin これにより、origin リポジトリからデータを取り込みます。取り込んだデータは、origin/\u0026lt;branch_name\u0026gt;という形でローカルリポジトリに保存されます。\ngit fetchは、リモートリポジトリからデータを取り込みますが、取り込んだデータは自動的にマージされません。取り込んだデータを反映するためには、git merge または git pull を使用します。\nまた、git fetchを使用することで、リモートリポジトリに存在するが、ローカルリポジトリに存在しないブランチを取り込むこともできます。\n関連記事  【Git】上級操作方法(その２)  ","permalink":"https://seiri-blog.github.io/posts/git-advanced-operation-part3/","summary":"Git の上級操作方法 Git には様々な上級操作がありますが、今回は下記操作方法を説明したいと思います。 git cherry-pick: git cherry-pick コマンドは、特定のコミットを別のブランチ","title":"【Git】上級操作方法(その３)"},{"content":"Git の用途と関連製品の紹介 Git はオープンソースの分散型バージョン管理システムです。\n開発者が複数人で協力してソフトウェアを開発するために使用されます。\nGit は 2005 年に Linus Torvalds によって開発され、現在では世界中で広く使用されています。\nGit は開発者だけでなく、デザイナーや文筆者など幅広い分野で使用されており、ソフトウェア開発以外でも幅広い利用が可能です。\nGit は複数人での作業を効率的にするために、以下のような機能を提供します。\n ファイルの変更履歴を記録し、差分を確認できる 複数のブランチを作成し、切り替えることができる リモートリポジトリと同期し、複数人での作業を協力することができる コンフリクトを解消するための merge 機能を持っている Git はコマンドラインから操作することができますが、GitHub や GitLab などのサービスを利用することで、web インターフェイスから操作することもできます。  基本操作手順の説明 初回時の手順 1.リポジトリ(プロジェクトの保存場所)を作成します。\n2.ローカルにリポジトリをクローンします。\n$ git clone https://github.com/your_username/your_repository.git 3.クローンしたリポジトリに移動します。\n$ cd your_repository 3.ファイルを編集します。\n4.ファイルを登録します。\n# すべてファイル登録したい場合は「.」を指定すればすべてファイルを登録できます $ git add . # 個別ファイルを登録したい場合は個別ファイルのパスを指定すれば登録できます $ git add 対象ファイルパス 5.登録したファイルをコミットします。\n$ git commit -m \u0026#34;コミットメッセージ\u0026#34; 6.リモートリポジトリにプッシュします。\n$ git push orogin ブランチ名 二回目以降の操作手順 1.feature ブランチを master ブランチから作成します。\n$ git branch feature 2.feature ブランチに切り替えます。\n$ git switch feature 3.ファイルを修正します。\n4.修正後のファイルを登録します。\n# すべてファイル登録したい場合は「.」を指定すればすべてファイルを登録できます $ git add . # 個別ファイルを登録したい場合は個別ファイルのパスを指定すれば登録できます $ git add 対象ファイルパス 5.登録したファイルをコミットします。\n$ git commit -m \u0026#34;コミットメッセージ\u0026#34; 6.リモートリポジトリにプッシュします。\n$ git push orogin ブランチ名 7.リモートリポジトリ上でプルリクエスト（マージリクエスト）作成します。\n8.レビュアーはソースをレビューします。\n9.レビュー終わったらマージします。\n関連記事  【Git】ファイル名大文字\u0026amp;小文字を区別する方法  ","permalink":"https://seiri-blog.github.io/posts/git-operation/","summary":"Git の用途と関連製品の紹介 Git はオープンソースの分散型バージョン管理システムです。 開発者が複数人で協力してソフトウェアを開発するために使用されま","title":"【Git】説明と基本操作方法"},{"content":"LWCライフサイクルフックの説明   LWC のライフサイクルフックには、インスタンス化、接続、更新、破棄の 4 つのフェーズがあります。それぞれのフェーズで使用することができるライフサイクルメソッドを紹介します。\n  constructor: コンポーネントのインスタンスが作成される時に呼び出されます。このメソッドでは、コンポーネントの初期設定を行います。\n  connectedCallback: コンポーネントが DOM に挿入されると呼び出されます。このメソッドでは、コンポーネントが他のコンポーネントや外部システムと連携するための設定を行います。\n  disconnectedCallback: コンポーネントが DOM から削除されると呼び出されます。このメソッドでは、コンポーネントが使用しているリソースを解放する処理を行います。\n  renderedCallback: コンポーネントがレンダリングされるたびに呼び出されます。このメソッドでは、コンポーネントの表示を更新する処理を行います。\n  errorCallback: コンポーネントでエラーが発生した場合に呼び出されます。このメソッドでは、エラーを処理する処理を行います。\n  これらのメソッドを使用することで、コンポーネントのライフサイクルに対応する処理を実装することができます。\nまた、LWC には、データバインディングの仕組みもあり、コンポーネントのプロパティと HTML 要素の値を双方向にバインドすることができます。\nこれにより、プロパティの値が変更されると、対応する HTML 要素も自動的に更新されます。\n具体的な例は下記を参照してください。\n インスタンス化: constructorメソッド\nインスタンスが生成された時に実行されるメソッドです。このメソッドでは、コンポーネントの初期設定を行います。  constructor() { super(); console.log(\u0026#39;constructor called.\u0026#39;); // コンポーネントの初期設定 } 接続: connectedCallbackメソッド\nコンポーネントが DOM に挿入された時に実行されるメソッドです。このメソッドでは、コンポーネントが他のコンポーネントや外部システムと連携するための設定を行います。  connectedCallback() { console.log(\u0026#39;connectedCallback called.\u0026#39;); // コンポーネントが他のコンポーネントや外部システムと連携するための設定 } 更新: renderedCallbackメソッド\nコンポーネントが更新された時に実行されるメソッドです。このメソッドでは、コンポーネントの表示を更新する処理を行います。  renderedCallback() { console.log(\u0026#39;renderedCallback called.\u0026#39;); // コンポーネントの表示を更新する処理 } 破棄: disconnectedCallbackメソッド\nコンポーネントが DOM から削除された時に実行されるメソッドです。このメソッドでは、コンポーネントが使用しているリソースを解放する処理を行います。  disconnectedCallback() { console.log(\u0026#39;disconnectedCallback called.\u0026#39;); // コンポーネントが使用しているリソースを解放する処理 } エラー: errorCallbackメソッド\nコンポーネントでエラーが発生した場合に呼び出されます。このメソッドでは、エラーを処理する処理を行います。\nerrorCallback メソッドの第 1 引数には、発生したエラーオブジェクトが渡され、第 2 引数には、エラーが発生したコールスタックが渡されます。\nこのメソッドを使用することで、コンポーネント内で発生したエラーを検知し、適切な処理を行うことができます。例えば、エラー発生時にエラーメッセージを表示したり、エラーを発生させないように対処する処理を行ったりすることができます  errorCallback(error, stack) { console.error(error); console.error(stack); // エラーを処理する処理 } 上記の例は、それぞれのライフサイクルフェーズのタイミングで、コンソールにログを出力するだけの処理になります。実際の開発では、これらのメソッドを使って、コンポーネントの表示や動作をカスタマイズします。\n例えば、インスタンス化フェーズでは、プロパティの初期値を設定し、接続フェーズでは、外部の API との通信処理を行ったり、更新フェーズでは、プロパティの値に応じて表示を更新する処理を行ったり、破棄フェーズでは、終了時の処理を行ったりすることができます。\n","permalink":"https://seiri-blog.github.io/posts/lwc-life-cycle-hook/","summary":"LWCライフサイクルフックの説明 LWC のライフサイクルフックには、インスタンス化、接続、更新、破棄の 4 つのフェーズがあります。それぞれのフェーズ","title":"【Salesforce】LWCライフサイクルフック"},{"content":"LWC（Lightning Web Component） とは LWC（Lightning Web Component） は、Web Componentsを使用して、Salesforceのプラットフォーム上でカスタムコンポーネントを構築するためのフレームワークです。 LWC は、Web Componentsに加え、以下の機能を提供しています。\n 強力なデータバインディング: Salesforce のデータモデルとの統合。 Apex のインテグレーション: Apex のメソッドを JavaScript から呼び出すことができます。 イベントシステム: コンポーネント間のデータのやり取りを行うためのイベントシステムが提供されています。 セキュリティ: セキュリティ機能が強化されています。 スケーラビリティ: 大量のデータを扱うことができるようになっています。  纏めると、LWC は Salesforce のプラットフォーム上でWeb Componentsを使用してカスタムコンポーネントを構築するためのフレームワークです。\nLWC（Lightning Web Component） の特徴 LWC (Lightning Web Component) の基礎となる概念は以下となる。\n Web Components: LWC は Web Components と呼ばれる技術を使用しています。Web Components は、ブラウザの API を使用して、カスタム HTML タグを作成するための仕組みです。 Shadow DOM: Shadow DOM は、Web Components の一部で、カスタム HTML タグのスタイルや構造を隠蔽するために使用されます。Shadow DOM を使用することで、カスタムコンポーネントのスタイルや構造を外部の要素から隔離することができます。 Template: LWC のコンポーネントは、HTML テンプレートによって構築されます。テンプレートは、HTML のマークアップと JavaScript のロジックを組み合わせたものです。 Decorators: LWC では、デコレータと呼ばれる構文を使用して、コンポーネントのプロパティやメソッドを定義します。デコレータは、JavaScript のアノテーションのような役割を持ちます。 Event Handling: LWC では、カスタムイベントを使用して、コンポーネント間のデータのやり取りを行います。イベントハンドラを使用することで、コンポーネント間のコミュニケーションを実現することができます。  次は上記の説明をそれぞれもっと詳しい説明します。\nWeb Components Web Components は、ブラウザの API を使用して、カスタム HTML タグを作成するための仕組みです。Web Components は、以下の 4 つの技術によって構成されます。\n Custom Elements: カスタム HTML タグを作成するための技術。 Shadow DOM: カスタム HTML タグのスタイルや構造を隠蔽するための技術。 HTML Templates: カスタム HTML タグのテンプレートを定義するための技術。 HTML Imports: カスタム HTML タグを外部から読み込むための技術。  Shadow DOM Shadow DOM は、Web Components の 1 つの機能で、カスタム HTML タグのスタイルや構造を隠蔽するための技術です。 Shadow DOM を使用することで、カスタム HTML タグ内部のスタイルや構造が外部の HTML に影響を与えなくなり、カスタム HTML タグを再利用することができるようになります。\nLWC (Lightning Web Component)では、Shadow DOMを使用して、カスタムコンポーネントのスタイルや構造を隠蔽することができます。 LWC のコンポーネントは、Shadow DOMを使用して、スタイルや構造を隠蔽するため、外部の HTML に影響を与えなくなり、再利用性が向上します。\nまた、LWC では、スタイルのスコープを限定することができるようになり、スタイルの上書きを防ぐことができます。\nLWC では、標準 HTML タグと同じように Shadow DOM を使用することができます。\nLWC Template LWC (Lightning Web Component)では、HTML Templates と呼ばれる機能を使用して、カスタムコンポーネントのテンプレートを定義することができます。 HTML Templates は、HTML のテンプレートを定義するためのテンプレートリテラルと呼ばれる記法を使用します。\nLWC の HTML Templates は、JavaScript のテンプレートリテラルを使用して記述します。テンプレートリテラルは、バッククォート (`) で囲むことで定義されます。\n例:\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt;Hello World!\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; LWC の HTML Templates は、カスタムコンポーネントの見た目を定義するために使用します。また、JavaScript のテンプレートリテラルを使用することで、変数の埋め込みや条件分岐などを行うことができます。\nLWC では、標準 HTML タグと同じように HTML Templates を使用することができます。\nLWC Decorators LWC (Lightning Web Component)では、デコレーターと呼ばれる機能を使用して、カスタムコンポーネントのプロパティやメソッドを拡張することができます。\nLWC のデコレーターは、JavaScript のアノテーションのように、プロパティやメソッドに対して追加されます。\nLWC では、次のようなデコレーターが提供されています。\n @api: コンポーネントの外部からアクセスできるプロパティを定義します。 @track: コンポーネントのテンプレートに反映されるプロパティを定義します。 @wire: Apex のメソッドを呼び出して、プロパティにデータをバインドします。  デコレーターを使用することで、コンポーネントの設計が簡潔になり、開発者がより素早くカスタムコンポーネントを構築することができるようになります。\n例:\nimport { LightningElement, api } from \u0026#34;lwc\u0026#34;; export default class MyComponent extends LightningElement { @api name; } 上記の例では、@apiデコレーターを使用して、nameというプロパティを定義し、外部からアクセスできるようにしています。\nデコレーターは、LWC では必須ではありませんが、開発効率を上げるために役立ちます。また、デコレーターを使用することで、コンポーネントをより明確に定義することができます。\nLWC Event Handling LWC (Lightning Web Component)では、イベントハンドリングと呼ばれる機能を使用して、カスタムコンポーネント間でのイベントの通信を行うことができます。イベントを定義するには、customEventのような自分自身のカスタムイベントを定義し、dispatchEventメソッドを使用して、イベントを発火させます。\n例:\nimport { LightningElement } from \u0026#34;lwc\u0026#34;; export default class MyComponent extends LightningElement { handleClick() { const event = new CustomEvent(\u0026#34;myevent\u0026#34;, { detail: { message: \u0026#34;Hello World!\u0026#34; }, }); // イベントを発火  this.dispatchEvent(event); } } 上記の例では、handleClickメソッド内でカスタムイベントmyeventを作成し、dispatchEventメソッドで発火しています。イベントオブジェクトには、detailプロパティを使用して、イベントに渡すデータを設定することができます。イベントを受け取るには、addEventListenerメソッドを使用して、イベントを受け取れるようにします。\n例:\nimport { LightningElement } from \u0026#34;lwc\u0026#34;; export default class OtherComponent extends LightningElement { connectedCallback() { this.addEventListener(\u0026#34;myevent\u0026#34;, this.handleEvent); } handleEvent(event) { console.log(event.detail.message); // \u0026#39;Hello World!\u0026#39;  } } 上記の例では、OtherComponent で myevent イベントを受け取るように、addEventListenerメソッドを使用して設定しています。イベントが発生したら、handleEventメソッドが呼び出され、event.detail.messageからイベントに渡されたデータを取得することができます。\nイベントハンドリングは、LWC 開発で重要な機能の一つであり、コンポーネント間のデータの通信や、親子関係のコンポーネント間でのイベントの通信を行うために使用されます。\n","permalink":"https://seiri-blog.github.io/posts/lwc-introduction/","summary":"LWC（Lightning Web Component） とは LWC（Lightning Web Component） は、Web Componentsを使用して","title":"【Salesforce】LWC入門"},{"content":"LWC の環境構築方法 LWC の環境構築の詳しい方法は以下のようになります。\n  Salesforce の Developer Edition アカウントを取得します。\nDeveloper Edition アカウントは、開発者向けのアカウントで、開発・テスト・デモ用に使用できます。アカウントを取得するには、Salesforce の Web サイトにアクセスし、登録手順を実行します。\n  Salesforce CLI をインストールします。\nCLI のダウンロードはこちらです。\nインストールには、Windows、macOS、Linux のいずれかの OS が必要です。\n  Salesforce CLI を使用して、LWC プロジェクトを作成します。\nSalesforce CLI を使用して、LWC プロジェクトを作成するには、以下のコマンドを実行します。\n  sfdx force:project:create -n MyLWCProject  Salesforce CLI を使用して、LWC プロジェクトに必要なプラグインをインストールします。  sfdx force:lightning:lwc:install  Salesforce CLI を使用して、LWC コンポーネントを作成します。\nSalesforce CLI を使用して、LWC コンポーネントを作成します。には、以下のコマンドを実行します。  sfdx force:lightning:component:create -n myComponent -d force-app/main/default/lwc  Salesforce CLI を使用して、開発したコンポーネントをデプロイします。\n開発したコンポーネントをデプロイするには、以下のコマンドを実行します。  sfdx force:source:deploy -p force-app/main/default/lwc これで、LWC 環境の構築が完了です。これらのステップを踏むことで、LWC の開発環境を構築することができます。\n","permalink":"https://seiri-blog.github.io/posts/salesforce-lwc-setup-environment/","summary":"LWC の環境構築方法 LWC の環境構築の詳しい方法は以下のようになります。 Salesforce の Developer Edition アカウントを取得します。 Developer Edition アカウントは、開発者向けのアカウントで、","title":"【Salesforce】LWC環境構築"},{"content":"目的 LWC でのファイルダウンロード方法を共有します。\nソース構成図 force-app └─main └─default ├─classes │ ├─GetFileDemoController │ └─GetFileDemoController.cls-meta.xml └─lwc └─fileDownload  Apex:GetFileDemoController  \npublic with sharing class GetFileDemoController { /** * ファイル一覧を取得 */ @AuraEnabled public static List\u0026lt;ContentVersion\u0026gt; getFileList(){ try { List\u0026lt;ContentVersion\u0026gt; contentVersions = [SELECT Id, Title, FileExtension, ContentSize FROM ContentVersion ]; if(contentVersions.size() \u0026gt; 0) return contentVersions; return null; } catch (Exception e) { throw new AuraHandledException(e.getMessage()); } } }  LWC:fileDownload  \n\u0026lt;template\u0026gt; \u0026lt;template if:true=\u0026#34;{loading}\u0026#34;\u0026gt; \u0026lt;lightning-spinner alternative-text=\u0026#34;Loading\u0026#34; size=\u0026#34;medium\u0026#34; \u0026gt;\u0026lt;/lightning-spinner\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;lightning-card\u0026gt; \u0026lt;div slot=\u0026#34;footer\u0026#34;\u0026gt; \u0026lt;lightning-datatable hide-checkbox-column key-field=\u0026#34;Id\u0026#34; columns=\u0026#34;{columns}\u0026#34; data=\u0026#34;{datas}\u0026#34; onrowaction=\u0026#34;{handleRowAction}\u0026#34; \u0026gt; \u0026lt;/lightning-datatable\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/lightning-card\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, track } from \u0026#34;lwc\u0026#34;; import { ShowToastEvent } from \u0026#34;lightning/platformShowToastEvent\u0026#34;; import getFileList from \u0026#34;@salesforce/apex/GetFileDemoController.getFileList\u0026#34;; export default class FileZipDemo extends LightningElement { @track columns; @track datas; @track loading; /** * メッセージ表示 * @param {window} that * @param {string} title タイトール * @param {string} message メッセージ * @param {string} variant タイプ info、success、warning、error */ showToast(title, message, variant) { const event = new ShowToastEvent({ title: title, message: message, variant: variant, }); this.dispatchEvent(event); } /** * ファイルサイズ変換 * @param {*} size バイト * @returns 変換後のサイズ */ fileSizeUnit(size) { // 1 KB = 1024 Byte  const kb = 1024; const mb = Math.pow(kb, 2); const gb = Math.pow(kb, 3); const tb = Math.pow(kb, 4); const pb = Math.pow(kb, 5); const round = (size, unit) =\u0026gt; { return Math.round((size / unit) * 100.0) / 100.0; }; if (size \u0026gt;= pb) { return round(size, pb) + \u0026#34;PB\u0026#34;; } else if (size \u0026gt;= tb) { return round(size, tb) + \u0026#34;TB\u0026#34;; } else if (size \u0026gt;= gb) { return round(size, gb) + \u0026#34;GB\u0026#34;; } else if (size \u0026gt;= mb) { return round(size, mb) + \u0026#34;MB\u0026#34;; } else if (size \u0026gt;= kb) { return round(size, kb) + \u0026#34;KB\u0026#34;; } return size + \u0026#34;バイト\u0026#34;; } /** * デートフォマート * @param {Date} date date * @param {string} fmt format * @returns {string} StringDate */ dateFormat(date, fmt = \u0026#34;YYYY/mm/dd\u0026#34;) { let ret; const opt = { \u0026#34;Y+\u0026#34;: date.getFullYear().toString(), // 年  \u0026#34;m+\u0026#34;: (date.getMonth() + 1).toString(), // 月  \u0026#34;d+\u0026#34;: date.getDate().toString(), // 日  \u0026#34;H+\u0026#34;: date.getHours().toString(), // 時  \u0026#34;M+\u0026#34;: date.getMinutes().toString(), // 分  \u0026#34;S+\u0026#34;: date.getSeconds().toString(), // 秒  }; for (let k in opt) { ret = new RegExp(\u0026#34;(\u0026#34; + k + \u0026#34;)\u0026#34;).exec(fmt); if (ret) { fmt = fmt.replace( ret[1], ret[1].length == 1 ? opt[k] : opt[k].padStart(ret[1].length, \u0026#34;0\u0026#34;) ); } } return fmt; } /** * ファイルダウンロード */ async downloadFile(Id) { try { this.loading = true; window.location.href = `/sfc/servlet.shepherd/version/download/${Id}`; } catch (err) { console.error(\u0026#34;Error: \u0026#34; + err); this.showToast(\u0026#34;\u0026#34;, err.body.message, \u0026#34;error\u0026#34;); } finally { this.loading = false; } } /** * RowAction * @param {*} event */ async handleRowAction(event) { const action = event.detail.action; const row = event.detail.row; switch (action.name) { case \u0026#34;download\u0026#34;: await this.downloadFile(row.Id); break; default: break; } } /** * 初期化 */ async connectedCallback() { this.columns = [ { label: \u0026#34;Id\u0026#34;, fieldName: \u0026#34;Id\u0026#34; }, { label: \u0026#34;ファイル名\u0026#34;, fieldName: \u0026#34;Title\u0026#34; }, { label: \u0026#34;拡張子\u0026#34;, fieldName: \u0026#34;FileExtension\u0026#34; }, { label: \u0026#34;ファイルサイズ\u0026#34;, fieldName: \u0026#34;ContentSize\u0026#34; }, { type: \u0026#34;action\u0026#34;, typeAttributes: { rowActions: [{ label: \u0026#34;ダウンロード\u0026#34;, name: \u0026#34;download\u0026#34; }], menuAlignment: \u0026#34;auto\u0026#34;, }, }, ]; this.datas = await getFileList(); this.datas = this.datas.map((e, i) =\u0026gt; { return { ...e, ContentSize: this.fileSizeUnit(e.ContentSize) }; }); } } Salesforce 側動作確認  Salesforce 側 Lightning コンポーネントタブを作成  \n タブを開いて、ファイルダウンロードする  \n\n参考 https://salesforce.stackexchange.com/questions/203030/content-document-download-url-params\nhttps://cafeforce.com/mass-attachments-documents-download-salesforce-lwc/\n","permalink":"https://seiri-blog.github.io/posts/lwc-download-file/","summary":"目的 LWC でのファイルダウンロード方法を共有します。 ソース構成図 force-app └─main └─default ├─classes │ ├─GetFileDemoC","title":"【Salesforce】LWCでのファイルダウンロード"},{"content":"目的 今回 Classic モードで Visualforce に LWC のでファイル一括ダウンロードする方法を共有します。\n前提 jszip.js を静的リソースにアップロードする\n\nソース構成図 force-app └─main └─default ├─aura │　└─LWCContainer │ ├─classes │ ├─CommonHandler.cls │ └─CommonHandler.cls-meta.xml ├─lwc │　└─fileZipDemo │ ├─pages ├─fileZipDemo.page └─fileZipDemo.page-meta.xml  Aura:LWCContainer  \n\u0026lt;aura:application access=\u0026#34;GLOBAL\u0026#34; extends=\u0026#34;ltng:outApp\u0026#34;\u0026gt; \u0026lt;/aura:application\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;AuraDefinitionBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;50.0\u0026lt;/apiVersion\u0026gt; \u0026lt;description\u0026gt;A Lightning Application Bundle\u0026lt;/description\u0026gt; \u0026lt;/AuraDefinitionBundle\u0026gt; ({ myAction: function (component, event, helper) {}, });  class:CommonHandler  \npublic with sharing class CommonHandler { /** *セッションIdを取得 */ @AuraEnabled public static String getSessionId() { try{ return UserInfo.getSessionId(); } catch (Exception e) { throw new AuraHandledException(e.getMessage()); } } /** * 選択された一括ダウンロード * @param parameterJson: contentDocumentIds * @return results ダウンロード情報 */ @AuraEnabled public static List \u0026lt;Map \u0026lt;String, String\u0026gt;\u0026gt; doDownloadFile(String parameter){ List\u0026lt;Map\u0026lt;String, String\u0026gt;\u0026gt; results = new List\u0026lt;Map\u0026lt;String, String\u0026gt;\u0026gt;(); String tempalteUrl = \u0026#39;/services/data/v51.0/sobjects/ContentVersion/{0}/VersionData\u0026#39;; try { List\u0026lt;String\u0026gt; contentVersionIds = (List\u0026lt;String\u0026gt;) JSON.deserialize(parameter, List\u0026lt;String\u0026gt;.class); if (contentVersionIds.size() \u0026gt; 0){ List\u0026lt;ContentVersion\u0026gt; contentVersions = [SELECT Id, Title, FileExtension, ContentSize FROM ContentVersion WHERE Id IN :contentVersionIds AND IsLatest = true ]; for(ContentVersion contentVersion: contentVersions) { Map\u0026lt;String, String\u0026gt; obj = new Map\u0026lt;String, String\u0026gt;(); obj.put(\u0026#39;name\u0026#39;, contentVersion.Title + \u0026#39;.\u0026#39; + contentVersion.FileExtension); List\u0026lt;String\u0026gt; Ids = new List\u0026lt;String\u0026gt;(); Ids.add(contentVersion.Id); obj.put(\u0026#39;url\u0026#39;, String.format(tempalteUrl, Ids)); results.add(obj); } } if (results.size() \u0026gt; 0) return results; return null; } catch (Exception e) { throw new AuraHandledException(e.getMessage()); } } /** * ファイル一覧を取得 */ @AuraEnabled public static List\u0026lt;ContentVersion\u0026gt; getFileList(){ try { List\u0026lt;ContentVersion\u0026gt; contentVersions = [SELECT Id, Title, FileExtension, ContentSize FROM ContentVersion ]; if(contentVersions.size() \u0026gt; 0) return contentVersions; return null; } catch (Exception e) { throw new AuraHandledException(e.getMessage()); } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;ApexClass xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;status\u0026gt;Active\u0026lt;/status\u0026gt; \u0026lt;/ApexClass\u0026gt;  LWC:fileZipDemo  \n\u0026lt;template\u0026gt; \u0026lt;template if:true=\u0026#34;{loading}\u0026#34;\u0026gt; \u0026lt;lightning-spinner alternative-text=\u0026#34;Loading\u0026#34; size=\u0026#34;medium\u0026#34; \u0026gt;\u0026lt;/lightning-spinner\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;lightning-card\u0026gt; \u0026lt;div class=\u0026#34;slds-p-horizontal_small\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-form\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-form__row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-form__item\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;slds-button slds-button_brand\u0026#34; onclick=\u0026#34;{downloadFile}\u0026#34; \u0026gt; 一括ダウンロード \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div slot=\u0026#34;footer\u0026#34;\u0026gt; \u0026lt;lightning-datatable key-field=\u0026#34;Id\u0026#34; columns=\u0026#34;{columns}\u0026#34; data=\u0026#34;{datas}\u0026#34;\u0026gt; \u0026lt;/lightning-datatable\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/lightning-card\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, track } from \u0026#34;lwc\u0026#34;; import { ShowToastEvent } from \u0026#34;lightning/platformShowToastEvent\u0026#34;; import { loadScript } from \u0026#34;lightning/platformResourceLoader\u0026#34;; import jszip from \u0026#34;@salesforce/resourceUrl/jszip\u0026#34;; import getSessionId from \u0026#34;@salesforce/apex/CommonHandler.getSessionId\u0026#34;; import doDownloadFile from \u0026#34;@salesforce/apex/CommonHandler.doDownloadFile\u0026#34;; import getFileList from \u0026#34;@salesforce/apex/CommonHandler.getFileList\u0026#34;; const zipFileNamePrefix = \u0026#34;zipFileNamePrefix\u0026#34;; export default class FileZipDemo extends LightningElement { @track columns; @track datas; @track loading; /** * メッセージ表示 * @param {window} that * @param {string} title タイトール * @param {string} message メッセージ * @param {string} variant タイプ info、success、warning、error */ showToast(title, message, variant) { const event = new ShowToastEvent({ title: title, message: message, variant: variant, }); this.dispatchEvent(event); } /** * ファイルサイズ変換 * @param {*} size バイト * @returns 変換後のサイズ */ fileSizeUnit(size) { // 1 KB = 1024 Byte  const kb = 1024; const mb = Math.pow(kb, 2); const gb = Math.pow(kb, 3); const tb = Math.pow(kb, 4); const pb = Math.pow(kb, 5); const round = (size, unit) =\u0026gt; { return Math.round((size / unit) * 100.0) / 100.0; }; if (size \u0026gt;= pb) { return round(size, pb) + \u0026#34;PB\u0026#34;; } else if (size \u0026gt;= tb) { return round(size, tb) + \u0026#34;TB\u0026#34;; } else if (size \u0026gt;= gb) { return round(size, gb) + \u0026#34;GB\u0026#34;; } else if (size \u0026gt;= mb) { return round(size, mb) + \u0026#34;MB\u0026#34;; } else if (size \u0026gt;= kb) { return round(size, kb) + \u0026#34;KB\u0026#34;; } return size + \u0026#34;バイト\u0026#34;; } /** * デートフォマート * @param {Date} date date * @param {string} fmt format * @returns {string} StringDate */ dateFormat(date, fmt = \u0026#34;YYYY/mm/dd\u0026#34;) { let ret; const opt = { \u0026#34;Y+\u0026#34;: date.getFullYear().toString(), // 年  \u0026#34;m+\u0026#34;: (date.getMonth() + 1).toString(), // 月  \u0026#34;d+\u0026#34;: date.getDate().toString(), // 日  \u0026#34;H+\u0026#34;: date.getHours().toString(), // 時  \u0026#34;M+\u0026#34;: date.getMinutes().toString(), // 分  \u0026#34;S+\u0026#34;: date.getSeconds().toString(), // 秒  }; for (let k in opt) { ret = new RegExp(\u0026#34;(\u0026#34; + k + \u0026#34;)\u0026#34;).exec(fmt); if (ret) { fmt = fmt.replace( ret[1], ret[1].length == 1 ? opt[k] : opt[k].padStart(ret[1].length, \u0026#34;0\u0026#34;) ); } } return fmt; } /** * 添付ファイルダウンロード */ async downloadFile(e) { try { e.preventDefault(); this.loading = true; //画面選択項目のレコードIdを取得  let targets = this.template .querySelector(\u0026#34;lightning-datatable\u0026#34;) .getSelectedRows(); if (targets.length \u0026gt; 0) { let targetIds = []; targets.forEach((e) =\u0026gt; { targetIds.push(e.Id); }); let results = await doDownloadFile({ parameter: JSON.stringify(targetIds), }); if (results) await this.allDownload(results); else this.showToast(\u0026#34;\u0026#34;, \u0026#34;添ファイルが存在しません。\u0026#34;, \u0026#34;warning\u0026#34;); } else { this.showToast(\u0026#34;\u0026#34;, \u0026#34;ファイルを選択してください。\u0026#34;, \u0026#34;warning\u0026#34;); } } catch (err) { console.error(\u0026#34;Error: \u0026#34; + err); this.showToast(\u0026#34;\u0026#34;, err.body.message, \u0026#34;error\u0026#34;); } finally { this.loading = false; } } /** * resultsにより、ファイルを一括ダウンロード * @param {*} results */ async allDownload(results) { try { let sessionId = await getSessionId(); console.time(\u0026#34;downloadtime\u0026#34;); let result = await this.getNameContentPairsFrom(results, sessionId); console.timeEnd(\u0026#34;downloadtime\u0026#34;); console.time(\u0026#34;ziptime\u0026#34;); let zipBlob = await this.generateZipBlob(result); console.timeEnd(\u0026#34;ziptime\u0026#34;); this.saveBlob( zipBlob, `${zipFileNamePrefix}${this.dateFormat( new Date(), \u0026#34;YYYYmmddHHMMSS\u0026#34; )}.zip` ); } catch (e) { console.timeEnd(\u0026#34;downloadtime\u0026#34;); console.error(e); } } /** * ファイル圧縮 * @param {*} nameContentPairs */ generateZipBlob(nameContentPairs) { let zip = new JSZip(); nameContentPairs.forEach((nameContentPair) =\u0026gt; { zip.file(nameContentPair.name, nameContentPair.content); }); return zip.generateAsync({ type: \u0026#34;blob\u0026#34;, compression: \u0026#34;DEFLATE\u0026#34;, compressionOption: { level: 1, }, }); } /** * RESTAPIにリクエストを出し、ファイル情報を取得 * @param {object} results * @param {string} sessionId セッションID */ async getNameContentPairsFrom(results, sessionId) { let promises = results.map(async (result) =\u0026gt; { let name = result.name; let response = await fetch(result.url, { headers: { Authorization: `Bearer ${sessionId}`, }, }); let content = await response.blob(); return { name, content }; }); let pairs = []; for (let promise of promises) { pairs.push(await promise); } return pairs; } /** * ファイル保存 * @param {*} blob ファイルの中身 * @param {*} name ファイル名 */ saveBlob(blob, name = undefined) { if (window.navigator.msSaveBlob) { if (name) window.navigator.msSaveBlob(blob, name); else window.navigator.msSaveBlob(blob); } else { let a = document.createElement(\u0026#34;a\u0026#34;); a.href = URL.createObjectURL(blob); if (name) a.download = name; a.style.display = \u0026#34;none\u0026#34;; document.body.appendChild(a); a.click(); document.body.removeChild(a); } } /** * 初期化 */ async connectedCallback() { this.columns = [ { label: \u0026#34;Id\u0026#34;, fieldName: \u0026#34;Id\u0026#34; }, { label: \u0026#34;ファイル名\u0026#34;, fieldName: \u0026#34;Title\u0026#34; }, { label: \u0026#34;拡張子\u0026#34;, fieldName: \u0026#34;FileExtension\u0026#34; }, { label: \u0026#34;ファイルサイズ\u0026#34;, fieldName: \u0026#34;ContentSize\u0026#34; }, ]; this.datas = await getFileList(); this.datas = this.datas.map((e, i) =\u0026gt; { return { ...e, ContentSize: this.fileSizeUnit(e.ContentSize) }; }); } /** * jszipロード */ renderedCallback() { if (this.jsinit) return; this.jsinit = true; Promise.all([loadScript(this, jszip)]) .then(() =\u0026gt; { console.log(\u0026#34;ライブラリロード成功\u0026#34;); }) .catch((error) =\u0026gt; { this.showToast(\u0026#34;\u0026#34;, \u0026#34;JSライブラリロードに失敗しました\u0026#34;, \u0026#34;error\u0026#34;); }); } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;true\u0026lt;/isExposed\u0026gt; \u0026lt;targets\u0026gt; \u0026lt;target\u0026gt;lightning__Tab\u0026lt;/target\u0026gt; \u0026lt;/targets\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt;  page:FileZipDemo  \n\u0026lt;apex:page standardStylesheets=\u0026#34;false\u0026#34; sidebar=\u0026#34;false\u0026#34; applyBodyTag=\u0026#34;false\u0026#34; docType=\u0026#34;html-5.0\u0026#34; \u0026gt; \u0026lt;!-- lightning Design System --\u0026gt; \u0026lt;apex:includeLightning /\u0026gt; \u0026lt;div id=\u0026#34;lwc-container\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; $Lightning.use(\u0026#34;c:LWCContainer\u0026#34;, function () { //AuraAppContainer  $Lightning.createComponent( \u0026#34;c:fileZipDemo\u0026#34;, //LWCコンポネント  {}, //lwcコンポネントに渡すパラメータ  \u0026#34;lwc-container\u0026#34;, //divのid  function (cmp) { //コールバック関数  console.log(\u0026#34;Load Success:\u0026#34; + cmp); } ); }); \u0026lt;/script\u0026gt; \u0026lt;/apex:page\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;ApexPage xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;availableInTouch\u0026gt;false\u0026lt;/availableInTouch\u0026gt; \u0026lt;confirmationTokenRequired\u0026gt;false\u0026lt;/confirmationTokenRequired\u0026gt; \u0026lt;label\u0026gt;FileZipDemo\u0026lt;/label\u0026gt; \u0026lt;/ApexPage\u0026gt; Salesforce 側動作確認  Salesforce 側 Visualforce タブを作成  \n タブを開いて、ファイルを一括ダウンロードする  \n\n\n参考 https://stuk.github.io/jszip/documentation/examples.html\nhttps://stuk.github.io/jszip/documentation/examples/download-zip-file.html\nhttps://github.com/Stuk/jszip/issues/617\n","permalink":"https://seiri-blog.github.io/posts/lwc-mass-file-download/","summary":"目的 今回 Classic モードで Visualforce に LWC のでファイル一括ダウンロードする方法を共有します。 前提 jszip.js を静的リソースにアップロードする ソース構成図 force-app └─main └","title":"【Salesforce】LWCでのファイル一括ダウンロード方法"},{"content":"準備  まずCloudBerry Explorerをアクセス  \n 自分のメールアドレスを入力してから Download ボタン押下する  \n ツールをダウンロードする  \n  ツールをインストールする\n Nextボタン押下  \n I Agree ボタン押下する  \n Install ボタン押下する  \n Finish ボタン押下する  \n  S3 へファイル転送  ツールを起動し、Next ボタン押下  \n Amazon S3のアイコンをダブルクリックする  \n Display name、Access KeyとSecret Keyを入力してからOKボタン押下する  \n 認証成功の画面をCloseする  \n 右側のSourceをさっき認証した表示名を選択するとバケット一覧が表示される  \n ドラッグ＆ドロップでファイルをアップロードする  \n ファイルをアップロードした  \n纏め  CloudBerry Explorerは無料版と有料版があります。 アップロードやダウンロードが使いやすいです。 普通アップロードやダウンロード等の操作だけであれば、無料版で十分使えると思います。  ","permalink":"https://seiri-blog.github.io/posts/aws-file-transfer-tool-to-s3/","summary":"準備 まずCloudBerry Explorerをアクセス 自分のメールアドレスを入力してから Download ボタン押下する ツールをダウンロードする ツールをイン","title":"【AWS】S3 へファイル転送ツール"},{"content":"OpenAI とは OpenAI は人工知能の研究を行う非営利団体です。OpenAI は 2015 年にエリック・シュミット氏、イーサン・アシマー氏、ジョン・ピータース氏、ブロントン・ベンス氏、イーライ・ミスライ氏、サミ・ゼリック氏によって設立されました。\n OpenAI の目的は、人工知能の技術を進展させ、人類の福祉を向上させることです。OpenAIの資金提供は、企業や個人からの寄付や、政府や非政府組織からの助成金などを通じて行われます。OpenAI は様々なプロジェクトを進めており、大型言語モデルのトレーニングや強化学習の技術開発などを行っています。 OpenAI APIは、自然言語やコードを理解したり生成したりするタスクにほとんど適用できます。さまざまなタスクに適した異なる電力レベルのモデルを提供し、カスタマイズしたモデルの能力を微調整します。これらのモデルは、コンテンツ生成からセマンティック検索と分類までのすべての側面で使用できます。 OpenAI 貢献 OpenAI は人工知能の分野で様々な貢献をしています。例えば、OpenAI は大型言語モデル「GPT-3」を発表しました。このモデルは、自然言語処理タスクにおいて高い性能を発揮し、自然言語処理技術の進歩に貢献しました。また、OpenAI は深層学習フレームワーク「PyTorch」の開発にも貢献しています。このフレームワークは、現在多くの研究者や企業で利用されています。\n参照 https://openai.com/\n","permalink":"https://seiri-blog.github.io/posts/story-about-openai/","summary":"OpenAI とは OpenAI は人工知能の研究を行う非営利団体です。OpenAI は 2015 年にエリック・シュミット氏、イーサン・アシマー氏、ジョン・ピータース氏、ブロン","title":"OpenAIに関する話"},{"content":"GPT とは GPT は Generative Pretrained Transformer の略で、トランスフォーマーを使った言語モデルの一種です。GPT は大量の文章データを分析し、それらから文章を生成することができます。GPT は人間が書いた文章を理解し、文章を生成する能力が高く、さまざまなトピックについて話すことができます。\n\nGPT3 とは GPT-3 は Generative Pretrained Transformer 3 の略で、トランスフォーマーを使った言語モデルの一種です。GPT-3 は大量の文章データを分析し、それらから文章を生成することができます。GPT-3 は人間が書いた文章を理解し、文章を生成する能力が高く、さまざまなトピックについて話すことができます。GPT-3 は GPT シリーズの最新版であり、トレーニングに使用されたデータ量が前バージョンのモデルよりも大きく、さらに高い性能を発揮します。\nGPT-3 のメリットとデメリット GPT-3 のメリットとしては、トレーニングに使用されたデータ量が膨大であることが挙げられます。GPT-3 は大量の文章データを分析し、それらから文章を生成することができるため、人間が書いた文章をより正確に理解し、より自然な文章を生成することができます。また、GPT-3 は自然言語処理の技術が進展し、さまざまなアプリケーションに応用される可能性があります。\n一方、GPT-3 のデメリットとしては、トレーニングに使用されたデータ量が膨大であることもあり、モデルのサイズが大きく、使用する際には高性能なコンピュータが必要です。また、GPT-3 はトレーニングされたデータを基にしているため、トレーニング時の環境や文化的な背景などが反映される可能性があり、偏った文章を生成することもあると言われています。このような偏りを補正するためには、様々な文章データをトレーニングに使用することが重要です。\nGPT モデルのバージョン GPT シリーズには複数のバージョンがあります。GPT-1 が最初にリリースされた後、GPT-2、GPT-3、GPT-3 に続いて GPT-4、GPT-5 がリリースされまます。GPT シリーズは、トレーニングに使用されるデータ量が増えることで、モデルのサイズが大きくなり、性能が向上しています。GPT-3 は現在最新バージョンであり、トレーニングに使用されたデータ量が前バージョンのモデルよりも大きく、さらに高い性能を発揮します。\nその他 Chrome の拡張機能をインストールすると、検索する時、右上に ChatGPT の回答にも表示されてます。\n\n参照 https://knowstechnic.blogspot.com/2022/12/gpt3.html\n","permalink":"https://seiri-blog.github.io/posts/story-about-gpt3/","summary":"GPT とは GPT は Generative Pretrained Transformer の略で、トランスフォーマーを使った言語モデルの一種です。GPT は大量の文章データを分析し、それらから文章を生成することができ","title":"GPT3に関する話"},{"content":"ChatGPT とは  ChatGPT は、OpenAI が開発した大規模な言語処理の人工知能モデルです。GPT は「Generative Pre-trained Transformer」の略で、「生成的な事前学習トランスフォーマー」という意味です。 ChatGPT は、GPT のバリエーションのひとつで、自然言語を理解し、応答することができるようにトレーニングされています。 ChatGPT は、質問応答、文章生成、対話生成など、様々なタスクに使用することができます。  ChatGPT の使い方 今回では ChatGPT の使い方はアカウント作成から説明します。\n具体的なやり方は下記となりますので、ご参照いただければと思います。\n  下記 URL で OpenAI のアカウント作成します。\n  https://beta.openai.com/signup\n  メールアドレスを入力して、「Continue」ボタン押下する\n  \n パスワードを入力して、「Continue」ボタン押下する  \n 届いたメールに下記内容が表示されていて、中の「Verify email address」ボタンを押下する  \n 「FirstName」と「LastName」を入力し、「Continue」を押下する  \n 電話番号を入力して、「Send code」を押下する  \n 次の画面で電話番号宛てに送られてきた確認コードを入力する  \n 続けて OpenAI を利用する主目的を選択する  \n 選択したら「Continue to account」を押下し、アカウント作成を完了させる  \nOpenAI にログインして、ChatGPT と会話する  Chrome で https://chat.openai.com/chat をアクセスし OpenAI にログインするとチャット画面を表示する  \n 入力ボックスに内容を入力して、「Enter」を押下する  \n纏め  ChatGPT は OpenAPI の製品です、アカウント作成だけで、無料で使えます。 Google 検索と比べるインタネットの最新情報を検索できないですが、質問に対してはすぐ回答できる且つ、とても相応しい情報と思います。 回答に対してはコンテキストを理解できます今まで AI チャットとは違います。  ","permalink":"https://seiri-blog.github.io/posts/openai-how-to-use/","summary":"ChatGPT とは ChatGPT は、OpenAI が開発した大規模な言語処理の人工知能モデルです。GPT は「Generative Pre-trained Transformer」の略で、「生","title":"OpenAI 使い方"},{"content":"Amazon API Gateway とは Amazon API Gateway は、あらゆる規模の REST、HTTP、および WebSocket API を作成、公開、維持、モニタリング、およびセキュア化するための AWS のサービスです。API 開発者は、AWS または他のウェブサービス、AWS クラウドに保存されているデータにアクセスする API を作成できます。API Gateway API デベロッパーとして、独自のクライアントアプリケーションで使用するための API を作成できます。または、API をサードパーティーのアプリ開発者に対して使用可能にできます。詳細については、「API Gateway を使用するユーザー」を参照してください。\nAPI Gateway は、次のような RESTful API を作成します。\n  HTTP ベース。\n  ステートレスなクライアント/サーバー通信を有効にします。\n  GET、POST、PUT、PATCH、DELETE などの標準の HTTP メソッドを実装します。\n  API Gateway REST API および HTTP API の詳細については、「REST API と HTTP API 間で選択する」、「HTTP API の操作」、「API Gateway を使用して REST API を作成する」、および「Amazon API Gateway での REST API の作成」を参照してください。\nAPI Gateway は、以下のような WebSocket API を作成します。\n  WebSocket プロトコルを遵守します。これにより、クライアントとサーバー間のステートフルな全二重通信が可能になります。\n  メッセージの内容に基づいて、受信メッセージをルーティングします。\n  API Gateway WebSocket API の詳細については、「API Gateway を使用して WebSocket API を作成する」および「API Gateway での WebSocket API について」を参照してください。\nトピック  API Gateway のアーキテクチャ API Gateway の特徴 API Gateway のユースケース API Gateway へのアクセス AWS サーバーレスインフラストラクチャの一部 Amazon API Gateway の使用を開始する方法 Amazon API Gateway の概念 REST API と HTTP API 間で選択する  API Gateway のアーキテクチャ API Gateway のアーキテクチャを次の図に示します。\n\nこの図は、Amazon API Gateway で構築した API が、お客様、またはお客様のデベロッパーカスタマーに AWS サーバーレスアプリケーションを構築するための統合された一貫的なデベロッパーエクスペリエンスを提供する方法を示しています。API Gateway では、最大で数十万個の同時 API コールの受け入れ処理に伴うすべてのタスクを取り扱います。これにはトラフィック管理、認証とアクセスコントロール、モニタリング、API バージョン管理が含まれます。\nAPI Gateway は、例えば、Amazon Elastic Compute Cloud (Amazon EC2) で実行されているワークロード、AWS Lambda で実行されているコード、ウェブアプリケーション、リアルタイム通信アプリケーションなど、アプリケーションがバックエンドサービスからデータ、ビジネスロジック、機能にアクセスするための「フロントドア」として機能します。\nAPI Gateway の特徴 Amazon API Gateway には、次のような機能があります。\n  ステートフル (WebSocket) およびステートレス (HTTP と REST) API のサポート。\n  AWS Identity and Access Management ポリシー、Lambda オーソライザー関数、Amazon Cognito ユーザープールなど、強力で柔軟な認証メカニズム。\n  API を発行するための開発者ポータル。\n  変更を安全に進めるための Canary リリースのデプロイ。\n  API の使用状況と API の変更に関する CloudTrail ログ記録とモニタリング。\n  アラームの設定機能を含む、CloudWatch アクセスのログ記録と実行のログ記録。詳細については、「Amazon CloudWatch のメトリクスを使用した REST API の実行のモニタリング」および「CloudWatch メトリクスを使用した WebSocket API の実行のモニタリング」を参照してください。\n  AWS CloudFormation テンプレートを使用して API の作成を有効にする機能。詳細については、Amazon API Gateway Resource Types Reference および「Amazon API Gateway V2 リソースタイプのリファレンス」を参照してください。\n  カスタムドメイン名のサポート。\n  一般的なウェブの脆弱性から API を保護するための AWS WAF との統合。\n  パフォーマンスのレイテンシーを理解し、対処順位を決定するための AWS X-Ray との統合。\n  API Gateway 機能のリリースの完全なリストについては、「ドキュメント履歴」を参照してください。\nAPI Gateway へのアクセス Amazon API Gateway には、以下の方法でアクセスできます。\n  AWS Management Console – AWS Management Console は、API を作成して管理するためのウェブインターフェイスを提供します。「API Gateway の開始方法の前提条件」のステップを完了したら、https://console.aws.amazon.com/apigateway で API Gateway コンソールにアクセスできます。\n  AWS SDK – AWS が SDK を提供しているプログラミング言語を使用している場合は、SDK を使用して API Gateway にアクセスできます。SDK によって認証が簡素化され、開発環境との統合が容易になり、API Gateway コマンドにアクセスすることができます。詳細については、Tools for Amazon Web Services を参照してください。\n  API Gateway V1 および V2 API – SDK に対応していないプログラミング言語を使用している場合、Amazon API Gateway Version 1 API Reference と Amazon API Gateway Version 2 API Reference を参照してください。\n  AWS Command Line Interface – 詳細については、AWS Command Line Interface ユーザーガイドの「AWS Command Line Interface でのセットアップ」を参照してください。\n  AWS Tools for Windows PowerShell – 詳細については、AWS Tools for Windows PowerShell ユーザーガイドの「AWS Tools for Windows PowerShell のセットアップ」を参照してください。\n  AWS サーバーレスインフラストラクチャの一部 API Gateway は AWS Lambda と連携して、AWS サーバーレスインフラストラクチャのアプリケーション向けの部分を形成します。\nアプリケーションで一般的に利用可能な AWS のサービスを呼び出す場合は、Lambda を使用して必要なサービスとやり取りし、API Gateway で API メソッドを使用して Lambda 関数を公開することができます。AWS Lambda は、可用性に優れたコンピューティングインフラストラクチャでコードを実行します。また、必要に応じて、コンピューティングリソースを実行および管理します。サーバーレスアプリケーションを実現するため、API Gateway は AWS Lambda と HTTP エンドポイントによる合理化されたプロキシ統合をサポートします。\n参考 https://docs.aws.amazon.com/ja_jp/apigateway/latest/developerguide/welcome.html\n","permalink":"https://seiri-blog.github.io/posts/amazon-api-gateway/","summary":"Amazon API Gateway とは Amazon API Gateway は、あらゆる規模の REST、HTTP、および WebSocket API を作成、公開、維持、モニタリング、およびセキュア化するための AWS のサービスです","title":"Amazon API Gateway"},{"content":"AWS Lambda とは Lambda はサーバーをプロビジョニングしたり管理しなくてもコードを実行できるコンピューティングサービスです。Lambda は可用性の高いコンピューティングインフラストラクチャでコードを実行し、コンピューティングリソースの管理をすべて担当します。これにはサーバーおよびオペレーティングシステムのメンテナンス、容量のプロビジョニングおよびオートスケーリング、コードのモニタリングおよびログ記録などが含まれます。Lambda を使用すると、実質どのようなタイプのアプリケーションやバックエンドサービスに対してもコードを実行できます。必要なのは、Lambda がサポートするいずれかの言語でコードを指定することだけです。\nコードを Lambda 関数に整理します。Lambda は必要に応じて関数を実行し、1 日あたり数個から 1 秒あたり数千個のリクエストまで自動的にスケーリングします。課金は実際に消費したコンピューティング時間に対してのみ発生します。コードが実行されていない場合、料金は発生しません。\nLambda API を使用して Lambda 関数を呼び出したり、他の AWS のサービスからのイベントに応答して Lambda が関数を実行したりできます 例えば、Lambda を使用して以下のことができます。\n  AWS のサービス (Amazon Simple Storage Service (Amazon S3) や Amazon DynamoDB など) のデータ処理トリガーの構築。\n  Amazon Kinesis に保存されたストリーミングデータの処理。\n  AWS 規模、パフォーマンス、セキュリティで動作する独自のバックエンドの作成。\n  Lambda は可用性の高いサービスです。詳細については、「AWS Lambda サービスレベルアグリーメント」を参照してください。\nセクション  Lambda が適している用途 Lambda の機能 Lambda の開始方法 関連サービス Lambda へのアクセス Lambda の料金  Lambda が適している用途 Lambda は、多くのアプリケーションシナリオにとって最適なコンピューティングサービスです。Lambda によって提供されるリソース内で - Lambda スタンダードランタイム環境を使用しながら、アプリケーションのコードを実行できます。\nLambda を使用する際、ユーザーが責任を負うのはコードのみです。Lambda によって、コードを実行するメモリのバランス、CPU、ネットワーク、その他のリソースを提供するコンピューティングフリートが管理されます。Lambda がこれらのリソースを管理するため、コンピューティングインスタンスにログインしたり、提供されたランタイムのオペレーティングシステムをカスタマイズしたりすることはできません。Lambda は、容量の管理、モニタリング、Lambda 関数のログ記録など、運用および管理アクティビティをユーザーに代わって実行します。\nAWS では、独自のコンピューティングリソースを管理する必要があるお客様に対しても、その目的に適した、他のコンピューティングサービスをご用意しています。次に例を示します。\nAmazon Elastic Compute Cloud (Amazon EC2) は、選択するさまざまな EC2 インスタンスタイプを提供します。このため、オペレーティングシステム、ネットワークやセキュリティの設定、ソフトウェアスタック全体をカスタマイズすることができます。容量のプロビジョニング、フリートの状態とパフォーマンスのモニタリング、および耐障害性のためのアベイラビリティゾーンの使用は、お客様が行う作業となります。\nAWS Elastic Beanstalk では、アプリケーションを Amazon EC2 にデプロイし、スケーリングできます。基盤となる EC2 インスタンスに対する所有権と完全なコントロール権は、お客様が保持します。\nLambda の機能 次の主要な機能は、スケーラブルで安全で拡張が容易な Lambda アプリケーションの開発に役立ちます。\n同時実行とスケーリングコントロール 同時実行制限やプロビジョニングされた同時実行などの 同時実行とスケーリング制御 により、製品アプリケーションのスケーリングと応答性をきめ細かく制御できます。\nコンテナイメージとして定義された関数 お好きなコンテナイメージツール、ワークフロー、依存関係を使用して、Lambda 関数を構築、テスト、デプロイできます。\nコード署名 Lambda のコード署名により、信頼性と整合性を管理できます。それにより、承認されたデベロッパーによって公開された未変更のコードのみが、Lambda 関数にデプロイされていることを確認できます。\nLambda の拡張 Lambda 拡張機能を使用して Lambda 関数を補強できます。拡張機能を使用すると、モニタリング、観測、セキュリティ、ガバナンス用のお気に入りのツールと Lambda を容易に統合できます。\n関数ブループリント 関数ブループリントは、他の AWS サービスやサードパーティーのアプリケーションで Lambda を使用する方法を示すサンプルコードを提供します。ブループリントには、Node.js および python ランタイム用のサンプルコードおよび関数設定プリセットが含まれています。\nデータベースアクセス データベースプロキシ は、データベース接続のプールを管理し、関数からのクエリを中継します。これにより、関数はデータベース接続を使い果たすことなく、同時実行レベルを上げることができます。\nファイルシステムのアクセス Amazon Elastic File System (Amazon EFS) ファイルシステムをローカルディレクトリにマウントするように関数を設定できます。Amazon EFS を使用すると、関数コードは共有リソースに安全かつ高い同時実行数でアクセスして変更できます。\nLambda の開始方法 Lambda を効果的に操作するには、次のドメインにおけるコーディングの経験と専門知識が必要です。\n  Linux OS とコマンド、および、プロセス、スレッド、ファイル権限などの概念。\n  クラウドの概念と IP ネットワークの概念 (パブリックネットワークとプライベートネットワーク)。\n  IPC、キュー、メッセージング、通知、同時実行としての、HTTP などの分散コンピューティングの概念。\n  セキュリティサービスと概念に精通していること: AWS Identity and Access Management (IAM) とアクセス制御の原則、および AWS Key Management Service (AWS KMS) と公開キーインフラストラクチャ。\n  Lambda と対話する主要なサービスに関する知識: Amazon API Gateway、Amazon S3、Amazon Simple Queue Service (Amazon SQS)、DynamoDB。\n  Linux を使用して EC2 インスタンスを設定する。\n    Lambda を初めて使用する場合は、ベーシックな学習に役立つ以下のトピックからスタートすることをお勧めします。\n  Lambda の製品概要と、「Lambda 使用開始」ページをお読みください。\n  Lambda コンソールを使用して Lambda 関数を作成してテストするには、コンソールベースの使用開始演習をお試しください。この演習では、Lambda プログラミングモデルやその他の概念について説明します。\n  コンテナイメージのワークフローに精通しているという場合は、使用開始演習を実行して、コンテナイメージとして定義された Lambda 関数を作成してください。\n  AWS では、サーバーレスアプリケーションと Lambda について学習するための次のリソースも提供しています。\n  AWS コンピューティングブログには Lambda に関する役立つ記事が掲載されています。\n  AWS Serverless は AWS サーバーレス開発に関連するブログ、ビデオ、トレーニングを提供します。\n  AWS オンラインテクニカルトーク YouTube チャンネルには、Lambda 関連トピックに関する動画が投稿されています。サーバーレスアプリケーションと Lambda の概要については、「AWS Lambda とサーバーレスアプリケーションの概要」ビデオを参照してください。\nLambda へのアクセス 次のいずれかのインタフェースを使用して、Lambda 関数を作成、呼び出し、管理できます。\n  AWS マネジメントコンソールは、関数にアクセスするためのウェブインターフェースを提供します。詳細については、「Lambda コンソール」を参照してください。\n  AWS Command Line Interface (AWS CLI) – Lambda を含むさまざまな AWS サービス用のコマンドを備え、Windows、macOS、Linux でサポートされています。詳細については、「AWS CLI での Lambda の使用」を参照してください。\n  AWS SDK – 言語固有の API を提供し、署名の計算、リクエストの再試行処理、エラー処理など、各種接続の詳細を管理します。詳細については、AWSSDK をご参照ください。\n  AWS CloudFormation – Lambda アプリケーションを定義するテンプレートを作成します。詳細については、「AWS Lambda アプリケーション 」を参照してください。AWS CloudFormation は AWS Cloud Development Kit (CDK)もサポートしています。\n  AWS Serverless Application Model (AWS SAM) – AWS サーバレスアプリケーションを設定および管理するためのテンプレートと CLI を提供します。詳細については、「SAM CLI」を参照してください。\n  Lambda の料金 Lambda 関数の作成に追加料金はかかりません。関数の実行や、Lambda と他の AWS サービス間のデータ転送には料金が発生します。一部のオプション Lambda 機能 (プロビジョニングされた同時実行など) にも料金が発生します。詳細については、AWS Lambda 料金を参照してください。\n参考 https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/welcome.html\n","permalink":"https://seiri-blog.github.io/posts/aws-lambda/","summary":"AWS Lambda とは Lambda はサーバーをプロビジョニングしたり管理しなくてもコードを実行できるコンピューティングサービスです。Lambda は可用性の高いコンピ","title":"AWS Lambda"},{"content":"Amazon S3 とは Amazon Simple Storage Service (Amazon S3) は、業界をリードするスケーラビリティ、データ可用性、セキュリティ、およびパフォーマンスを提供するオブジェクトストレージサービスです。あらゆる規模や業界のお客様が、Amazon S3 を使用して、データレイク、ウェブサイト、モバイルアプリケーション、バックアップおよび復元、アーカイブ、エンタープライズアプリケーション、IoT デバイス、ビッグデータ分析など、広範なユースケースのデータを容量にかかわらず、保存して保護することができます。Amazon S3 には、特定のビジネス、組織、コンプライアンスの要件を満たすために、データへのアクセスを最適化、整理、設定できる管理機能があります。\nトピック  Amazon S3 の機能 Amazon S3 の仕組み Amazon S3 のデータ整合性モデル 関連する のサービス Amazon S3 へのアクセス Amazon S3 の支払い PCI DSS コンプライアンス  Amazon S3 の機能 ストレージクラス Amazon S3 では、さまざまなユースケース向けに、幅広いストレージクラスが提供されています。例えば、ミッションクリティカルな本番データを S3 Standard に保存して頻繁にアクセスしたり、アクセス頻度の低いデータを S3 標準 – IA または S3 1 ゾーン – IA に保存してコストを節約したり、S3 Glacier Instant Retrieval、S3 Glacier Flexible Retrieval、S3 Glacier Deep Archive でデータを最も低いコストでアーカイブしたりできます。\nS3 Intelligent-Tiering では、変更する、または不明なアクセスパターンを持つデータを保存できます。これにより、アクセスパターンが変更されたときに 4 つのアクセス層間でデータを自動的に移動することで、ストレージコストを最適化できます。4 つのアクセス階層にあ、高頻度のアクセスと低頻度のアクセス用に最適化された 2 つの低レイテンシーのアクセス階層と、稀にしかアクセスされないデータ向けに設計された非同期アクセス用の 2 つのオプトインアーカイブアクセス階層があります。\n詳細については、「Amazon S3 ストレージクラスを使用する」を参照してください。S3 Glacier Flexible Retrieval の詳細については、Amazon S3 Glacier デベロッパーガイドを参照してください。\nストレージ管理 Amazon S3 には、コストの管理、規制要件への対応、レイテンシーの削減、コンプライアンス要件のためのデータの複数の個別コピーの保存で使用できるストレージ管理機能があります。\n  S3 ライフサイクル – オブジェクトを管理し、ライフサイクルを通じてコスト効率の高い方法で保存できるようにライフサイクルポリシーを設定します。オブジェクトを他の S3 ストレージクラスに移行したり、ライフタイムが終了したオブジェクトを期限切れにすることができます。\n  S3 オブジェクトロック – Amazon S3 オブジェクトが固定期間または無期限に削除または上書きされるのを防止します。オブジェクトロックを使用して、write-once-read-many (WORM) ストレージを必要とする規制要件を満たしたり、オブジェクトの変更や削除に対する保護レイヤーを追加したりできます。\n  S3 レプリケーション – オブジェクトおよびそれぞれのメタデータタグとオブジェクトタグを、同じまたは異なる AWS リージョン にある 1 つまたは複数のレプリケーション先バケットにレプリケートして、レイテンシーの削減、コンプライアンス、セキュリティ、その他のユースケースで活用できます。\n  S3 バッチ操作 – 1 つの S3 API リクエストまたは Amazon S3 コンソールで数回クリックするだけで、数十億のオブジェクトを大規模に管理できます。バッチ操作を使用すると、次のようなオペレーションを実行できます。コピー、AWS Lambda 関数の呼び出し、数百万または数十億のオブジェクトの復元。\n  アクセス管理 Amazon S3 には、バケットとオブジェクトへのアクセスを監査および管理する機能があります。デフォルトでは、S3 バケットとオブジェクトはプライベートです。作成した S3 リソースにのみアクセスできます。以下の機能を使用して、特定のユースケースをサポートする詳細なリソース許可を付与したり、Amazon S3 リソースの許可を監査したりできます。\n  S3 ブロックパブリックアクセス – S3 バケットおよびオブジェクトへのパブリックアクセスをブロックします。デフォルトでは、ブロックパブリックアクセス設定はアカウントレベルとバケットレベルで有効になっています。\n  AWS Identity and Access Management (IAM) – AWS アカウント の IAM ユーザーを作成して、Amazon S3 リソースへのアクセスを管理します。例えば、Amazon S3 で IAM を使用して、AWS アカウント が所有する S3 バケットに対するユーザーまたはユーザーグループのアクセス権のタイプをコントロールすることができます。\n  バケットポリシー – IAM ベースのポリシー言語を使用して、S3 バケットとその中のオブジェクトに対するリソースベースの許可を設定します。\n  Amazon S3 アクセスポイント — 専用アクセスポリシーを持つ名前付きネットワークエンドポイントを設定して、Amazon S3 の共有データセットへの大規模なデータアクセスを管理します。\n  アクセスコントロールリスト (ACL) – 個々のバケットおよびオブジェクトに対する読み取りおよび書き込みの許可を、承認されたユーザーに付与します。原則として、アクセスコントロールには ACL ではなく S3 リソースベースのポリシー (バケットポリシーとアクセスポイントポリシー) または IAM ポリシーを使用することをお勧めします。ACL は、リソースベースのポリシーと IAM よりも優先されるアクセスコントロールメカニズムです。リソースベースのポリシーまたは IAM ポリシーの代わりに ACL を使用する場合の詳細については、「アクセスポリシーのガイドライン」を参照してください。\n  S3 オブジェクト所有権 - ACL を無効にし、バケット内のすべてのオブジェクトの所有権を取得し、Amazon S3 に保存されているデータのアクセス管理を簡素化します。バケット所有者はバケット内のすべてのオブジェクトを自動的に所有し完全に制御できます。データのアクセス制御はポリシーに基づきます。\n  Access Analyzer for S3 – S3 バケットアクセスポリシーを評価およびモニタリングし、ポリシーが S3 リソースへの意図したアクセスのみを提供することを確認します。\n  データ処理 データを変換し、ワークフローをトリガーして、他のさまざまな処理アクティビティを大規模に自動化するには、次の機能を使用できます。\n  S3 Object Lambda – Amazon S3 GET リクエストに独自のコードを追加して、データがアプリケーションに返されるときにそのデータを変更および処理できます。行のフィルタリング、画像の動的なサイズ変更、機密データの編集などを行います。\n  イベント通知 – S3 リソースに変更が加えられると、Amazon Simple Notification Service (Amazon SNS)、Amazon Simple Queue Service (Amazon SQS)、および AWS Lambda を使用するワークフローをトリガーします。\n  ストレージのログ記録とモニタリング Amazon S3 には、Amazon S3 リソースの使用状況をモニタリングおよびコントロールするために使用できるロギングおよびモニタリングツールが用意されています。詳細については、「モニタリングツール 」を参照してください。\n自動モニタリングツール   Amazon S3 の Amazon CloudWatch メトリクス – TS3 リソースのオペレーション状態を追跡し、推定請求額がユーザー定義のしきい値に達したときに請求アラートを設定します。\n  AWS CloudTrail – ユーザー、ロール、または Amazon S3 で AWS のサービス によって行われるアクションを記録します。CloudTrail ログを使用すると、S3 バケットレベルおよびオブジェクトレベルのオペレーションの詳細な API 追跡が可能になります。\n  手動モニタリングツール   サーバーアクセスログ – バケットに対するリクエストの詳細が記録されます。サーバーアクセスのログ記録を使用して、セキュリティとアクセスの監査、カスタマーベースに関するラーニング、Amazon S3 請求書の把握などの多くのユースケースに対応できます。\n  AWSTrusted Advisor – AWS ベストプラクティスチェックを使用してアカウントを評価し、AWS インフラストラクチャを最適化し、セキュリティとパフォーマンスを向上させ、コストを削減し、サービスクォータを監視する方法を特定します。その後、推奨事項に従って、サービスとリソースを最適化できます。\n  分析とインサイト Amazon S3 には、ストレージの使用状況を可視化するための機能が用意されています。これにより、ストレージを大規模に理解、分析し、最適化することができます。\n  Amazon S3 Storage Lens – ストレージを理解、分析し、最適化します。S3 Storage Lens は、29 以上の使用状況およびアクティビティのメトリクスとインタラクティブなダッシュボードを提供し、組織全体、特定のアカウント、AWS リージョン、バケット、またはプレフィックスに関するデータを集約します。\n  ストレージクラス分析 – ストレージアクセスパターンを分析して、よりコスト効果の高いストレージクラスにデータを移動するタイミングを決定します。\n  インベントリ付き S3 インベントリレポート – オブジェクトとそれに対応するメタデータを監査してレポートし、インベントリレポートでアクションを実行するように他の Amazon S3 機能を設定します。例えば、オブジェクトのレプリケーションと暗号化のステータスをレポートできます。インベントリレポートの各オブジェクトで使用できるすべてのメタデータのリストについては、「Amazon S3 インベントリリスト」を参照してください。\n  強力な整合性 Amazon S3 には、すべての AWS リージョン にある Amazon S3 バケットの、オブジェクトの PUT と DELETE に関する、書き込み後読み取りの強力な整合性があります。この動作は、新しいオブジェクトへの書き込みと、既存のオブジェクトを上書きする PUT、そして DELETE リクエストにも適用されます。さらに、Amazon S3 Select、Amazon S3 アクセスコントロールリスト (ACL)、Amazon S3 オブジェクトタグ、オブジェクトメタデータ (HEAD オブジェクトなど) での読み込みオペレーションには、強力な整合性があります。詳細については、「Amazon S3 のデータ整合性モデル」を参照してください。\nAmazon S3 の仕組み Amazon S3 は、データをオブジェクトとしてバケットに保存するオブジェクトストレージサービスです。オブジェクトとは、ファイルと、そのファイルを記述している任意のメタデータのことです。バケット とは、オブジェクトのコンテナのことです。\nAmazon S3 にデータを保存するには、まずバケットを作成し、バケット名および AWS リージョン を指定します。次に、Amazon S3 のオブジェクトとしてそのバケットにデータをアップロードします。各オブジェクトには、キー(またはキー名) があります。これは、バケット内のオブジェクトの一意の識別子です。\nS3 には、特定のユースケースをサポートするように設定できる機能があります。例えば、S3 Versioning を使用すると、オブジェクトの複数のバージョンを同じバケットに保持し、誤って削除または上書きされたオブジェクトを復元することができます。\nバケットとその中のオブジェクトはプライベートであり、アクセス許可を明示的に付与した場合にのみアクセスできます。バケットポリシー、AWS Identity and Access Management(IAM) ポリシー、アクセスコントロールリスト (ACL)、および S3 アクセスポイントを使用して、アクセスを管理できます。\nトピック  バケット オブジェクト キー S3 バージョニング バージョン ID バケットポリシー S3 アクセスポイント アクセスコントロールリスト (ACL) リージョン  バケット バケットとは、Amazon S3 に保存されるオブジェクトのコンテナです。バケットにはオブジェクトをいくつでも保存でき、アカウントにはバケットを 100 個まで保存できます。増加をリクエストするには、Service Quotas コンソールにアクセスしてください。\nすべてのオブジェクトはバケット内に保存されます。例えば、photos/puppy.jpg という名前のオブジェクトが米国西部 (オレゴン) リージョンにある DOC-EXAMPLE-BUCKET バケットに保存される場合、URL https://DOC-EXAMPLE-BUCKET.s3.us-west-2.amazonaws.com/photos/puppy.jpg を使用してアドレスを解決できます。詳細については、「バケットへのアクセス」を参照してください。\nバケットを作成するときは、バケット名を入力し、バケットが存在する AWS リージョン を選択します。一度バケットを作成したら、そのバケット名またはリージョンを変更することはできません。バケット名は、バケットの命名規則に従う必要があります。また、バケットを設定して、S3 バージョニングまたは、他のストレージ管理機能を使用できます。\nバケットは、以下も行います。\n  最も高いレベルで Amazon S3 名前空間を編成します。\n  ストレージおよびデータ転送料金が課金されるアカウントを特定します。\n  バケットポリシー、アクセスコントロールリスト (ACL)、および S3 アクセスポイントなどのアクセスコントロールオプションを提供します。これを使用すると、Amazon S3 リソースへのアクセスを管理できます。\n  使用状況レポートの集計単位として機能します。\n  バケットの詳細については、「バケットの概要」を参照してください。\nオブジェクト オブジェクトとは、Amazon S3 に保存される基本エンティティです。オブジェクトは、オブジェクトデータとメタデータで構成されます。メタデータは、オブジェクトを表現する名前と値のペアのセットです。これには最終更新日などのデフォルトメタデータや、Content-Type などの標準 HTTP メタデータが含まれます。また、オブジェクトの保存時にカスタムメタデータを指定することもできます。\nオブジェクトは、バケット内でキー (名前)とバージョン ID（バケットで S3 バージョニングが有効になっている場合）によって一意に特定されます。オブジェクトの詳細については、Amazon S3 オブジェクトの概要 を参照してください。\nキー オブジェクトキー (または キー名) は、バケット内のオブジェクトの固有の識別子です。バケット内のすべてのオブジェクトは、厳密に 1 個のキーを持ちます。バケット、オブジェクトキー、およびオプションでバージョン ID（バケットで S3 バージョニングが有効になっている場合）の組み合わせによって、各オブジェクトが一意に識別されます。そのため、Amazon S3 を「バケット + キー + バージョン」とオブジェクト自体の間での基本データマップと考えることができます。\nAmazon S3 内の各オブジェクトは、ウェブサービスエンドポイント、バケット名、キー、およびオプションでバージョンを組み合わせることで一意にアドレスを指定できます。例えば、https://DOC-EXAMPLE-BUCKET.s3.us-west-2.amazonaws.com/photos/puppy.jpg という URL で、「DOC-EXAMPLE-BUCKET」がバケットの名前で、「photos/puppy.jpg」がキーです。\nオブジェクトキーの詳細については、「オブジェクトキー名の作成」を参照してください。\nS3 バージョニング 同じバケット内でオブジェクトの複数のバリアントを保持するには、S3 バージョニングを使用します。S3 バージョニングを使用すると、 バケットに保存されたあらゆるオブジェクトのあらゆるバージョンを保存、取得、復元することができます。バージョニングを使用すれば、意図しないユーザーアクションからもアプリケーション障害からも、簡単に復旧できます。\n詳細については、「S3 バケットでのバージョニングの使用」を参照してください。\nバージョン ID バケットで S3 バージョニングを有効にすると、Amazon S3 はバケットに追加されたすべてのオブジェクトに一意のバージョン ID を与えます。バージョニングを有効にした時点でバケットにすでに存在していたオブジェクトのバージョン ID は null です。これらの (またはその他の) オブジェクトを他のオペレーション (CopyObject および PutObject) で変更すると、新しいオブジェクトは一意のバージョン ID を取得します。\n詳細については、「S3 バケットでのバージョニングの使用」を参照してください。\nバケットポリシー バケットポリシーは、リソースベースの AWS Identity and Access Management (IAM) ポリシーを使用して、バケットとその中のオブジェクトへのアクセス許可を付与できます。バケット所有者のみが、ポリシーをバケットに関連付けることができます。バケットに添付された許可は、バケット所有者が所有するバケットのすべてのオブジェクトに適用されます。バケットポリシーのサイズは 20 KB に制限されています。\nバケットポリシーは、AWS で標準である JSON ベースのアクセスポリシー言語を使用しています。バケットポリシーを使用して、バケット内のオブジェクトに対する許可を追加または拒否できます。バケットポリシーは、リクエスタ、S3 アクション、リソース、リクエストの側面または条件(リクエストの作成に使用された IP アドレスなど)など、ポリシー内のエレメントに基づいてリクエストを許可または拒否します。例えば、バケット所有者がアップロードされたオブジェクトを完全にコントロールできるように、S3 バケットにオブジェクトをアップロードするクロスアカウント許可を付与するバケットポリシーを作成できます。詳細については、バケットポリシーの例 を参照してください。\nバケットポリシーでは、Amazon リソースネーム (ARN) やその他の値に対してワイルドカード文字を使用して、オブジェクトのサブセットに対する許可を付与できます。例えば、共通のプレフィックスで始まるか、.html などの特定の拡張子で終わるオブジェクトのグループへのアクセスをコントロールできます。\nS3 アクセスポイント Amazon S3 アクセスポイントは、そのエンドポイントを使用してデータにアクセスする方法を説明する専用のアクセスポリシーを持つ名前付きネットワークエンドポイントです。アクセスポイントは、バケットにアタッチされ、それを使用して、GetObject や PutObject などの S3 オブジェクト操作を実行できます。アクセスポイントは、Amazon S3 の共有データセットへの大規模なデータアクセスの管理を簡素化します。\n各アクセスポイントには独自のアクセスポイントポリシーがあります。また、アクセスポイントごとにブロックパブリックアクセス設定を設定することもできます。Virtual Private Cloud (VPC) からのリクエストだけを受け入れるようにアクセスポイントを設定することで、プライベートネットワークへの Amazon S3 データアクセスを制限できます。\n詳細については、「Amazon S3 アクセスポイントを使用したデータアクセスの管理」を参照してください。\nアクセスコントロールリスト (ACL) ACL を使用して、個々のバケットとオブジェクトの読み取りと書き込みの許可を認可されたユーザーに付与できます。各バケットとオブジェクトには、サブリソースとして ACL がアタッチされています。ACL は、アクセスを付与する AWS アカウント またはグループまたはアクセスのタイプを定義します。ACL は IAM よりも優先されるアクセスコントロールメカニズムです。ACL の詳細については、アクセスコントロールリスト (ACL) の概要 を参照してください。\n別の AWS アカウント が S3 バケットにオブジェクトをアップロードした場合、そのアカウント（オブジェクトライター）がデフォルトでオブジェクトを所有し、そのオブジェクトへのアクセス権を持ち、ACL を介して他のユーザーにそのオブジェクトへのアクセス権を付与できます。オブジェクトの所有権を使用してこのデフォルトの動作を変更し、ACL を無効にして、バケット所有者としてバケット内のすべてのオブジェクトを自動的に所有することができます。その結果、データのアクセスコントロールは、IAM ポリシー、S3 バケットポリシー、仮想プライベートクラウド (VPC) エンドポイントポリシー、AWS Organizations サービスコントロールポリシー (SCP) などのポリシーに基づいています。\nAmazon S3 の最新のユースケースの大部分では ACL を使用する必要がなくなり、オブジェクトごとに個別にアクセスを制御する必要がある異常な状況を除き、ACL を無効にすることをお勧めします。オブジェクトの所有権を使用すると ACL を無効にして、アクセスコントロールに関するポリシーに依存できます。ACL を無効にすると、別の AWS アカウント によってアップロードされたオブジェクトを含むバケットを簡単に維持できます。バケット所有者は、バケット内のすべてのオブジェクトを所有し、ポリシーを使用してオブジェクトへのアクセスを管理できます。詳細については、「オブジェクトの所有権の制御とバケットの ACL の無効化。」を参照してください。\nリージョン 作成したバケットを Amazon S3 が保存する地理的な AWS リージョン を選択できます。レイテンシーを最適化し、コストを最小限に抑えて規制用件に対応できるリージョンを選ぶとよいでしょう。明示的に別のリージョンに移動またはレプリケートする場合を除き、AWS リージョン に保存されたオブジェクトは、そのリージョンから移動されることはありません。たとえば、欧州 (アイルランド) リージョンに格納されたオブジェクトは、ずっとそのリージョンに置かれたままです。\nAmazon S3 のデータ整合性モデル Amazon S3 には、すべての AWS リージョン にある Amazon S3 バケットの、オブジェクトの PUT と DELETE に関する、書き込み後読み取りの強力な整合性があります。この動作は、新しいオブジェクトへの書き込みと、既存のオブジェクトを上書きする PUT リクエスト、そして DELETE リクエストにも適用されます。さらに、Amazon S3 Select、Amazon S3 アクセスコントロールリスト (ACL)、Amazon S3 オブジェクトタグ、オブジェクトメタデータ (HEAD オブジェクトなど) での読み込みオペレーションには、強力な整合性があります。\n単一のキーに対する更新はアトミックです。例えば、あるスレッドから既存のキーに PUT リクエストを実行し、同時に同じキーに対して別のスレッドから GET リクエストを実行すると、古いデータまたは新しいデータを取得できますが、データの一部分だけが取得されることも、破損することもありません。\nAmazon S3 は、AWS データセンターに配置された複数のサーバー間でデータを複製することにより、高可用性を実現します。PUT リクエストが成功した場合、データは安全に保存されています。成功した PUT 応答の受信後に開始された読み取り (GET または LIST) は、PUT リクエストによって書き込まれたデータを返します。この動作の例を示します。\n  新しいオブジェクトを Amazon S3 に書き込み、すぐにバケット内のキーを一覧表示します。新しいオブジェクトがリストに表示されます。\n  既存のオブジェクトを置換し、すぐにそのオブジェクトの読み取りを試みます。Amazon S3 が新しいデータを返します。\n  既存のオブジェクトを削除し、すぐにそのオブジェクトの読み取りを試みます。オブジェクトが削除されたため、Amazon S3 はデータを返しません。\n  既存のオブジェクトを削除し、すぐにバケット内のキーのリストを表示します。オブジェクトはリストに表示されません。\n  バケット設定には、結果整合性モデルがあります。具体的には、次のように処理されます。\n  バケットを削除してすぐにすべてのバケットを一覧表示しても、削除されたバケットは引き続きリストに表示されます。\n  バケットで初めてバージョニングを有効にしたときは、変更が完全に反映されるまでに、少し時間がかかることがあります。バケットへのオブジェクトの書き込みオペレーション (PUT または DELETE リクエスト) は、バージョニングを有効にして 15 分待ってから発行することをお勧めします。\n  アプリケーションの同時実行 このセクションでは、同じアイテムに複数のクライアントから書き込むときに、Amazon S3 で予想される動作の例を示します。\n次の例では、R1 (読み取り 1) と R2 (読み取り 2) の開始前に W1 (書き込み 1) と W2 (書き込み 2) が完了しています。S3 には強固な整合性があるため、R1 と R2 はどちらも color = ruby を返します。\n\n次の例では、R1 の開始前に、W2 は完了していません。したがって、R1 は color = ruby または color = garnet を返す可能性があります。ただし、R2 が開始する前に W1 と W2 が終了するため、R2 は color = garnet を返します。\n\n最後の例では、W1 が受信確認を受け取る前に、W2 が開始します。したがって、これらは同時の書き込みとみなされます。どの書き込みを優先するのかを決定するにあたり、Amazon S3 は内部的に last-writer-wins セマンティクスを使用します。しかし、ネットワークレイテンシーなどのさまざまな要因により、Amazon S3 がリクエストを受信する順序や、アプリケーションが受信確認を受け取る順序を予測することはできません。例えば、W2 が同じリージョンにある Amazon EC2 インスタンスによって開始される一方で、W1 は遠くにあるホストによって開始されるかもしれません。両方の書き込みの受信確認を受け取った後に、読み込みを実行することが、最終的な値を決定する最善の方法です。\n\n関連する のサービス Amazon S3 にロードしたデータは、他の AWS のサービスでも利用できます。よく使用すると思われるサービスは次のとおりです。\n  Amazon Elastic Compute Cloud (Amazon EC2) – AWS クラウド でスケーラブルなコンピューティングキャパシティーを提供します。Amazon EC2 の使用により、ハードウェアに事前投資する必要がなくなり、アプリケーションをより速く開発およびデプロイできます。Amazon EC2 を使用すると、必要な数 (またはそれ以下) の仮想サーバーの起動、セキュリティおよびネットワーキングの構成、ストレージの管理ができます。\n  Amazon EMR – ビジネス、研究者、データアナリスト、およびデベロッパーが、簡単かつ費用対効果の高い方法で、莫大な量のデータを処理できます。Amazon EMR は、Amazon EC2 および Amazon S3 のウェブスケールのインフラストラクチャ上で稼動するホストされた Hadoop フレームワークを使用しています。\n  AWSSnow ファミリー– 厳しいデータセンター以外の環境や、一貫性のあるネットワーク接続がない場所で運用を実行する必要があるお客様を支援します。AWS Snow ファミリーデバイスを使用して、インターネットに接続できない環境で、ローカルでコスト効果の高い方法で AWS クラウド のストレージおよび処理能力にアクセスできます。\n  AWS Transfer Family – セキュアシェル (SSH) ファイル転送プロトコル（SFTP）、SSL 経由ファイル転送プロトコル（FTPS）、およびファイル転送プロトコル（FTP）を使用して、Amazon S3 または Amazon Elastic File System（Amazon EFS）との間で直接ファイル転送を行う完全マネージドサポートを提供します。\n  Amazon S3 へのアクセス Amazon S3 は次のいずれかの方法で使用できます。\nAWS Management Console コンソールは、Amazon S3 と AWS リソースを管理するためのウェブベースのユーザーインターフェイスです。AWS アカウント にサインアップ済みの場合は、AWS Management Console にサインインし、AWS Management Console ホームページから [S3] を選択することで、Amazon S3 コンソールにアクセスできます。\nAWS Command Line Interface AWS コマンドラインツールを使用して、コマンドを発行するか、システムのコマンドラインでスクリプトを作成して AWS (S3 を含む) タスクを実行します。\nAWS Command Line Interface (AWS CLI) は、幅広い AWS のサービス のセットに対するコマンドを提供します。AWS CLI は、Windows、macOS、Linux でサポートされています。使用を開始するには、「 AWS Command Line Interface ユーザーガイド」を参照してください。Amazon S3 用コマンドの詳細については、AWS CLI コマンドリファレンスの s3api および s3control を参照してください。\nAWS SDK AWS には、さまざまなプログラミング言語およびプラットフォーム (Java、python、Ruby、.NET、iOS、Android など) のライブラリとサンプルコードで構成された SDK (ソフトウェア開発キット) が用意されています。AWS SDK は、S3 や AWS へのプログラムによるアクセスを作成するのに役立ちます。Amazon S3 は REST サービスです。AWS SDK ライブラリを使用して Amazon S3 にリクエストを送信できます。これは、基盤となる Amazon S3 REST API をラップし、プログラミングタスクを簡素化します。例えば、SDK は署名の計算、リクエストの暗号化による署名、エラーの管理、リクエストの自動再試行などのタスクを処理します。AWS SDK のダウンロードやインストールなどの詳細については、「AWS のツール」を参照してください。\nAmazon S3 とのすべてのやり取りは認証されるか匿名で行われます。AWS SDK を使用している場合、指定したキーから、ライブラリによって認証のための署名が計算されます。Amazon S3 へのリクエストの作成方法の詳細については、「リクエストの実行」を参照してください。\nAmazon S3 REST API Amazon S3 は、プログラミング言語に依存しないアーキテクチャとして設計されており、AWS がサポートされているインターフェイスを使用してオブジェクトを保存、取得します。Amazon S3 REST API を使用して、プログラムによって S3 や AWS にアクセスすることができます。REST API は、Amazon S3 に対する HTTP インターフェイスです。REST API では、標準 HTTP リクエストを使用してバケットとオブジェクトを作成、取得、削除できます。\nREST API を使用する場合、HTTP をサポートする任意のツールキットを使用できます。匿名で読み取り可能なオブジェクトであれば、ブラウザを使用して取得することもできます。\nREST API は標準の HTTP ヘッダーとステータスコードを使用するため、標準のブラウザとツールキットが予期したとおりに機能します。一部のエリアでは、HTTP に機能が追加されています (たとえば、アクセスコントロールをサポートするヘッダーを追加しました)。このように新機能を追加する場合、できるだけ標準 HTTP 書式の使用法に合致するように最善を尽くしました。\nただし、アプリケーションで直接 REST API を呼び出す場合、署名を計算するコードを作成し、それをリクエストに追加する必要があります。Amazon S3 へのリクエストの作成方法の詳細については、「リクエストの実行」を参照してください。\nAmazon S3 の支払い Amazon S3 の料金は、アプリケーションのストレージ要件を考慮しなくてすむように設定されています。ほとんどのストレージプロバイダーでは、あらかじめ決められた量のストレージおよびネットワーク転送容量を購入する必要があります。このシナリオでは、その容量を超えると、サービスが停止されるか、高額な超過料金を支払う必要があります。その容量を超えない場合でも、全量を使用したものとして支払うことになります。\nAmazon S3 では、実際に使用した分だけが請求されます。隠れた料金や超過料金はありません。このモデルでは、AWS インフラストラクチャのコスト面のメリットを得ながら、ビジネスの成長に応じた可変コストのサービスを利用することができます。詳細については、Amazon S3 の料金 を参照してください。\nAWS にサインアップすると、Amazon S3 を含む AWS のすべてのサービスに対して AWS アカウント が自動的にサインアップされます。ただし､料金が発生するのは、実際に使用したサービスの分のみです。Amazon S3 の新規のお客様は、Amazon S3 を無料で使い始めることができます。詳細については、「AWS 無料利用枠」を参照してください。\n請求を表示するには、AWS Billing and Cost Management コンソールで請求およびコスト管理ダッシュボードに移動します。AWS アカウント 請求の詳細については、AWS Billing ユーザーガイドを参照してください。AWS 請求および AWS アカウント についてご質問がある場合は、AWS Support にお問い合わせください。\nPCI DSS コンプライアンス Amazon S3 は、マーチャントまたはサービスプロバイダーによるクレジットカードデータの処理、ストレージ、および伝送をサポートしており、Payment Card Industry (PCI) Data Security Standard (DSS) に準拠していることが確認されています。PCI DSS の詳細 (AWS PCI Compliance Package のコピーをリクエストする方法など) については、「PCI DSS レベル 1」を参照してください。\n参考 https://docs.aws.amazon.com/ja_jp/AmazonS3/latest/userguide/Welcome.html\n","permalink":"https://seiri-blog.github.io/posts/amazons-s3/","summary":"Amazon S3 とは Amazon Simple Storage Service (Amazon S3) は、業界をリードするスケーラビリティ、データ可用性、セキュリティ、およびパフォーマンスを提供するオブジェクトストレージサ","title":"Amazon S3"},{"content":"Amazon DynamoDB とは Amazon DynamoDB デベロッパーガイド\nAmazon DynamoDB は、フルマネージドの NoSQL データベースサービスであり、高速で予測可能なパフォーマンスとシームレスな拡張性が特長です。DynamoDB を使用すると、ディストリビューションデータベースの運用とスケーリングに伴う管理作業をまかせることができるため、ハードウェアのプロビジョニング、設定と構成、レプリケーション、ソフトウェアパッチ適用、クラスタースケーリングなどを自分で行う必要はなくなります。また、DynamoDB も保管時の暗号化を提供し、機密データの保護における負担と複雑な作業を解消します。詳細については、「保管時の DynamoDB 暗号化」を参照してください。\nDynamoDB を使用して、任意の量のデータを保存および取得できるデータベーステーブルを作成し、任意のレベルのリクエストトラフィックを処理できます。ダウンタイムやパフォーマンスが低下することなく、テーブルのスループット容量をスケールアップまたはスケールダウンできます。AWS Management Console を使用して、リソースの使用率とパフォーマンスメトリクスをモニタリングできます。\nDynamoDB では、オンデマンドバックアップ機能を使用できます。この機能により、テーブルの完全なバックアップを作成して、規制やコンプライアンス要件を満たすために長期間の保存とアーカイブを行うことができます。詳細については、「DynamoDB のオンデマンドバックアップおよび復元の使用」を参照してください。\nオンデマンドバックアップを作成し、Amazon DynamoDB テーブルのポイントインタイムリカバリを有効にすることもできます。ポイントインタイムリカバリを使用することで、オペレーションによってテーブルが誤って上書きされたり削除されたりしないようにできます。ポイントインタイムリカバリを使用すれば、過去 35 日間の任意の時点にテーブルを復元することができます。詳細については、「ポイントインタイムリカバリ: 仕組み」を参照してください。\nDynamoDB では、テーブルから有効期限切れの項目を自動的に削除できるため、ストレージの使用量と、関連性がなくなったデータの保存コストを削減できます。詳細については、「DynamoDB の有効期限 (TTL) を使用して項目を有効期限切れにする」を参照してください。\n高い可用性と耐久性 DynamoDB では、一貫性のある高速パフォーマンスを維持しながら、スループットとストレージの要件を処理できるように、テーブルのデータとトラフィックが十分な数のサーバーに自動的に分散されます。また、すべてのデータをソリッドステートディスク (SSD) に保存し、AWS リージョン内の複数のアベイラビリティーゾーン間で自動的にレプリケートするため、組み込みの高い可用性とデータ堅牢性が実現します。グローバルテーブルを使用して、DynamoDB テーブルを AWS リージョン間で同期させることができます。詳細については、「グローバルテーブル – DynamoDB の複数リージョンレプリケーション」を参照してください。\nDynamoDB の使用開始 最初に以下のセクションを読むことをお勧めします。\n  Amazon DynamoDB: 仕組み — DynamoDB の基本的な概念について説明します。\n  DynamoDB のセットアップ — DynamoDB (ダウンロード可能なバージョンまたはウェブサービス) のセットアップ方法を説明します。\n  DynamoDB にアクセスする — コンソール、AWS CLI、API を使用して DynamoDB にアクセスする方法を説明します。\n  DynamoDB の使用をすばやく開始するには、DynamoDB および AWS SDK の開始方法 を参照してください。\nアプリケーション開発の詳細については、以下を参照してください。\n  DynamoDB と AWS SDK を使用したプログラミング\n  テーブル、項目、クエリ、スキャン、およびインデックスの使用\n  パフォーマンスを最大にしてスループットコストを最小にするための推奨事項をすばやく確認するには、「DynamoDB を使用した設計とアーキテクチャの設計に関するベストプラクティス」を参照してください。DynamoDB リソースにタグを付ける方法については、「リソースへのタグとラベルの追加」を参照してください。\nベストプラクティス、ハウツーガイド、およびツールについては、Amazon DynamoDB のリソースを参照してください。\nAWS Database Migration Service (AWS DMS) を使用して、リレーショナルデータベースまたは MongoDB から DynamoDB テーブルにデータを移行できます。詳細については、AWS Database Migration Service ユーザーガイドを参照してください。\nMongoDB を移行ソースとして使用する方法については、MongoDB を AWS Database Migration Service のソースとして使用するを参照してください。DynamoDB を移行ターゲットとして使用する方法については、Amazon DynamoDB データベースを AWS Database Migration Service のターゲットとして使用するを参照してください。\n参考 https://docs.aws.amazon.com/ja_jp/amazondynamodb/latest/developerguide/Introduction.html\n","permalink":"https://seiri-blog.github.io/posts/aws-dynamodb/","summary":"Amazon DynamoDB とは Amazon DynamoDB デベロッパーガイド Amazon DynamoDB は、フルマネージドの NoSQL データベースサービスであり、高速で予測可能なパフォーマンスとシームレスな拡張性が特長","title":"AWS DynamoDB"},{"content":"Apex 選択リスト取得方法説明 Apex を使用して Salesforce 内の選択リストから値を取得する方法は以下の通りです。\n 最初に、選択リストが定義されているオブジェクトのフィールド情報を取得するために、「Schema.DescribeFieldResult」クラスを使用します。このクラスには、選択リストに関する情報が含まれています。  Schema.DescribeFieldResult fieldResult = Account.Industry.getDescribe(); 次に、「Schema.PicklistEntry」クラスを使用して、選択リストから取得したいエントリを取得します。「Schema.PicklistEntry」クラスには、選択リストの中のすべてのエントリに関する情報が含まれています。  List\u0026lt;Schema.PicklistEntry\u0026gt; picklistEntries = fieldResult.getPicklistValues(); 最後に、取得したエントリを使用して、選択リストの中から選択された値を取得することができます。  for (Schema.PicklistEntry picklistEntry : picklistEntries) { System.debug(picklistEntry.getLabel()); } では下記具体的な例を参照してください。\n実装方法 /** * 選択リストの項目値を取得 * @param {String} sObjectName オブジェクト名 * @param {String} sFieldName 項目名 * @return 選択リスト */ @AuraEnabled public static List\u0026lt;Map\u0026lt;String, object\u0026gt;\u0026gt; getPicklist(String sObjectName, String sFieldName){ try { List\u0026lt;Map\u0026lt;String, object\u0026gt;\u0026gt; pickLists = new List\u0026lt;Map\u0026lt;String, object\u0026gt;\u0026gt;(); Map\u0026lt;String, Schema.SObjectType\u0026gt; sObjectDescribeMap = Schema.getGlobalDescribe(); if (sObjectDescribeMap.containsKey(sObjectName)) { Map\u0026lt;String, Schema.SobjectField\u0026gt; sObjectFieldsMap = sObjectDescribeMap.get(sObjectName).getDescribe().fields.getMap(); if (sObjectFieldsMap.containsKey(sFieldName)) { Schema.DescribeFieldResult sObjectFieldDescribe = sObjectFieldsMap.get(sFieldName).getDescribe(); List\u0026lt;Schema.PicklistEntry\u0026gt; lPickEntryList = sObjectFieldDescribe.getPicklistValues(); for (Schema.PicklistEntry tPicklistEntry : lPickEntryList) { pickLists.add(new Map\u0026lt;String,object\u0026gt; { \u0026#39;value\u0026#39; =\u0026gt; tPicklistEntry.getValue(), \u0026#39;isActive\u0026#39; =\u0026gt; tPicklistEntry.isActive(), \u0026#39;isDefaultValue\u0026#39; =\u0026gt; tPicklistEntry.isDefaultValue(), \u0026#39;label\u0026#39; =\u0026gt; tPicklistEntry.getLabel() }); } } } return pickLists; } catch (Exception e) { throw new AuraHandledException(e.getMessage()); } } ","permalink":"https://seiri-blog.github.io/posts/salesforce-apex-get-picklist-value/","summary":"Apex 選択リスト取得方法説明 Apex を使用して Salesforce 内の選択リストから値を取得する方法は以下の通りです。 最初に、選択リストが定義されているオブジェクトのフ","title":"【Salesforce】Apexで選択リスト取得方法"},{"content":"目的 LWC のlightning-quick-action-panelモーダル画面の幅を調整できないため、\n今回 Aura と LWC でのアクションボタンが表示したモーダル画面の高さと幅を調整できる方法を共有します。\n（※ExC 側も適用）\n実装  Aura コンポーネント\n  AuraActionCont(基底 Aura コンポーネント)\n\u0026lt;aura:component implements=\u0026quot;force:lightningQuickActionWithoutHeader,force:hasRecordId,force:hasSObjectName\u0026quot; access=\u0026quot;global\u0026quot; extensible=\u0026quot;true\u0026quot;\u0026gt; \u0026lt;aura:html tag=\u0026quot;style\u0026quot;\u0026gt; \u0026lt;!-- アクションモダール --\u0026gt; .slds-modal__container { margin: 0 auto !important; width: 70% !important; max-width: 75rem !important; min-width: 40rem !important; } .slds-p-around--medium { padding: 0 !important; height: fit-content !important; min-height: none !important; max-height: none !important; } .cuf-content { padding: 0 !important; } \u0026lt;/aura:html\u0026gt; \u0026lt;!-- LWCコンポーネント名 --\u0026gt; \u0026lt;aura:attribute name=\u0026quot;lwcName\u0026quot; type=\u0026quot;String\u0026quot; default=\u0026quot;\u0026quot; /\u0026gt; \u0026lt;!-- ロード中 --\u0026gt; \u0026lt;aura:attribute name=\u0026quot;isLoading\u0026quot; type=\u0026quot;Boolean\u0026quot; default=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;!-- 初期化 --\u0026gt; \u0026lt;aura:handler name=\u0026quot;init\u0026quot; value=\u0026quot;{!this}\u0026quot; action=\u0026quot;{!c.onInit}\u0026quot; /\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- LWC差し込む場所 --\u0026gt; {!v.body} \u0026lt;aura:if isTrue=\u0026quot;{!v.isLoading}\u0026quot;\u0026gt; \u0026lt;lightning:spinner alternativeText=\u0026quot;Loading...\u0026quot; /\u0026gt; \u0026lt;/aura:if\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/aura:component\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;AuraDefinitionBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;54.0\u0026lt;/apiVersion\u0026gt; \u0026lt;description\u0026gt;A Lightning Component Bundle\u0026lt;/description\u0026gt; \u0026lt;/AuraDefinitionBundle\u0026gt; .THIS { position: relative; } .THIS .slds-spinner { position: sticky; } ({ /** * 初期化 * @param {*} component コンポーネント * @param {*} event イベント * @param {*} helper ヘルパー */ onInit: function (component, event, helper) { helper.init(component, event); }, /** * Auraイベント * @param {*} component コンポーネント * @param {*} event イベント * @param {*} helper ヘルパー */ onAuraEvent: function (component, event, helper) { helper.fireAuraEvent(event.getParam(\u0026#34;name\u0026#34;), event.getParam(\u0026#34;params\u0026#34;)); }, /** * ロードフラグ設定 * @param {*} component コンポーネント * @param {*} event イベント * @param {*} helper ヘルパー */ onSetLoading: function (component, event, helper) { helper.setLoading(component, event.getParam(\u0026#34;isLoading\u0026#34;)); }, /** * QuickActionを閉じる */ closeAction: function () { $A.get(\u0026#34;e.force:closeQuickAction\u0026#34;).fire(); } }); ({ /** * 初期化 * @param {*} component */ init: function(component) { var lwcName = component.get(\u0026#39;v.lwcName\u0026#39;); this.createComponent(component, lwcName); }, /** * LWCコンポーネント作成 * @param {*} component * @param {*} lwcName LWCコンポーネント名 */ createComponent: function(component, lwcName) { const recordId = component.get(\u0026#34;v.recordId\u0026#34;); const sObjectName = component.get(\u0026#34;v.sObjectName\u0026#34;); $A.createComponent( `c:${lwcName}`, { recordId: recordId, sObjectName: sObjectName, onauraevent: component.getReference(\u0026#34;c.onAuraEvent\u0026#34;), onsetloading: component.getReference(\u0026#34;c.onSetLoading\u0026#34;) }, (lwcCmp, status, errorMessage) =\u0026gt; { if (status === \u0026#34;SUCCESS\u0026#34;) { const body = component.get(\u0026#34;v.body\u0026#34;); body.push(lwcCmp); component.set(\u0026#34;v.body\u0026#34;, body); } else { this.displayError( `The \u0026#39;${lwcName}\u0026#39; can\u0026#39;t be find. Check if it\u0026#39;s exposed. More details in DevTools.`, errorMessage ); $A.enqueueAction(component.get(\u0026#34;c.closeAction\u0026#34;)); } } ); }, /** * Auraイベント * @param {*} name イベント名 * @param {*} params パラメータ */ fireAuraEvent: function(name, params) { const event = $A.get(name); if (params) event.setParams(params); event.fire(); }, /** * ロードフラグ設定 * @param {*} component * @param {*} loading ロードフラグ */ setLoading: function(component, loading) { component.set(\u0026#34;v.isLoading\u0026#34;, loading); }, /** * Toastエラーメッセージ表示 * @param {*} message メッセージ * @param {*} errorMessage エラーメッセージ */ displayError: function(message, errorMessage) { console.error(\u0026#34;Error: \u0026#34;, errorMessage); this.showToast(message, \u0026#34;error\u0026#34;); }, /** * Toastメッセージ表示 * @param {*} message メッセージ * @param {*} type タイプ */ showToast: function(message, type) { const toast = $A.get(\u0026#34;e.force:showToast\u0026#34;); toast.setParams({ message: message, type: type }); toast.fire(); } }); DeleteCont(LWC の容器)\n\u0026lt;!-- 基底AuraActionContを継承する --\u0026gt; \u0026lt;aura:component extends=\u0026quot;c:AuraActionCont\u0026quot;\u0026gt; \u0026lt;aura:html tag=\u0026quot;style\u0026quot;\u0026gt; \u0026lt;!-- アクションモダール --\u0026gt; .slds-modal__container { margin: 0 auto !important; width: 50% !important; max-width: 75rem !important; min-width: 40rem !important; } .slds-p-around--medium { padding: 0 !important; height: fit-content !important; min-height: none !important; max-height: none !important; } .cuf-content { padding: 0 !important; } \u0026lt;/aura:html\u0026gt; \u0026lt;!-- LWCのコンポーネント名を指定する --\u0026gt; \u0026lt;aura:attribute name=\u0026quot;lwcName\u0026quot; type=\u0026quot;String\u0026quot; default=\u0026quot;deleteButton\u0026quot; /\u0026gt; \u0026lt;/aura:component\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;AuraDefinitionBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;54.0\u0026lt;/apiVersion\u0026gt; \u0026lt;description\u0026gt;A Lightning Component Bundle\u0026lt;/description\u0026gt; \u0026lt;/AuraDefinitionBundle\u0026gt;  LWC コンポーネント\nlwcAction（基底コンポーネント）\n  import { LightningElement, api } from \u0026#34;lwc\u0026#34;; export default class LwcAction extends LightningElement { //レコードId  @api recordId; //オブジェクト名  @api sObjectName; //準備完了フラグ  isReady = false; /** * ロード完了 */ ready() { this.hideSpinner(); this.isReady = true; } /** * QuickActionを閉じる */ closeAction() { this.dispatchEvent(LwcAction.getCloseQuickAction()); } /** * 画面リフレッシュ */ refreshView() { this.dispatchEvent(LwcAction.getRefreshView()); } /** * ロード表示 */ showSpinner() { this.dispatchEvent(LwcAction.getSpinnerEvent(true)); } /** * ロール非表示 */ hideSpinner() { this.dispatchEvent(LwcAction.getSpinnerEvent(false)); } /** * Auraイベント * @param {*} name イベント名 * @param {*} params パラメータ */ fireAuraEvent(name, params) { this.dispatchEvent(LwcAction.getAuraEvent(name, params)); } /** * 静的メソッド * QuickActionを閉じる * @param {*} element */ static fireCloseAction(element) { element.dispatchEvent(LwcAction.getCloseQuickAction()); } /** * 静的メソッド * 画面リフレッシュ * @param {*} element */ static fireRefreshView(element) { element.dispatchEvent(LwcAction.getRefreshView()); } /** * 静的メソッド * ロード表示 * @param {*} element */ static fireShowSpinner(element) { element.dispatchEvent(LwcAction.getSpinnerEvent(true)); } /** * 静的メソッド * ロード非表示 * @param {*} element */ static fireHideSpinner(element) { element.dispatchEvent(LwcAction.getSpinnerEvent(false)); } /** * 静的メソッド * Auraイベント * @param {*} element * @param {*} name * @param {*} params */ static fireAuraEvent(element, name, params) { element.dispatchEvent(LwcAction.getAuraEvent(name, params)); } /** * 静的メソッド * ロード制御 * @param {*} isLoading * @returns */ static getSpinnerEvent(isLoading) { return new CustomEvent(\u0026#34;setloading\u0026#34;, { detail: { isLoading: isLoading }, composed: true, bubbles: true, }); } /** * QuickActionを閉じる */ static getCloseQuickAction() { return LwcAction.getAuraEvent(\u0026#34;e.force:closeQuickAction\u0026#34;); } /** * 静的メソッド * 画面リフレッシュ */ static getRefreshView() { return LwcAction.getAuraEvent(\u0026#34;e.force:refreshView\u0026#34;); } /** * Auraイベント * @param {*} name 名 * @param {*} params パラメータ * @returns */ static getAuraEvent(name, params) { return new CustomEvent(\u0026#34;auraevent\u0026#34;, { detail: { name: name, params: params }, composed: true, bubbles: true, }); } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;54.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;true\u0026lt;/isExposed\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt; deleteButton\n\n\u0026lt;template\u0026gt; \u0026lt;lightning-quick-action-panel header=\u0026#34;メッセージ\u0026#34;\u0026gt; メッセージ \u0026lt;div slot=\u0026#34;footer\u0026#34;\u0026gt; \u0026lt;lightning-button variant=\u0026#34;neutral\u0026#34; label=\u0026#34;いいえ\u0026#34; onclick={cancel}\u0026gt;\u0026lt;/lightning-button\u0026gt; \u0026lt;lightning-button variant=\u0026#34;brand\u0026#34; label=\u0026#34;はい\u0026#34; class=\u0026#34;slds-m-left_x-small\u0026#34; onclick={confirm}\u0026gt; \u0026lt;/lightning-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/lightning-quick-action-panel\u0026gt; \u0026lt;/template\u0026gt; import LwcAction from \u0026#34;c/lwcAction\u0026#34;; export default class DeleteButton extends LwcAction { /** * 「はい」 */ async confirm(e) { try { //はいの処理TODO  } catch (error) { console.error(error); } finally { this.closeAction(); } } /** * 「いええ」 */ cancel(e) { e.preventDefault(); this.closeAction(); } /** * 初期化処理 */ connectedCallback() { this.ready(); } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;54.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;false\u0026lt;/isExposed\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt; アクションボタン作成 該当オブジェクトのボタン、リンク、およびアクションを選択\n\n新規アクションを押下\n\nアクション種別をLightningコンポーネントを選択し、Lightning コンポーネントをc:DeleteContを選択し、表示ラベルと名前を入力してから、保存ボタン押下\n\nページレイアウトの設定 該当オブジェクトのケース ページレイアウトを選択\n\nモバイルおよび Lighting のアクションを選択し、削除（カスタム）をドラグ\u0026amp;ドロップで、Salesforce モバイルおよび Lightning Experience のアクションに設定して保存\n\n\n動作確認 詳細画面でアクションボタンを確認\n\nアクションボタンを押下\n\n参考 https://help.salesforce.com/s/articleView?id=sf.lightning_web_component_actions_create.htm\u0026amp;type=5\nhttps://github.com/andrii-solokh/LWCAction\nその他 https://knowstechnic.blogspot.com/2022/12/salesforce.html\n","permalink":"https://seiri-blog.github.io/posts/salesforce-action-button/","summary":"目的 LWC のlightning-quick-action-panelモーダル画面の幅を調整できないため、 今回 Aura と LWC でのアクションボタンが表示した","title":"【Salesforce】アクションボタン"},{"content":"目的 CRUD および項目レベルセキュリティ (FLS) 権限チェック Util を作成方法を共有します\nソース public with sharing class FLSUtil { //環境の接頭辞  private static final String ENV_PREFIX = getPrefix(); //アンダーバーC  private static final String UNDERBAR_C = \u0026#39;__c\u0026#39;; /** * FLSチェックタイプ */ public enum FLSType { //登録  INSERT_OBJECT, //削除  DELETE_OBJECT, //更新  UPDATE_OBJECT, //検索  SELECT_OBJECT } /** * 共通チェックFLS(項目) * @param objectName オブジェクト名 * @param fieldList チェック項目リスト * @param type チェックタイプ */ public static Boolean commmonCheckFLS(String objectName, List\u0026lt;String\u0026gt; fieldList, FLSType type) { objectName = objectName.contains(UNDERBAR_C) ? ENV_PREFIX + objectName : objectName; SObjectType objType = Schema.getGlobalDescribe().get(objectName); Map\u0026lt;String,Schema.SObjectField\u0026gt; m = objType.getDescribe().fields.getMap(); if(type == FLSType.INSERT_OBJECT) {//登録権限  for(String field : fieldList) { if(field.contains(UNDERBAR_C)) { //カスタム項目  if(!m.get(ENV_PREFIX + field).getDescribe().isCreateable()) { return false; } } else { //標準項目  if(!m.get(field).getDescribe().isCreateable()) { return false; } } } } else if(type == FLSType.UPDATE_OBJECT) {//更新権限  for(String field : fieldList) { if(field.contains(UNDERBAR_C)) { //カスタム項目  if(!m.get(ENV_PREFIX + field).getDescribe().isUpdateable()) { return false; } } else { //標準項目  if(!m.get(field).getDescribe().isUpdateable()) { return false; } } } } else if(type == FLSType.SELECT_OBJECT){//検索権限  for(String field : fieldList) { if(field.contains(UNDERBAR_C)) { //カスタム項目  if(!m.get(ENV_PREFIX + field).getDescribe().isUpdateable()) { return false; } } else { //標準項目  if(!m.get(field).getDescribe().isUpdateable()) { return false; } } } } else if(type == FLSType.DELETE_OBJECT) {//削除権限  if(!objType.getDescribe().isDeletable()) { return false; } } return true; } /** * 共通チェックFLS(オブジェクト) * @param objectName オブジェクト名 * @param type チェックタイプ */ public static Boolean commmonCheckFLS(String objectName, FLSType type) { objectName = objectName.contains(UNDERBAR_C) ? ENV_PREFIX + objectName : objectName; SObjectType objType = Schema.getGlobalDescribe().get(objectName); if(type == FLSType.INSERT_OBJECT) { //登録権限  if(!objType.getDescribe().isCreateable()) { return false; } } else if(type == FLSType.DELETE_OBJECT) {//削除権限  if(!objType.getDescribe().isDeletable()) { return false; } } else if(type == FLSType.UPDATE_OBJECT) {//更新権限  if(!objType.getDescribe().isUpdateable()) { return false; } } else if(type == FLSType.SELECT_OBJECT) {//検索権限  if(!objType.getDescribe().isAccessible()) { return false; } } return true; } /** * 接頭辞取得 */ public static String getPrefix(){ ApexClass ac =[SELECT NamespacePrefix FROM ApexClass WHERE Name =: FLSUtil.class.getName()]; String nameSpacePrefix = ac.NamespacePrefix; if(String.isEmpty(nameSpacePrefix)) { nameSpacePrefix = \u0026#39;\u0026#39;; } else { nameSpacePrefix += \u0026#39;__\u0026#39;; } return nameSpacePrefix; } } 参考 https://developer.salesforce.com/docs/atlas.ja-jp.lightning.meta/lightning/apex_crud_fls.htm\nhttps://gist.github.com/zaki-yama/8df241545cd95641a538\n","permalink":"https://seiri-blog.github.io/posts/salesforce-fls-authority-check/","summary":"目的 CRUD および項目レベルセキュリティ (FLS) 権限チェック Util を作成方法を共有します ソース public with sharing class FLSUtil { //環境の接頭辞 private static final String ENV_PREFIX = getPrefix(); //アンダーバーC private","title":"【Salesforce】FLS権限チェック"},{"content":"プラットフォームイベントの役割  プラットフォームイベントを使用し、リアルタイムイベントデータのやり取りによって、Salesforce のビジネスプロセスと外部アプリケーションを接続します。プラットフォームイベントは、データを含む安全で拡張性があるメッセージです。パブリッシャーは、サブスクライバーがリアルタイムで受信するイベントメッセージを公開します。公開されたデータをカスタマイズするには、プラットフォームイベント項目を定義します。\n 一般的なプラットフォームイベントの割り当て\n    説明 Performance Edition および Unlimited Edition Enterprise Edition Developer Edition Professional Edition (API アドオンあり)     1 つの組織で作成できるプラットフォームイベント定義の最大数 100 50 5 5   すべてのチャネルおよびすべてのイベント種別での、同時 CometD クライアント (サブスクライバー) の最大数 2,000 1,000 20 20   プラットフォームイベントを登録できるプロセスの最大数 4,000 4,000 4,000 5   プラットフォームイベントを登録できる有効なプロセスの最大数 2,000 2,000 2,000 5   作成可能なカスタムチャネルの最大数 100 100 100 100   チャネルにチャネルメンバーとして追加できる個別のプラットフォームイベントの最大数同じプラットフォームイベントを複数のチャネルに追加する場合、割り当てごとに 1 回カウントされます。 50 50 5 5     プラットフォームイベントの作成 \n\nプラットフォームイベントの公開  フローによるイベントメッセージの公開\nフローを使用して、ユーザ操作、自動化プロセス、Apex、またはワークフローアクションの一環としてイベントメッセージを Salesforce アプリケーションから公開します。\n\n\n  Apex によるイベントメッセージの公開  Apex を使用して、イベントメッセージを Salesforce アプリケーションから公開します。\nイベントメッセージを公開するには、EventBus.publish メソッドをコールします。  List\u0026lt;Test__e\u0026gt; listTest = new List\u0026lt;Test__e\u0026gt;(); listTest.add(new Test__e(test__c=\u0026#39;メッセージ\u0026#39;); // プラットフォームイベント公開 List\u0026lt;Database.SaveResult\u0026gt; results = EventBus.publish(listTest); // 公開結果取得 for (Database.SaveResult sr : results) { if (sr.isSuccess()) { System.debug(\u0026#39;Successfully published event.\u0026#39;); } else { for(Database.Error err : sr.getErrors()) { System.debug(\u0026#39;Error returned: \u0026#39; + err.getStatusCode() + \u0026#39; - \u0026#39; + err.getMessage()); } } } バッチサイズ設定方法   PlatformEventSubscriberConfig\n   項目名 項目の型 説明     batchSize int プラットフォームイベント Apex トリガのカスタムバッチサイズ (1 ～ 2,000)。バッチサイズは 1 回の実行でトリガに送信できるイベントメッセージの最大数に対応します。デフォルトのバッチサイズはプラントイベントトリガで 2,000 です。一度に 1 つのイベントを処理するために、バッチサイズを 1 に設定することはお勧めしません。バッチサイズが小さいと、イベントメッセージの処理速度が遅くなることがあります。   isProtected boolean (継承された項目)。このコンポーネントが保護されるか (true)、否か (false) を示します。保護コンポーネントは、登録者の組織で作成されたコンポーネントからリンク付けしたり参照したりすることはできません。開発者は、今後のリリースで、インストールの失敗を心配することなく保護コンポーネントを削除できます。ただし、コンポーネントが非保護に設定され、グローバルにリリースされると、開発者は削除できなくなります。   masterLabel string 必須。PlatformEventSubscriberConfig コンポーネントの表示ラベル。   platformEventConsumer string 必須。設定するプラットフォームイベント Apex トリガの完全名。   user string プラットフォームイベント Apex トリガを実行するユーザのユーザ名。デフォルトでは、プラットフォームイベントトリガは自動化プロセスエンティティとして実行されます。実行ユーザを特定のユーザに設定することには、次のような利点があります。・レコードがこのユーザとして作成または変更される。・OwnerId 項目があるレコードが作成または変更されたときに、OwnerId 項目にこのユーザが入力される。・このユーザによってトリガ実行のデバッグログが作成される。・デフォルトの自動化プロセスユーザではサポートされないメールをトリガから送信できる。      PlatformEventSubscriberConfigs フォルダにバッチサイズの設定ファイルを追加\n  フォルダ階層\n├─force-app │ └─main │ └─default │ └─PlatformEventSubscriberConfigs │ トリガConfig.platformEventSubscriberConfig-meta.xml　⇐　設定ファイル \n設定ファイルの中身\n\n参考 プラットフォームイベント開発者ガイド\nプラットフォームイベントの公開\nプラットフォームイベントの登録\nPlatformEventSubscriberConfig\n最後 プラットフォームイベントバッチサイズの設定は有効まで時間がかかります（約３時間かかります）\n\n","permalink":"https://seiri-blog.github.io/posts/salesforce-platform-event-description-and-usage/","summary":"プラットフォームイベントの役割 プラットフォームイベントを使用し、リアルタイムイベントデータのやり取りによって、Salesforce のビジネス","title":"【Salesforce】プラットフォームイベント説明と利用方法"},{"content":"データローダとは  データローダは、データを一括でインポートまたはエクスポートするためのクライアントアプリケーションです。Salesforce レコードの挿入、更新、削除、またはエクスポートに使用できます。\nデータのインポート時には、カンマ区切り値 (CSV) ファイルまたはデータベース接続からデータローダの参照、抽出、および読み込みを実行できます。データのエクスポート時には、CSV ファイルが出力されます。\n  データローダは、次の 2 通りの方法で使用できます。\n・ユーザインターフェース — ユーザインターフェースを使用する場合、対話形式で作業して、設定パラメータ、インポートとエクスポートに使用する CSV ファイル、インポートファイルの項目名と Salesforce の項目名を対応付ける項目の対応付けを指定します。\n・コマンドライン (Windows のみ) — コマンドラインを使用する場合は、ファイルの設定、データソース、対応付け、アクションを指定します。これにより、自動処理のためにデータローダを設定できます。\n  データローダには、次の主な特長があります。\n・対話形式で使用するための使いやすいウィザードを持つインターフェース\n・自動バッチ操作のための代替コマンドラインインターフェース (Windows のみ)\n・5 百万レコードまでの大規模ファイルにも対応\n・ドラッグアンドドロップによる項目の関連付け\n・カスタムオブジェクトを含む全オブジェクトのサポート\n・Salesforce および Database.com の両方でのデータ処理に使用できる\n・CSV ファイル形式での詳細な成功またはエラーログ\n・組込み型 CSV ファイル参照アプリケーション\n・Windows および Mac のサポート\n データローダバッチ作成方法 今回はデータローダエクスポート用のバッチ作成方法を説明します。\n具体的なやり方は下記を参照してください。\n環境 OS : Windows10 Java Zulu OpenJDK バージョン 18 ⇒ https://www.azul.com/downloads/?os=windows DataLoder 54.0.0バージョン ⇒ https://github.com/forcedotcom/dataloader パスワード暗号化  暗号鍵生成  java -cp dataloader-54.0.0-uber.jar com.salesforce.dataloader.security.EncryptionUtil -k ./conf/dataloader.key  暗号鍵を使用して、パスワードを暗号化する  java -cp dataloader-54.0.0-uber.jar com.salesforce.dataloader.security.EncryptionUtil -e パスワード .conf/dataloader.key データローダバッチの構成 ├─start.bat ⇒　実行ファイル(手動実行可能) │─dataloader-54.0.0-uber.jar ⇒　データローダJAR ├─conf │ map.sdl ⇒　オブジェクトのマッピングファイル │ config.properties ⇒　データローダ全体的な設定ファイル │ dataloader.key ⇒　暗号鍵 │ log-conf.xml ⇒　ログ出力用の設定ファイル │ process-conf.xml ⇒　データローダの設定ファイル（必須ファイル） │ setting.properties ⇒　データローダ環境設定用ファイル │ ├─data ⇒　取り込み対象ファイル格納フォルダ ├─log ⇒　エラーログフォルダ ├─status ⇒　処理結果フォルダ start.bat(実行ファイル)\n@echo off rem if \u0026#34;%1\u0026#34;==\u0026#34;hide\u0026#34; goto CmdBegin start mshta vbscript:createobject(\u0026#34;wscript.shell\u0026#34;).run(\u0026#34;\u0026#34;\u0026#34;%~0\u0026#34;\u0026#34; hide\u0026#34;,0)(window.close)\u0026amp;\u0026amp;exit :CmdBegin set DATALOADER_PATH=データローダパス　⇒　実際のパス set DATALOADER_CONF_PATH=%DATALOADER_PATH%/conf cd %DATALOADER_PATH% java -Dfile.encoding=MS932 -jar dataloader-54.0.0-uber.jar run.mode=batch salesforce.config.dir=./conf process.name=プロセスID　⇒　BeanのId exit 0 map.sdl\n# マップイングファイル Id=ID Name=Name ... config.properties\n# 中身は空です log-conf.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;Configuration status=\u0026#34;info\u0026#34; name=\u0026#34;MyApp\u0026#34; packages=\u0026#34;\u0026#34;\u0026gt; \u0026lt;Appenders\u0026gt; \u0026lt;RollingFile name=\u0026#34;RollingFile\u0026#34; filePattern=\u0026#34;./log/dataloader_%d{yyyy-MM-dd_HHmmss}.log.gz\u0026#34;\u0026gt; \u0026lt;PatternLayout\u0026gt; \u0026lt;Pattern\u0026gt;%-5p %d [%t] - %m%n\u0026lt;/Pattern\u0026gt; \u0026lt;/PatternLayout\u0026gt; \u0026lt;Policies\u0026gt; \u0026lt;CronTriggeringPolicy schedule=\u0026#34;0 0 * * * ?\u0026#34;/\u0026gt; \u0026lt;SizeBasedTriggeringPolicy size=\u0026#34;250 MB\u0026#34;/\u0026gt; \u0026lt;/Policies\u0026gt; \u0026lt;/RollingFile\u0026gt; \u0026lt;/Appenders\u0026gt; \u0026lt;Loggers\u0026gt; \u0026lt;Root level=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;AppenderRef ref=\u0026#34;RollingFile\u0026#34;/\u0026gt; \u0026lt;/Root\u0026gt; \u0026lt;/Loggers\u0026gt; \u0026lt;/Configuration\u0026gt; process-conf.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE beans PUBLIC \u0026#34;-//SPRING//DTD BEAN//EN\u0026#34; \u0026#34;http://www.springframework.org/dtd/spring-beans.dtd\u0026#34;\u0026gt; \u0026lt;beans\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.context.support.PropertySourcesPlaceholderConfigurer\u0026#34;\u0026gt; \u0026lt;!-- 設定Propertyをインポートする --\u0026gt; \u0026lt;property name=\u0026#34;locations\u0026#34; value=\u0026#34;file:./conf/setting.properties\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;BeanのId\u0026#34; name=\u0026#34;name\u0026#34; class=\u0026#34;com.salesforce.dataloader.process.ProcessRunner\u0026#34;\u0026gt; \u0026lt;description\u0026gt;説明\u0026lt;/description\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;値\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;configOverrideMap\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;sfdc.endpoint\u0026#34; value=\u0026#34;${sfdc.endpoint}\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;sfdc.username\u0026#34; value=\u0026#34;${sfdc.username}\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;sfdc.password\u0026#34; value=\u0026#34;${sfdc.password}\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;process.encryptionKeyFile\u0026#34; value=\u0026#34;${batch.path}/conf/dataloader.key\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;sfdc.timeoutSecs\u0026#34; value=\u0026#34;${timeoutSecs}\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;sfdc.entity\u0026#34; value=\u0026#34;オブジェクト\u0026#34;/\u0026gt; \u0026lt;!--ここはSOQL--\u0026gt; \u0026lt;entry key=\u0026#34;sfdc.extractionSOQL\u0026#34; value=\u0026#34;SELECT Id, Name, ．．． FROM オブジェクト \u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;process.enableLastRunOutput\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;process.operation\u0026#34; value=\u0026#34;extract\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;process.mappingFile\u0026#34; value=\u0026#34;${batch.path}/conf/map.sdl\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;dataAccess.name\u0026#34; value=\u0026#34;${batch.path}/data/resultData.csv\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;dataAccess.type\u0026#34; value=\u0026#34;csvWrite\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;loader.csvTab\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;loader.csvComma\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;dataAccess.readUTF8\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;dataAccess.writeUTF8\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;process.initialLastRunDate\u0026#34; value=\u0026#34;2006-12-01T00:00:00.000-0800\u0026#34;/\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; ・・・ \u0026lt;/beans\u0026gt; setting.properties\n# Loader Config sfdc.endpoint=Salesforceエンドポイント sfdc.username=ユーザ名 sfdc.password=暗号化のパスワード batch.path=データローダバッチパス　⇒　実際のパス timeoutSecs=600 Windows タスクスケジューラを作成 下記手順で Window タスクスケジューラを作成を作成します。\n\n\n\n\n\n\n関連記事  【Salesforce】データローダバッチ作成方法（インポート）  ","permalink":"https://seiri-blog.github.io/posts/salesforce-data-loader-batch-export-edition/","summary":"データローダとは データローダは、データを一括でインポートまたはエクスポートするためのクライアントアプリケーションです。Salesforce レ","title":"【Salesforce】データローダバッチ（エクスポート編）"},{"content":"データローダとは  データローダは、データを一括でインポートまたはエクスポートするためのクライアントアプリケーションです。Salesforce レコードの挿入、更新、削除、またはエクスポートに使用できます。\nデータのインポート時には、カンマ区切り値 (CSV) ファイルまたはデータベース接続からデータローダの参照、抽出、および読み込みを実行できます。データのエクスポート時には、CSV ファイルが出力されます。\n  データローダは、次の 2 通りの方法で使用できます。\n・ユーザインターフェース — ユーザインターフェースを使用する場合、対話形式で作業して、設定パラメータ、インポートとエクスポートに使用する CSV ファイル、インポートファイルの項目名と Salesforce の項目名を対応付ける項目の対応付けを指定します。\n・コマンドライン (Windows のみ) — コマンドラインを使用する場合は、ファイルの設定、データソース、対応付け、アクションを指定します。これにより、自動処理のためにデータローダを設定できます。\n  データローダには、次の主な特長があります。\n・対話形式で使用するための使いやすいウィザードを持つインターフェース\n・自動バッチ操作のための代替コマンドラインインターフェース (Windows のみ)\n・5 百万レコードまでの大規模ファイルにも対応\n・ドラッグアンドドロップによる項目の関連付け\n・カスタムオブジェクトを含む全オブジェクトのサポート\n・Salesforce および Database.com の両方でのデータ処理に使用できる\n・CSV ファイル形式での詳細な成功またはエラーログ\n・組込み型 CSV ファイル参照アプリケーション\n・Windows および Mac のサポート\n データローダバッチ作成方法 今回はデータローダインポート用のバッチ作成方法を説明します。\n具体的なやり方は下記を参照してください。\n環境 OS : Windows10 Java Zulu OpenJDK バージョン 18 ⇒ https://www.azul.com/downloads/?os=windows DataLoder 54.0.0バージョン ⇒ https://github.com/forcedotcom/dataloader パスワード暗号化  暗号鍵生成  java -cp dataloader-54.0.0-uber.jar com.salesforce.dataloader.security.EncryptionUtil -k ./conf/dataloader.key  暗号鍵を使用して、パスワードを暗号化する  java -cp dataloader-54.0.0-uber.jar com.salesforce.dataloader.security.EncryptionUtil -e パスワード .conf/dataloader.key データローダバッチの構成 ├─start.bat ⇒　実行ファイル(手動実行可能) │─dataloader-54.0.0-uber.jar ⇒　データローダJAR ├─conf │ map.sdl ⇒　オブジェクトのマッピングファイル │ config.properties ⇒　データローダ全体的な設定ファイル │ dataloader.key ⇒　暗号鍵 │ log-conf.xml ⇒　ログ出力用の設定ファイル │ process-conf.xml ⇒　データローダの設定ファイル（必須ファイル） │ setting.properties ⇒　データローダ環境設定用ファイル │ ├─data ⇒　取り込み対象ファイル格納フォルダ ├─log ⇒　エラーログフォルダ ├─status ⇒　処理結果フォルダ start.bat(実行ファイル)\n@echo off rem if \u0026#34;%1\u0026#34;==\u0026#34;hide\u0026#34; goto CmdBegin start mshta vbscript:createobject(\u0026#34;wscript.shell\u0026#34;).run(\u0026#34;\u0026#34;\u0026#34;%~0\u0026#34;\u0026#34; hide\u0026#34;,0)(window.close)\u0026amp;\u0026amp;exit :CmdBegin set DATALOADER_PATH=データローダパス　⇒　実際のパス set DATALOADER_CONF_PATH=%DATALOADER_PATH%/conf cd %DATALOADER_PATH% java -Dfile.encoding=MS932 -jar dataloader-54.0.0-uber.jar run.mode=batch salesforce.config.dir=./conf process.name=BeanのId exit 0 map.sdl\n# マップイングファイル Id=ID Name=Name ... config.properties\n# 中身は空です log-conf.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;Configuration status=\u0026#34;info\u0026#34; name=\u0026#34;MyApp\u0026#34; packages=\u0026#34;\u0026#34;\u0026gt; \u0026lt;Appenders\u0026gt; \u0026lt;RollingFile name=\u0026#34;RollingFile\u0026#34; filePattern=\u0026#34;./log/dataloader_%d{yyyy-MM-dd_HHmmss}.log.gz\u0026#34;\u0026gt; \u0026lt;PatternLayout\u0026gt; \u0026lt;Pattern\u0026gt;%-5p %d [%t] - %m%n\u0026lt;/Pattern\u0026gt; \u0026lt;/PatternLayout\u0026gt; \u0026lt;Policies\u0026gt; \u0026lt;CronTriggeringPolicy schedule=\u0026#34;0 0 * * * ?\u0026#34;/\u0026gt; \u0026lt;SizeBasedTriggeringPolicy size=\u0026#34;250 MB\u0026#34;/\u0026gt; \u0026lt;/Policies\u0026gt; \u0026lt;/RollingFile\u0026gt; \u0026lt;/Appenders\u0026gt; \u0026lt;Loggers\u0026gt; \u0026lt;Root level=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;AppenderRef ref=\u0026#34;RollingFile\u0026#34;/\u0026gt; \u0026lt;/Root\u0026gt; \u0026lt;/Loggers\u0026gt; \u0026lt;/Configuration\u0026gt; process-conf.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE beans PUBLIC \u0026#34;-//SPRING//DTD BEAN//EN\u0026#34; \u0026#34;http://www.springframework.org/dtd/spring-beans.dtd\u0026#34;\u0026gt; \u0026lt;beans\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.context.support.PropertySourcesPlaceholderConfigurer\u0026#34;\u0026gt; \u0026lt;!-- 設定Propertyをインポートする --\u0026gt; \u0026lt;property name=\u0026#34;locations\u0026#34; value=\u0026#34;file:./conf/setting.properties\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;BeanのId\u0026#34; name=\u0026#34;name\u0026#34; class=\u0026#34;com.salesforce.dataloader.process.ProcessRunner\u0026#34;\u0026gt; \u0026lt;description\u0026gt;説明\u0026lt;/description\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;value\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;configOverrideMap\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;sfdc.endpoint\u0026#34; value=\u0026#34;${sfdc.endpoint}\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;sfdc.username\u0026#34; value=\u0026#34;${sfdc.username}\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;sfdc.password\u0026#34; value=\u0026#34;${sfdc.password}\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;process.encryptionKeyFile\u0026#34; value=\u0026#34;${batch.path}/conf/dataloader.key\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;sfdc.timeoutSecs\u0026#34; value=\u0026#34;${timeoutSecs}\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;sfdc.loadBatchSize\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;sfdc.entity\u0026#34; value=\u0026#34;カスタムオブジェクト\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;process.enableLastRunOutput\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;process.operation\u0026#34; value=\u0026#34;insert\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;process.mappingFile\u0026#34; value=\u0026#34;${batch.path}/conf/map.sdl\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;dataAccess.name\u0026#34; value=\u0026#34;${batch.path}/data/targetData.csv\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;dataAccess.type\u0026#34; value=\u0026#34;csvRead\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;loader.csvTab\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;loader.csvComma\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;dataAccess.readUTF8\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;process.initialLastRunDate\u0026#34; value=\u0026#34;2006-12-01T00:00:00.000-0800\u0026#34;/\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; ・・・ \u0026lt;/beans\u0026gt; setting.properties\n# Loader Config sfdc.endpoint=Salesforceエンドポイント sfdc.username=ユーザ名 sfdc.password=暗号化のパスワード batch.path=データローダバッチパス timeoutSecs=600 Windows タスクスケジューラを作成 下記手順で Window タスクスケジューラを作成を作成します。\n\n\n\n\n\n\n関連記事  【Salesforce】データローダバッチ作成方法（エクスポート）  ","permalink":"https://seiri-blog.github.io/posts/salesforce-data-loader-batch-import-edition/","summary":"データローダとは データローダは、データを一括でインポートまたはエクスポートするためのクライアントアプリケーションです。Salesforce レ","title":"【Salesforce】データローダバッチ（インポート編）"},{"content":"目的 LWC での Path 共通コンポーネントを共有します。\n実装例 path \npath.html\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;slds-path\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-grid slds-path__track\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-grid slds-path__scroller-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-path__scroller\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-path__scroller_inner\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;slds-path__nav\u0026#34; role=\u0026#34;listbox\u0026#34; aria-orientation=\u0026#34;horizontal\u0026#34; \u0026gt; \u0026lt;template for:each=\u0026#34;{pathItemList}\u0026#34; for:item=\u0026#34;pathItem\u0026#34; for:index=\u0026#34;index\u0026#34; \u0026gt; {getIndex} \u0026lt;template if:true=\u0026#34;{pathIndexGeCurrentIndex}\u0026#34;\u0026gt; \u0026lt;li key=\u0026#34;{pathItem}\u0026#34; if:true=\u0026#34;{pathIndexEqCurrentIndex}\u0026#34; class=\u0026#34;slds-path__item slds-is-current slds-is-active\u0026#34; role=\u0026#34;presentation\u0026#34; \u0026gt; \u0026lt;a aria-selected=\u0026#34;true\u0026#34; class=\u0026#34;slds-path__link\u0026#34; href=\u0026#34;javasctipt:void();\u0026#34; role=\u0026#34;option\u0026#34; tabindex=\u0026#34;-1\u0026#34; \u0026gt; \u0026lt;span class=\u0026#34;slds-path__stage\u0026#34;\u0026gt; \u0026lt;lightning-icon class=\u0026#34;slds-icon slds-icon_x-small\u0026#34; icon-name=\u0026#34;utility:check\u0026#34; alternative-text=\u0026#34;Stage Complete\u0026#34; variant=\u0026#34;inverse\u0026#34; size=\u0026#34;x-small\u0026#34; \u0026gt; \u0026lt;/lightning-icon\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;slds-path__title\u0026#34;\u0026gt;{pathItem}\u0026lt;/span\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li key=\u0026#34;{pathItem}\u0026#34; if:false=\u0026#34;{pathIndexEqCurrentIndex}\u0026#34; class=\u0026#34;slds-path__item slds-is-incomplete\u0026#34; role=\u0026#34;presentation\u0026#34; \u0026gt; \u0026lt;a aria-selected=\u0026#34;false\u0026#34; class=\u0026#34;slds-path__link\u0026#34; href=\u0026#34;javasctipt:void();\u0026#34; role=\u0026#34;option\u0026#34; \u0026gt; \u0026lt;span class=\u0026#34;slds-path__stage\u0026#34;\u0026gt; \u0026lt;lightning-icon class=\u0026#34;slds-icon slds-icon_x-small\u0026#34; icon-name=\u0026#34;utility:check\u0026#34; alternative-text=\u0026#34;Stage Complete\u0026#34; variant=\u0026#34;inverse\u0026#34; size=\u0026#34;x-small\u0026#34; \u0026gt; \u0026lt;/lightning-icon\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;slds-path__title\u0026#34;\u0026gt;{pathItem}\u0026lt;/span\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template if:false=\u0026#34;{pathIndexGeCurrentIndex}\u0026#34;\u0026gt; \u0026lt;li key=\u0026#34;{pathItem}\u0026#34; class=\u0026#34;slds-path__item slds-is-complete\u0026#34; role=\u0026#34;presentation\u0026#34; \u0026gt; \u0026lt;a aria-selected=\u0026#34;false\u0026#34; class=\u0026#34;slds-path__link\u0026#34; href=\u0026#34;javasctipt:void();\u0026#34; role=\u0026#34;option\u0026#34; tabindex=\u0026#34;-1\u0026#34; \u0026gt; \u0026lt;span class=\u0026#34;slds-path__stage\u0026#34;\u0026gt; \u0026lt;lightning-icon class=\u0026#34;slds-icon slds-icon_x-small\u0026#34; icon-name=\u0026#34;utility:check\u0026#34; alternative-text=\u0026#34;Stage Complete\u0026#34; variant=\u0026#34;inverse\u0026#34; size=\u0026#34;x-small\u0026#34; \u0026gt; \u0026lt;/lightning-icon\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;slds-path__title\u0026#34;\u0026gt;{pathItem}\u0026lt;/span\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; path.js\nimport { LightningElement, api, track } from \u0026#34;lwc\u0026#34;; export default class Path extends LightningElement { //パス項目リスト  @api pathItemList = []; //現在のパスインデックス  @track _currentPathIndex; @api get currentPathIndex() { return this._currentPathIndex; } set currentPathIndex(val) { this._currentPathIndex = val || []; this.idx = -1; } /** * 指定したインデックスより等しいまたは大きい */ get pathIndexGeCurrentIndex() { return this.idx \u0026gt;= Number(this.currentPathIndex); } /** * 指定したインデックスと等しい */ get pathIndexEqCurrentIndex() { return this.idx === Number(this.currentPathIndex); } /** * インデックス取得 */ get getIndex() { this.idx++; } } path.js-meta.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;54.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;false\u0026lt;/isExposed\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt; pathContainer \npathContainer.html\n\u0026lt;template\u0026gt; \u0026lt;c-path path-item-list=\u0026#34;{pathItemList}\u0026#34; current-path-index=\u0026#34;{currentPathIndex}\u0026#34; \u0026gt;\u0026lt;/c-path\u0026gt; \u0026lt;/template\u0026gt; pathContainer.js\nimport { LightningElement, track } from \u0026#34;lwc\u0026#34;; export default class PathContainer extends LightningElement { @track pathItemList = [\u0026#34;Status1\u0026#34;, \u0026#34;Status2\u0026#34;, \u0026#34;Status3\u0026#34;, \u0026#34;Status4\u0026#34;]; @track currentPathIndex = 2; } pathContainer.js-meta.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;54.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;false\u0026lt;/isExposed\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt; ロカールで動作確認 pathContainer 中に右クリックし、SFDX:Preview Component Locallyを押下する\n\nUse Desktop Browserを選択する\n\nサーバを立ち上げて、ブラウザを自動的に開く\n\n","permalink":"https://seiri-blog.github.io/posts/lwc-path-common-component/","summary":"目的 LWC での Path 共通コンポーネントを共有します。 実装例 path path.html \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;slds-path\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-grid slds-path__track\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-grid slds-path__scroller-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-path__scroller\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-path__scroller_inner\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;slds-path__nav\u0026#34; role=\u0026#34;listbox\u0026#34; aria-orientation=\u0026#34;horizontal\u0026#34; \u0026gt; \u0026lt;template for:each=\u0026#34;{pathItemList}\u0026#34; for:item=\u0026#34;pathItem\u0026#34; for:index=\u0026#34;index\u0026#34; \u0026gt; {getIndex} \u0026lt;template if:true=\u0026#34;{pathIndexGeCurrentIndex}\u0026#34;\u0026gt; \u0026lt;li key=\u0026#34;{pathItem}\u0026#34; if:true=\u0026#34;{pathIndexEqCurrentIndex}\u0026#34; class=\u0026#34;slds-path__item slds-is-current slds-is-active\u0026#34; role=\u0026#34;presentation\u0026#34; \u0026gt; \u0026lt;a aria-selected=\u0026#34;true\u0026#34; class=\u0026#34;slds-path__link\u0026#34; href=\u0026#34;javasctipt:void();\u0026#34; role=\u0026#34;option\u0026#34; tabindex=\u0026#34;-1\u0026#34; \u0026gt; \u0026lt;span class=\u0026#34;slds-path__stage\u0026#34;\u0026gt;","title":"【Salesforce】LWCでのPath共通コンポーネント"},{"content":"LWC で CSV 出力方法説明 LWC で CSV ファイルを出力する考え方は主に下記の流れとなります。\n1.LWC のコンポーネントにデータを持たせます。\n2.CSV を作成するため、各行の値\u0026quot;\u0026quot;で囲みます。\n3.CSV を作成するため、各行の値は,で区切します。\n4.CSV を作成するため、各行の後ろは\\nで改行します。 5.data:text/csv;charset=utf-8, + encodeURI(処理後のデータ)をリンクの URL を設定します。 6.以上のやり方で CSV を出力できるようにします。\n実装方法 \n exportDataToCSVInLWC  \u0026lt;template\u0026gt; \u0026lt;lightning-card title=\u0026#34;Export Data as CSV in Lightning Web Component\u0026#34; icon-name=\u0026#34;custom:custom63\u0026#34; \u0026gt; \u0026lt;template if:true=\u0026#34;{data}\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-p-around_medium lgc-bg-inverse\u0026#34;\u0026gt; \u0026lt;p\u0026gt; Do you want download data as a CSV format, Click Here \u0026amp;nbsp; \u0026lt;lightning-button icon-name=\u0026#34;utility:download\u0026#34; label=\u0026#34;Download as CSV\u0026#34; title=\u0026#34;Download CSV File\u0026#34; onclick=\u0026#34;{downloadCSVFile}\u0026#34; variant=\u0026#34;brand\u0026#34; \u0026gt;\u0026lt;/lightning-button\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;slds-m-around_medium\u0026#34;\u0026gt; \u0026lt;!-- Datatable component --\u0026gt; \u0026lt;lightning-datatable columns=\u0026#34;{columns}\u0026#34; data=\u0026#34;{data}\u0026#34; hide-checkbox-column=\u0026#34;true\u0026#34; key-field=\u0026#34;id\u0026#34; \u0026gt; \u0026lt;/lightning-datatable\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/lightning-card\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, track } from \u0026#34;lwc\u0026#34;; // importing accounts import getAccountList from \u0026#34;@salesforce/apex/LWCExampleController.getAccounts\u0026#34;; // imported to show toast messages import { ShowToastEvent } from \u0026#34;lightning/platformShowToastEvent\u0026#34;; // datatable columns const cols = [ { label: \u0026#34;Name\u0026#34;, fieldName: \u0026#34;Name\u0026#34; }, { label: \u0026#34;Industry\u0026#34;, fieldName: \u0026#34;Industry\u0026#34; }, { label: \u0026#34;Type\u0026#34;, fieldName: \u0026#34;Type\u0026#34; }, { label: \u0026#34;Phone\u0026#34;, fieldName: \u0026#34;Phone\u0026#34;, type: \u0026#34;phone\u0026#34; }, { label: \u0026#34;Rating\u0026#34;, fieldName: \u0026#34;Rating\u0026#34; }, { label: \u0026#34;Account Number\u0026#34;, fieldName: \u0026#34;AccountNumber\u0026#34; }, ]; export default class ExportDataToCSVInLWC extends LightningElement { @track error; @track data; @track columns = cols; // this constructor invoke when component is created.  // once component is created it will fetch the accounts  constructor() { super(); this.getallaccounts(); } // fetching accounts from server  getallaccounts() { getAccountList() .then((result) =\u0026gt; { this.data = result; this.error = undefined; }) .catch((error) =\u0026gt; { this.error = error; this.dispatchEvent( new ShowToastEvent({ title: \u0026#34;Error while getting Accounts\u0026#34;, message: error.message, variant: \u0026#34;error\u0026#34;, }) ); this.data = undefined; }); } // this method validates the data and creates the csv file to download  downloadCSVFile() { let rowEnd = \u0026#34;\\n\u0026#34;; let csvString = \u0026#34;\u0026#34;; // this set elminates the duplicates if have any duplicate keys  let rowData = new Set(); // getting keys from data  this.data.forEach(function (record) { Object.keys(record).forEach(function (key) { rowData.add(key); }); }); // Array.from() method returns an Array object from any object with a length property or an iterable object.  rowData = Array.from(rowData); // splitting using \u0026#39;,\u0026#39;  csvString += rowData.join(\u0026#34;,\u0026#34;); csvString += rowEnd; // main for loop to get the data based on key value  for (let i = 0; i \u0026lt; this.data.length; i++) { let colValue = 0; // validating keys in data  for (let key in rowData) { if (rowData.hasOwnProperty(key)) { // Key value  // Ex: Id, Name  let rowKey = rowData[key]; // add , after every value except the first.  if (colValue \u0026gt; 0) { csvString += \u0026#34;,\u0026#34;; } // If the column is undefined, it as blank in the CSV file.  let value = this.data[i][rowKey] === undefined ? \u0026#34;\u0026#34; : this.data[i][rowKey]; csvString += \u0026#39;\u0026#34;\u0026#39; + value + \u0026#39;\u0026#34;\u0026#39;; colValue++; } } csvString += rowEnd; } // Creating anchor element to download  let downloadElement = document.createElement(\u0026#34;a\u0026#34;); // This encodeURI encodes special characters, except: , / ? : @ \u0026amp; = + $ # (Use encodeURIComponent() to encode these characters).  downloadElement.href = \u0026#34;data:text/csv;charset=utf-8,\u0026#34; + encodeURI(csvString); downloadElement.target = \u0026#34;_self\u0026#34;; // CSV File Name  downloadElement.download = \u0026#34;Account Data.csv\u0026#34;; // below statement is required if you are using firefox browser  document.body.appendChild(downloadElement); // click() Javascript function to download CSV file  downloadElement.click(); } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34; fqn=\u0026#34;exportDataToCSVInLWC\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;53.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;true\u0026lt;/isExposed\u0026gt; \u0026lt;targets\u0026gt; \u0026lt;target\u0026gt;lightning__Tab\u0026lt;/target\u0026gt; \u0026lt;/targets\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt; 動作確認 ","permalink":"https://seiri-blog.github.io/posts/salesforce-lwc-csv-output-method/","summary":"LWC で CSV 出力方法説明 LWC で CSV ファイルを出力する考え方は主に下記の流れとなります。 1.LWC のコンポーネントにデータを持たせます。 2.CSV を作成するため、各行の","title":"【Salesforce】LWC CSV出力方法"},{"content":"準備 下記コマンドを順番に実行し、Amplify-React での環境を構築する\n1.AmplifyCLI をインストール\nnpm install -g @aws-amplify/cli 2.Amplify を設定する\namplify configure Specify the AWS Region ? region: # Your preferred region Specify the username of the new IAM user: ? user name: # User name for Amplify IAM user Complete the user creation using the AWS console Enter the access key of the newly created user: ? accessKeyId: # YOUR_ACCESS_KEY_ID ? secretAccessKey: # YOUR_SECRET_ACCESS_KEY This would update/create the AWS Profile in your local machine ? Profile Name: # (default) Successfully set up the new user. 3.Amplify プロジェクトを作成する\nnpx create-react-app react-amplified cd react-amplified 4.Amplify での初期化\namplify init Enter a name for the project (react-amplified) # All AWS services you provision for your app are grouped into an \u0026quot;environment\u0026quot; # A common naming convention is dev, staging, and production Enter a name for the environment (dev) # Sometimes the CLI will prompt you to edit a file, it will use this editor to open those files. Choose your default editor # Amplify supports JavaScript (Web \u0026amp; React Native), iOS, and Android apps Choose the type of app that you're building (javascript) What JavaScript framework are you using (react) Source directory path (src) Distribution directory path (build) Build command (npm run build) Start command (npm start) # This is the profile you created with the `amplify configure` command in the introduction step. Do you want to use an AWS profile 5.Amplify でのパッケージをインストールする\nnpm install aws-amplify @aws-amplify/ui-react@1.x.x 構成 react-amplified | +---public | index.html | \\---src | App.js | aws-exports.js　⇒　自動生成設定ファイル | index.js | +---page | Index.js | Page1.js | Page2.js | NotFound.js | ErrorBoundary.js 実装 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; import React from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom\u0026#39;; import Amplify from \u0026#34;aws-amplify\u0026#34;; import App from \u0026#39;./App\u0026#39;; //予期せぬエラーページ import ErrorBoundary from \u0026#39;./page/ErrorBoundary\u0026#39;; //Amplifyの設定を読み込む import config from \u0026#34;./aws-exports\u0026#34;; Amplify.configure(config); ReactDOM.render(\u0026lt;ErrorBoundary\u0026gt;\u0026lt;App /\u0026gt;\u0026lt;/ErrorBoundary\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;)); import { withAuthenticator } from \u0026#39;aws-amplify-react\u0026#39;; import { BrowserRouter, Route } from \u0026#39;react-router-dom\u0026#39;; import React, { Component } from \u0026#39;react\u0026#39;; //ページインポート import Index from \u0026#39;./page/Index\u0026#39;; import Page1 from \u0026#39;./page/Page1\u0026#39;; import Page2 from \u0026#39;./page/Page2\u0026#39;; import NotFound from \u0026#39;./page/NotFound\u0026#39;; class App extends Component { render() { return ( {/*ルーター宣言*/} \u0026lt;BrowserRouter\u0026gt; \u0026lt;Route exact path=\u0026#39;/\u0026#39; component={Index} /\u0026gt; \u0026lt;Route exact path=\u0026#39;/page1\u0026#39; component={Page1} /\u0026gt; \u0026lt;Route exact path=\u0026#39;/page1\u0026#39; component={Page2} /\u0026gt; {/*404ページ*/} \u0026lt;Route component={NotFound} /\u0026gt; \u0026lt;/BrowserRouter\u0026gt; ); } } //Amplifyの高級コンポネント(HoC)をエクスポート export default withAuthenticator(App); import React, { Component } from \u0026#39;react\u0026#39;; export default class Index extends Component { render() { return ( \u0026lt;div\u0026gt;\u0026lt;h2 \u0026gt;Index Page\u0026lt;/h2\u0026gt;\u0026lt;/div\u0026gt; ); } } import React, { Component } from \u0026#39;react\u0026#39;; export default class Page1 extends Component { render() { return ( \u0026lt;div\u0026gt;\u0026lt;h2 \u0026gt;Page1\u0026lt;/h2\u0026gt;\u0026lt;/div\u0026gt; ); } } import React, { Component } from \u0026#39;react\u0026#39;; export default class Page2 extends Component { render() { return ( \u0026lt;div\u0026gt;\u0026lt;h2 \u0026gt;Page2\u0026lt;/h2\u0026gt;\u0026lt;/div\u0026gt; ); } } import React, { Component } from \u0026#39;react\u0026#39;; export default class NotFound extends Component { render() { return ( \u0026lt;div\u0026gt;\u0026lt;h2 \u0026gt;Error 404: Not Found\u0026lt;/h2\u0026gt;\u0026lt;/div\u0026gt; ); } } import React, { Component } from \u0026#39;react\u0026#39;; export default class ErrorBoundary extends Component { constructor(props) { super(props); this.state = { hasError: false }; } static getDerivedStateFromError(error) { return { hasError: true }; } componentDidCatch(error, errorInfo) { //エラー情報を出力する  console.error(error, errorInfo); } render() { if (this.state.hasError) { // エラー発生するUI  return ( \u0026lt;div \u0026gt; \u0026lt;h2 \u0026gt;予期せぬエラーが発生しました。\u0026lt;/h2\u0026gt;\u0026lt;/div\u0026gt; ); } return this.props.children; } } 参考 https://docs.amplify.aws/\nhttps://ja.reactjs.org/\nhttps://reactrouter.com/\n","permalink":"https://seiri-blog.github.io/posts/application-creating-at-amplify-react/","summary":"準備 下記コマンドを順番に実行し、Amplify-React での環境を構築する 1.AmplifyCLI をインストール npm install -g @aws-amplify/cli 2.Amplify を設定する amplify configure Specify the AWS Region ? region: # Your preferred region Specify the","title":"Amplify + Reactでアプリケーション作成"},{"content":"準備 1.amplify add storageコマンドで、S3 を追加する\namplify add storage ? Please select from one of the below mentioned services (Use arrow keys) ❯ Content (Images, audio, video, etc.) NoSQL Database 2.amplify pushコマンドで作成した S3 を AWS にデプロイし、\nAWS のS3サービスへ反映する\namplify push 3.amplify consoleコマンドでデプロイしたサービスを確認する\namplify console 4.AWS S3のCORSを設定する\n[ { \u0026quot;AllowedHeaders\u0026quot;: [ \u0026quot;*\u0026quot; ], \u0026quot;AllowedMethods\u0026quot;: [ \u0026quot;GET\u0026quot;, \u0026quot;HEAD\u0026quot;, \u0026quot;PUT\u0026quot;, \u0026quot;POST\u0026quot;, \u0026quot;DELETE\u0026quot; ], \u0026quot;AllowedOrigins\u0026quot;: [ \u0026quot;*\u0026quot; ], \u0026quot;ExposeHeaders\u0026quot;: [ \u0026quot;x-amz-server-side-encryption\u0026quot;, \u0026quot;x-amz-request-id\u0026quot;, \u0026quot;x-amz-id-2\u0026quot;, \u0026quot;ETag\u0026quot; ], \u0026quot;MaxAgeSeconds\u0026quot;: 3000 } ] 実装 import Amplify, { Storage } from \u0026#39;aws-amplify\u0026#39;; import config from \u0026#34;./aws-exports\u0026#34;; Amplify.configure(config); /** * ファイルを保存 * @param {string} key キー * @param {object} object オブジェクト * @param {object} config 設定（オプション） * @returns 結果 */ export async function put(key, object, config = null) { try { return await Storage.put(key, object, config); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); } } /** * ファイルを削除 * @param {string} key キー * @param {object} object オブジェクト * @param {object} config 設定（オプション） * @returns 結果 */ export async function remove(key, object, config = null) { try { return await Storage.remove(key, object, config); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); } } /** * ファイルを取得 * @param {string} key キー * @param {object} config 設定（オプション） * @returns 署名付きURLまたはファイル(Blob) */ export async function get(key, config = null) { try { return await Storage.get(key, config); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); } } /** * ファイル一覧を取得 * @param {string} path キー * @param {object} config 設定（オプション） * @returns 一覧情報 */ export async function list(path, config = null) { try { return await Storage.list(path, config); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); } } /** * ファイルダウンロード * @param {object} blob ファイルオブジェクト * @param {string} filename ファイル名 */ export function downloadBlob(blob, filename) { const url = URL.createObjectURL(blob); const a = document.createElement(\u0026#39;a\u0026#39;); a.href = url; a.download = filename || \u0026#39;download\u0026#39;; const clickHandler = () =\u0026gt; { setTimeout(() =\u0026gt; { URL.revokeObjectURL(url); a.removeEventListener(\u0026#39;click\u0026#39;, clickHandler); }, 150); }; a.addEventListener(\u0026#39;click\u0026#39;, clickHandler, false); a.click(); return a; } 参考 https://docs.amplify.aws/lib/storage/getting-started/q/platform/js/\nhttps://aws-amplify.github.io/amplify-js/api/classes/storageclass.html\n","permalink":"https://seiri-blog.github.io/posts/amplify-setup-s3-and-operation/","summary":"準備 1.amplify add storageコマンドで、S3 を追加する amplify add storage ? Please select from one of the below mentioned services (Use arrow keys) ❯ Content (Images, audio, video, etc.) NoSQL Database 2.amplify pushコマンドで作成した S3 を AWS にデプロイ","title":"AmplifyでS3と連携する方法"},{"content":"準備 1.amplify add apiコマンドで、GraphQL API を追加する\namplify add api ? Please select from one of the below mentioned services: \u0026gt; GraphQL ? Here is the GraphQL API that we will create. Select a setting to edit or continue: \u0026gt; Continue ? Choose a schema template: \u0026gt; Single object with fields (e.g., “Todo” with ID, name, description) ? Do you want to edit the schema now? \u0026gt; Yes 2.amplify/backend/api/myapi/schema.graphqlを編集する\ntype Todo @model { id: ID! name: String! description: String } 3.amplify pushコマンドで作成した Rest API を AWS にデプロイし、\nAWS のAppSyncサービスへ反映する\namplify push ? Are you sure you want to continue? Y ? Do you want to generate code for your newly created GraphQL API? Y ? Choose the code generation language target: javascript (or your preferred language target) ? Enter the file name pattern of graphql queries, mutations and subscriptions src/graphql/**/*.js ? Do you want to generate/update all possible GraphQL operations - queries, mutations and subscriptions? Y ? Enter maximum statement depth [increase from default if your schema is deeply nested]: 2 4.amplify consoleコマンドでデプロイしたサービスを確認する\namplify console 実装 import Amplify, { API } from \u0026#39;aws-amplify\u0026#39;; import config from \u0026#34;./aws-exports\u0026#34;; Amplify.configure(config); /** * GraphQL実行 * @param {string} query 作成、更新、削除、検索のGraphQL * @param {object} input 項目(設定無し可) * @returns 結果 */ export async function graphql(query, input = null) { try { if (!!input) return await API.graphql({ query, variables: { input } }); else return await API.graphql({ query }); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); } } 参考 https://docs.amplify.aws/lib/restapi/getting-started/q/platform/js/\nhttps://docs.amplify.aws/cli-legacy/graphql-transformer/overview/\nhttps://aws-amplify.github.io/amplify-js/api/classes/apiclass.html\n","permalink":"https://seiri-blog.github.io/posts/amplify-call-graphql/","summary":"準備 1.amplify add apiコマンドで、GraphQL API を追加する amplify add api ? Please select from one of the below mentioned services: \u0026gt; GraphQL ? Here is the GraphQL API that we will create. Select a setting to edit or continue: \u0026gt; Continue ? Choose a schema template: \u0026gt; Single object with fields","title":"AmplifyでGraphQLを呼出す方法"},{"content":"準備 1.amplify add apiコマンドで、Rest API を追加する\namplify add api ? Please select from one of the below mentioned services GraphQL ❯ REST 2.amplify pushコマンドで作成した Rest API を AWS にデプロイし、\nAWS のAPI Gatewayサービスへ反映する\namplify push 3.amplify consoleコマンドでデプロイしたサービスを確認する\namplify console 実装 import Amplify, { API } from \u0026#39;aws-amplify\u0026#39;; import config from \u0026#34;./aws-exports\u0026#34;; Amplify.configure(config); /** * DELETEメソッド * @param {string} apiName api名 * @param {string} path パス * @param {object} init init * @returns 結果 */ export async function del(apiName, path, init) { try { return await API.del(apiName, path, init); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); return err; } } /** * GETメソッド * @param {string} apiName api名 * @param {string} path パス * @param {object} init init * @returns 結果 */ export async function get(apiName, path, init) { try { return await API.get(apiName, path, init); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); return err; } } /** * POSTメソッド * @param {string} apiName api名 * @param {string} path パス * @param {object} init init * @returns 結果 */ export async function post(apiName, path, init) { try { return await API.post(apiName, path, init); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); return err; } } /** * PUTメソッド * @param {string} apiName api名 * @param {string} path パス * @param {object} init init * @returns 結果 */ export async function put(apiName, path, init) { try { return await API.put(apiName, path, init); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); return err; } } /** * HEADメソッド * @param {string} apiName api名 * @param {string} path パス * @param {object} init init * @returns 結果 */ export async function head(apiName, path, init) { try { return await API.head(apiName, path, init); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); return err; } } /** * PATCHメソッド * @param {string} apiName api名 * @param {string} path パス * @param {object} init init * @returns 結果 */ export async function patch(apiName, path, init) { try { return await API.patch(apiName, path, init); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); return err; } } 参考 https://docs.amplify.aws/lib/restapi/getting-started/q/platform/js/\nhttps://aws-amplify.github.io/amplify-js/api/classes/apiclass.html\n","permalink":"https://seiri-blog.github.io/posts/amplify-call-gateway/","summary":"準備 1.amplify add apiコマンドで、Rest API を追加する amplify add api ? Please select from one of the below mentioned services GraphQL ❯ REST 2.amplify pushコマンドで作成した Rest API を AWS にデプロイし、 AWS のAPI G","title":"AmplifyでAPI Gatewayを呼出す方法"},{"content":"前提 1.amplify add authコマンドで認証サービスを作成する\namplify add auth ? Do you want to use the default authentication and security configuration? Default configuration ? How do you want users to be able to sign in? Username ? Do you want to configure advanced settings? No, I am done. 2.amplify pushコマンドで作成した認証サービスを AWS にデプロイし、\nAWS のCognitoサービスへ反映する\namplify push 3.amplify consoleコマンドでデプロイしたサービスを確認する\namplify console 実装 import Amplify, { Auth } from \u0026#39;aws-amplify\u0026#39;; import config from \u0026#34;./aws-exports\u0026#34;; Amplify.configure(config); /** * 現在の設定を取得 * @returns 設定情報 */ export function getAuthCurrentConfig() { return Auth.configure(); } /** * サインアップ * @param {object} userInfo ユーザ情報 * {username, password, email, phone_number} * @returns サインアップ情報 */ export async function signUp(userInfo) { try { const { username, password, email, phone_number } = userInfo; let userConfiger = { username, password }; let attributes = {}; if (!!email) { attributes = { email }; } if (!!phone_number) { attributes = { ...attributes, phone_number }; } userConfiger = {...userConfiger, attributes }; return await Auth.signUp(userConfiger); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); } } /** * サインアップ再送 * @param {*} username ユーザ名 */ export async function resendSignUp(username) { try { await Auth.resendSignUp(username); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); } } /** * サインアップ確認 * @param {string} username ユーザ名 * @param {string} code 認証コード */ export async function confirmSignUp(username, code) { try { await Auth.confirmSignUp(username, code); } catch (err) { console.error(\u0026#39;error\u0026#39;, err); } } /** * サインイン * @param {string} username ユーザ名 * @param {string} password パスワード * @returns ユーザ情報 */ export async function signIn(username, password) { try { return await Auth.signIn(username, password); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); } } /** * サインアウト */ export async function signOut() { try { return await Auth.signOut(); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); } } /** * グルバールサインアウト */ export async function globalSignOut() { try { await Auth.signOut({ global: true }); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); } } /** * パスワード変更 * @param {object} cognitoUser cognitoユーザ * @param {string} oldPassword 旧パスワード * @param {string} newPassword 新パスワード * @returns 変更結果 */ export async function changePassword(cognitoUser, oldPassword, newPassword) { try { return await Auth.changePassword(cognitoUser, oldPassword, newPassword); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); } } /** * パースワードを忘れる * @param {string} username ユーザ名 * @returns パスワードを忘れる結果 */ export async function forgotPassword(username) { try { return await Auth.forgotPassword(username); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); } } /** * パスワード忘れサブミット * @param {string} username ユーザ名 * @param {string} code 認証コード * @param {string} password パスワード * @returns 結果 */ export async function forgotPasswordSubmit(username, code, password) { try { return await Auth.forgotPasswordSubmit(username, code, password); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); } } /** * 新パースワードを完了 * @param {object} cognitoUser cognitoユーザ * @param {string} password パスワード * @param {string} requiredAttributes 必須属性 * @returns 結果 */ export async function completeNewPassword(cognitoUser, password, requiredAttributes) { try { return await Auth.completeNewPassword(cognitoUser, password, requiredAttributes); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); } } /** * 現在セッションを取得 * @returns 現在セッション */ export async function currentSession() { try { return await Auth.currentSession(); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); } } /** * 現在ユーザ認証情報を取得 * @returns 現在ユーザ認証情報 */ export async function currentAuthenticatedUser() { try { return await Auth.currentAuthenticatedUser(); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); } } /** * 現在資格情報取得 * @returns 現在情報資格 */ export async function currentCredentials() { try { return await Auth.currentCredentials(); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); } } /** * 現在ユーザ資格情報取得 * @returns 現在ユーザ資格情報 */ export async function currentUserCredentials() { try { return await Auth.currentUserCredentials(); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); } } /** * 現在ユーザ情報取得 * @returns 現在ユーザ情報 */ export async function currentUserInfo() { try { return await Auth.currentUserInfo(); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); } } /** * 現在ユーザプールユーザ取得 * @returns 現在ユーザプールユーザ */ export async function currentUserPoolUser() { try { return await Auth.currentUserPoolUser(); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); } } /** * ユーザ属性取得 * @returns ユーザ属性 */ export async function userAttributes() { try { return await Auth.userAttributes(); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); } } /** * ユーザセッション取得 * @param {object} cognitoUser ユーザ * @returns ユーザセッション */ export async function userSession(cognitoUser) { try { return await Auth.userSession(cognitoUser); } catch (err) { console.error(\u0026#39;error:\u0026#39;, err); } } 参考 https://knowstechnic.blogspot.com/2022/12/amplifyauthutil.html\nhttps://docs.amplify.aws/start/getting-started/auth/q/integration/react/##create-authentication-service\nhttps://aws-amplify.github.io/amplify-js/api/classes/authclass.html\n","permalink":"https://seiri-blog.github.io/posts/create-authutil-on-amplify/","summary":"前提 1.amplify add authコマンドで認証サービスを作成する amplify add auth ? Do you want to use the default authentication and security configuration? Default configuration ? How do you want users to be able to sign in? Username ? Do you want to configure advanced settings? No, I am done. 2.amplify pus","title":"AmplifyでのAuthUtilを作成する"},{"content":"環境 Win10\npython 3.8.10\n・requests==2.25.1\n・pandas==1.3.1\n実装 import requests as rq import pandas as pd url = \u0026#39;https://covid19-japan-web-api.vercel.app/api/v1/positives?prefecture={0}\u0026#39; prefectures = [\u0026#39;北海道\u0026#39;,\u0026#39;青森県\u0026#39;,\u0026#39;岩手県\u0026#39;,\u0026#39;宮城県\u0026#39;,\u0026#39;秋田県\u0026#39;,\u0026#39;山形県\u0026#39;,\u0026#39;福島県\u0026#39;,\u0026#39;茨城県\u0026#39;,\u0026#39;栃木県\u0026#39;,\u0026#39;群馬県\u0026#39;,\u0026#39;埼玉県\u0026#39;,\u0026#39;千葉県\u0026#39;,\u0026#39;東京都\u0026#39;,\u0026#39;神奈川県\u0026#39;,\u0026#39;新潟県\u0026#39;,\u0026#39;富山県\u0026#39;,\u0026#39;石川県\u0026#39;,\u0026#39;福井県\u0026#39;,\u0026#39;山梨県\u0026#39;,\u0026#39;長野県\u0026#39;,\u0026#39;岐阜県\u0026#39;,\u0026#39;静岡県\u0026#39;,\u0026#39;愛知県\u0026#39;,\u0026#39;三重県\u0026#39;,\u0026#39;滋賀県\u0026#39;,\u0026#39;京都府\u0026#39;,\u0026#39;大阪府\u0026#39;,\u0026#39;兵庫県\u0026#39;,\u0026#39;奈良県\u0026#39;,\u0026#39;和歌山県\u0026#39;,\u0026#39;鳥取県\u0026#39;,\u0026#39;島根県\u0026#39;,\u0026#39;岡山県\u0026#39;,\u0026#39;広島県\u0026#39;,\u0026#39;山口県\u0026#39;,\u0026#39;徳島県\u0026#39;,\u0026#39;香川県\u0026#39;,\u0026#39;愛媛県\u0026#39;,\u0026#39;高知県\u0026#39;,\u0026#39;福岡県\u0026#39;,\u0026#39;佐賀県\u0026#39;,\u0026#39;長崎県\u0026#39;,\u0026#39;熊本県\u0026#39;,\u0026#39;大分県\u0026#39;,\u0026#39;宮崎県\u0026#39;,\u0026#39;鹿児島県\u0026#39;,\u0026#39;沖縄県\u0026#39;] out_dataframe = pd.DataFrame() for p in prefectures: tmp_url = url.format(p) response = rq.get(tmp_url) if response.status_code == 200: dataframe_body = pd.DataFrame(response.json()) out_dataframe = out_dataframe.append(dataframe_body, ignore_index=True) out_dataframe.to_csv(\u0026#39;result.csv\u0026#39;, mode=\u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) 参考 https://requests-docs-ja.readthedocs.io/en/latest/\n","permalink":"https://seiri-blog.github.io/posts/python-corona-patient-info-in-japanese/","summary":"環境 Win10 python 3.8.10 ・requests==2.25.1 ・pandas==1.3.1 実装 import requests as rq import pandas as pd url = \u0026#39;https://covid19-japan-web-api.vercel.app/api/v1/positives?prefecture={0}\u0026#39; prefectures = [\u0026#39;北海道\u0026#39;,\u0026#39","title":"Pythonで日本の新型コロナ患者情報取得"},{"content":"準備 環境変数の設定 環境変数は、関数の未公開バージョンで定義します。バージョンを公開するとき、他のバージョン固有の設定とともに、そのバージョンの環境変数がロックされます。\n関数の環境変数を作成するには、キーと値を定義します。関数は、キーの名前を使用して、環境変数の値を取得します。\nLambda コンソールで環境変数を設定するには\n Lambda コンソールで [Functions (関数)] ページを開きます。 関数を選択します。 [Configuration] (設定) を選択してから、[Environment variables] (環境変数) を選択します。 [環境変数] で、[編集] を選択します。 [環境変数の追加] を選択します キーと値を入力します。  Requirements  キーは文字で始まり、少なくとも 2 文字です。 キーには、文字、数字、およびアンダースコア (_) のみを含める。 キーは Lambda によって予約されていない。 すべての環境変数の合計サイズは 4 KB を超えない。     [Save] を選択します。  \n実装 AWS Lambda 関数内で Python を使用して環境変数を取得するには、os モジュールを使用します。以下のコードスニペットは、Lambda 関数内で環境変数を取得する方法を示しています。\nimport os def lambda_handler(event, context): # 環境変数の取得 my_var = os.environ.get(\u0026#39;MY_VARIABLE\u0026#39;) # ログに出力 print(my_var) # 他の処理... 上記の例では、os.environ.get()関数を使用して MY_VARIABLE という名前の環境変数の値を取得しています。もし環境変数が存在しない場合、None が返されます。\nLambda 関数が実行される際に、Lambda コンソールや AWS CLI、または AWS SDK などを使用して、環境変数を設定することができます。\n参照 https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/configuration-envvars.html\n","permalink":"https://seiri-blog.github.io/posts/aws-lambda-environment-variable-acquisition-on-python/","summary":"準備 環境変数の設定 環境変数は、関数の未公開バージョンで定義します。バージョンを公開するとき、他のバージョン固有の設定とともに、そのバージョン","title":"PythonでのAWS Lambda環境変数の取得"},{"content":"python での DBUtil の作成方法 以下に、Python で AWS Lambda 内で共通的に使用される DynamoDB 操作のためのユーティリティクラスの例を示します。このクラスを使用すると、DynamoDB テーブルへのアクセスや操作が容易になります。\nimport boto3 dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;, endpoint_url=\u0026#34;XXXXXXX\u0026#34;) class DynamoDB: \u0026#34;\u0026#34;\u0026#34;DynamoDBの操作(CRUD)クラス Args: table_name: テーブル名 Attributes: table: DynamoDBテーブルのオブジェクト \u0026#34;\u0026#34;\u0026#34; def __init__(self, table_name): try: self.table = dynamodb.Table(table_name) except Exception: raise def put_item(self, item_dict): \u0026#34;\u0026#34;\u0026#34;アイテム追加 Args: item_dict: 追加情報 Returns: 追加結果(dict) \u0026#34;\u0026#34;\u0026#34; response = self.table.put_item( Item=item_dict ) return response def update_item(self, key_dict, update_expression, expression_attribute_values, expression_attribute_names): \u0026#34;\u0026#34;\u0026#34;アイテム更新 Args: key_dict: パーティションキー値（更新列指定） update_expression: 更新カラム指定 expression_attribute_values: 更新属性値 expression_attribute_names: 更新属性名 Returns: 更新結果(dict) \u0026#34;\u0026#34;\u0026#34; response = self.table.update_item( Key=key_dict, UpdateExpression=update_expression, ExpressionAttributeValues=expression_attribute_values, ExpressionAttributeNames=expression_attribute_names, ) return response def delete_item(self, partition_key_value, sort_key_value=None): \u0026#34;\u0026#34;\u0026#34;アイテム削除 Args: partition_key_value: パーティションキー値 sort_key_value: ソートキー値 Returns: 削除結果(dict) \u0026#34;\u0026#34;\u0026#34; if sort_key_value is not None: response = self.table.delete_item( key=partition_key_value, sortkey=sort_key_value ) else: response = self.table.delete_item( Key=partition_key_value ) return response def get_item(self, item_dict): \u0026#34;\u0026#34;\u0026#34;アイテム一意検索 Args: item_dict: 検索情報 Returns: 検索結果(dict) \u0026#34;\u0026#34;\u0026#34; response = self.table.get_item( Key=item_dict, ) return response.get(\u0026#39;Item\u0026#39;) def exist_item(self, item_dict): \u0026#34;\u0026#34;\u0026#34;アイテム一意検索(存在チェックあり) Args: item_dict: 検索情報 Returns: 検索結果(dict) ヒットいない場合None \u0026#34;\u0026#34;\u0026#34; response = self.table.get_item( Key=item_dict, ) if \u0026#39;Item\u0026#39; in response: return True else: return False def query(self, key_condition_expression, filter_expression=None): \u0026#34;\u0026#34;\u0026#34;全データクエリ(LIMITなし) Args: key_condition_expression: キー検索条件 filter_expression: 検索条件 Returns: 検索結果(dict) 使い方) from boto3.dynamodb.conditions import Key, Attr key_condition_expression=Key(\u0026#39;Id\u0026#39;).eq(\u0026#39;1\u0026#39;) filter_expression=Attr(\u0026#39;XXXXX\u0026#39;).contains(\u0026#39;○○\u0026#39;) Item = DynamoDB(\u0026#39;Table\u0026#39;,\u0026#39;Id\u0026#39;).query( key_condition_expression, filter_expression) print(Item) \u0026#34;\u0026#34;\u0026#34; params = {\u0026#39;KeyConditionExpression\u0026#39;: key_condition_expression} response = [] if filter_expression is not None: params[\u0026#39;FilterExpression\u0026#39;] = filter_expression while True: result = self.table.query(**params) response.extend(result[\u0026#39;Items\u0026#39;]) if \u0026#39;LastEvaluatedKey\u0026#39; not in result: break params[\u0026#39;ExclusiveStartKey\u0026#39;] = result[\u0026#39;LastEvaluatedKey\u0026#39;] return response def scan(self, filter_expression): \u0026#34;\u0026#34;\u0026#34;全データスキャン(LIMITなし) Args: filter_expression: 検索条件 Returns: 検索結果(dict) 使い方) from boto3.dynamodb.conditions import Key, Attr filter_expression=Attr(\u0026#39;XXXXX\u0026#39;).eq(\u0026#39;○○\u0026#39;) Items = DynamoDB(\u0026#39;Table\u0026#39;,\u0026#39;Id\u0026#39;).scan(filter_expression) \u0026#34;\u0026#34;\u0026#34; params = {} response = [] if filter_expression is not None: params[\u0026#39;FilterExpression\u0026#39;] = filter_expression while True: result = self.table.scan(**params) response.extend(result[\u0026#39;Items\u0026#39;]) if \u0026#39;LastEvaluatedKey\u0026#39; not in result: break params[\u0026#39;ExclusiveStartKey\u0026#39;] = result[\u0026#39;LastEvaluatedKey\u0026#39;] return response 上記の例では、DynamoDB というクラスが定義されています。このクラスは DynamoDB テーブルへの共通的な操作を提供します。\n__init__メソッドでは、DynamoDB リソースとテーブルを初期化します。table_name パラメータは、操作する対象の DynamoDB テーブルの名前です。\n以下のメソッドが提供されています:\n get_item: 指定されたキーを使用してアイテムを取得します。 put_item: アイテムをテーブルに追加します。 update_item: アイテムを更新します。アップデート式と式の属性値を指定する必要があります。 delete_item: 指定されたキーを持つアイテムを削除します。 exist_item: 指定されたキーを持つアイテムが存在するかを判断します。 query: 指定されたキーと検索条件によりデータを取得します。 scan: 指定された検索条件によりデータを取得します。  これらのメソッドは、必要に応じてカスタマイズや追加の操作を行うことができます。また、AWS SDK for Python (Boto3)の機能を活用して、他の DynamoDB 操作も実装できます。\nこのクラスを使用するには、Lambda 関数内でインスタンスを作成し、適切なメソッドを呼び出すことができます。\n例えば、以下のような使い方ができます:\ndef lambda_handler(event, context): dynamodb_utils = DynamoDBUtils(\u0026#39;my-table-name\u0026#39;) # アイテムの取得 key = {\u0026#39;id\u0026#39;: \u0026#39;123\u0026#39;} item = dynamodb_utils.get_item(key) print(item) # アイテムの追加 new_item = {\u0026#39;id\u0026#39;: \u0026#39;456\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;John\u0026#39;} response = dynamodb_utils.put_item(new_item) print(response) # アイテムの更新 update_expression = \u0026#39;SET #attrName = :attrValue\u0026#39; expression_attribute_values = {\u0026#39;:attrValue\u0026#39;: \u0026#39;updated value\u0026#39;} response = dynamodb_utils.update_item(key, update_expression, expression_attribute_values, None) print(response) 参考 https://docs.aws.amazon.com/ja_jp/amazondynamodb/latest/developerguide/GettingStarted.python.04.html\nhttps://docs.aws.amazon.com/ja_jp/amazondynamodb/latest/developerguide/Scan.html#Scan.Pagination\nhttps://boto3.amazonaws.com/v1/documentation/api/latest/guide/dynamodb.html\n","permalink":"https://seiri-blog.github.io/posts/aws-lambda-common-dynamodb-operation-util-in-python/","summary":"python での DBUtil の作成方法 以下に、Python で AWS Lambda 内で共通的に使用される DynamoDB 操作のためのユーティリティクラスの例を示します。このクラスを使用すると、","title":"PythonでのAWS Lambda共通DynamoDB操作Util"},{"content":"コンピューティングとストレージ Lambda では、関数の実行と保存に使用できるコンピューティングおよびストレージリソースの量に対してクォータを設定します。以下のクォータは、AWS リージョンごとに適用されており、引き上げることができます。詳細については、Service Quotas ユーザーガイドの「クォータの引き上げのリクエスト」を参照してください。\n   リソース デフォルトのクォータ 引き上げることができる最大     同時実行数 1,000 数万   アップロードされた関数 (.zip ファイルアーカイブ) とレイヤーのストレージ。各関数バージョンとレイヤーバージョンは、ストレージを消費します。コードストレージ管理のベストプラクティスについては、Lambda オペレータガイドの Lambda コードストレージのモニタリングを参照してください。 75 GB Terabytes   コンテナイメージとして定義された関数のストレージ。これらのイメージは Amazon ECR に保存されます。 「Amazon ECR サービスクォータ」を参照してください。    Virtual Private Cloud (VPC) ごとの Elastic Network Interfaces 250 数百    関数の設定、デプロイ、実行 関数の設定、デプロイ、実行には、次のクォータが適用されます。変更することはできません。\n Lambda のドキュメント、ログメッセージ、およびコンソールでは、1024 KB を示すのに (MiB ではなく) MB 使用します。\n    リソース クォータ     関数のメモリ割り当て 128 MB から 10,240 MB まで、1 MB 単位で増加できます。   関数タイムアウト 900 秒 (15 分)   関数の環境変数 4 KB (関数に関連付けられたすべての環境変数)   関数リソースベースのポリシー 20 KB   関数レイヤー 5 つのレイヤー   関数の同時実行数のバースト 500 ～ 3000 (リージョンによって異なります)   呼び出しペイロード (リクエストとレスポンス) 6 MB (同期)256 KB (非同期)   デプロイパッケージ (.zip ファイルアーカイブ) のサイズ 50 MB (zip 圧縮済み、直接アップロード)、250 MB (解凍後)このクォータは、レイヤーやカスタムランタイムなど、アップロードするすべてのファイルに適用されます。3 MB (コンソールエディタ)   コンテナイメージのコードパッケージサイズ 10 GB   テストイベント (コンソールエディタ) 10   /tmp ディレクトリのストレージ 512 MB   ファイルディスクリプタ 1,024   実行プロセス/スレッド 1,024    Lambda API リクエスト 次のクォータは Lambda API リクエストに関連付けられています。\n   リソース クォータ     リージョンあたりの呼び出しリクエスト頻度 (リクエスト数/秒) 10 x 同時実行クォータ (同期的、すべてのソース)、10 x 同時実行クォータ (非同期的、AWS 以外のソース)   非同期の AWS のサービスソースでの、リージョンあたりの呼び出しリクエスト数 (1 秒あたりのリクエスト数) 無制限のリクエストが可能です。実行レートは、その関数で利用可能な同時実行数に基づきます。「非同期呼び出し」を参照してください。   関数のバージョンまたはエイリアスあたりの呼び出しリクエスト頻度 (リクエスト数/秒) 10 x 割り当て済みのプロビジョニングされた同時実行数   GetFunction API リクエスト数 1 秒あたり 100 リクエスト   GetPolicy API リクエスト数 1 秒あたり 15 リクエスト   残りのコントロールプレーン API リクエスト数 (呼び出し、GetFunction、および GetPolicy リクエストを除く) 1 秒あたり 15 リクエスト    参考 https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/gettingstarted-limits.html\n","permalink":"https://seiri-blog.github.io/posts/aws-lambda-quota/","summary":"コンピューティングとストレージ Lambda では、関数の実行と保存に使用できるコンピューティングおよびストレージリソースの量に対してクォータを設定します","title":"AWS Lambda クォータ"},{"content":"tmp ディレクトリ説明  各実行環境は、/tmp ディレクトリ内の 512 MB~ 10240 MB のディスク領域を提供します。ディレクトリのコンテンツは、実行環境が停止された際に維持され、複数の呼び出しに使用できる一時的なキャッシュを提供します。キャッシュに保存したデータが存在するかどうかを確認するための追加コードを追加できます。デプロイのサイズ制限の詳細については、「Lambda クォータ」を参照してください。\n \nhttps://docs.aws.amazon.com/ja_jp/lambda/latest/dg/lambda-runtime-environment.html\nファイルを tmp ディレクトリに保存方法 AWS Lambda 関数内で S3 からファイルをダウンロードして/tmp ディレクトリに保存するには、以下の手順に従います。\n boto3 モジュールを使用して S3 クライアントを作成します。Lambda 関数の外部でクライアントを作成し、再利用することをお勧めします。  import boto3 s3 = boto3.resource(\u0026#39;s3\u0026#39;) ダウンロードするファイルを指定し、download_file メソッドを使用してファイルを/tmp ディレクトリにダウンロードします。  import boto3 from datetime import datetime s3 = boto3.resource(\u0026#39;s3\u0026#39;) BUCKET_NAME= \u0026#39;bucket_name\u0026#39; def lambda_handler(event, context): file_key = \u0026#39;your-file-key\u0026#39; local_file_path = \u0026#39;/tmp/my-file.txt\u0026#39; # ダウンロード後のローカルファイルパス bucket = s3.Bucket(BUCKET_NAME) bucket.download_file(file_key, local_file_path) 上記の例では、your-bucket-name は S3 バケットの名前で、your-file-key はダウンロードするファイルのキーです。local_file_path はローカルで保存するファイルのパスを指定します。この例では/tmp/my-file.txt に保存しています。\nS3 ファイルの内容を読取方法 import boto3 from datetime import datetime s3 = boto3.resource(\u0026#39;s3\u0026#39;) BUCKET_NAME= \u0026#39;bucket_name\u0026#39; def lambda_handler(event, context): file_key = \u0026#39;your-file-key\u0026#39; local_file_path = \u0026#39;/tmp/my-file.txt\u0026#39; # ダウンロード後のローカルファイルパス bucket = s3.Bucket(BUCKET_NAME) bucket.download_file(file_key, local_file_path) with open(local_file_path, \u0026#39;r\u0026#39;) as file: file_contents = file.read() # ファイルの内容に対する処理 print(file_contents) # 他の処理... 上記の例では、open 関数を使用してダウンロードしたファイルを読み込み、内容を表示しています。必要に応じて、他の処理を追加してください。\n纏め Lambda 関数は/tmp ディレクトリ内のファイルにのみアクセスできます。そのため、一時的な保存先として/tmp ディレクトリを使用しています。\nLambda 関数の実行が終了すると、/tmp ディレクトリ内のファイルは削除されるため、必要な場合は適切に処理してください。\n","permalink":"https://seiri-blog.github.io/posts/aws-lambda-by-s3-file-tmp-directory-save/","summary":"tmp ディレクトリ説明 各実行環境は、/tmp ディレクトリ内の 512 MB~ 10240 MB のディスク領域を提供します。ディレクトリのコンテンツは、実行環境が停止された","title":"【AWS】LambdaでS3ファイルをtmpディレクトリに保存"},{"content":"目的 boto3 ラブライブを利用して、AWS Coginit での操作 Utitl 作成方法を共有します。\n実装 # -*- coding: utf-8 -*- import secrets import string import boto3 USERPOOL_ID = \u0026#39;USERPOOL_ID\u0026#39; client = boto3.client(\u0026#39;cognito-idp\u0026#39;) def show_user_list(): \u0026#34;\u0026#34;\u0026#34;Cognitoおよびエンティティからユーザリストを取得する（最大60名a） Returns: ユーザ情報（ユーザーID、ユーザー名、状態、グループ権限） \u0026#34;\u0026#34;\u0026#34; def _user_list(pagination_token=None): \u0026#34;\u0026#34;\u0026#34;　Cognitoユーザーリストの再帰取得 Args: pagination_token: 前回呼び出しトークン Returns: ユーザ情報（ユーザーID、ユーザー名、状態、グループ権限） \u0026#34;\u0026#34;\u0026#34; if pagination_token is None: response = client.list_users( UserPoolId=USERPOOL_ID, ) else: response = client.list_users( UserPoolId=USERPOOL_ID, PaginationToken=pagination_token, ) for user in response[\u0026#39;Users\u0026#39;]: record = {} attrs = [attr[\u0026#39;Value\u0026#39;] for attr in user[\u0026#39;Attributes\u0026#39;] if attr[\u0026#39;Name\u0026#39;] == \u0026#39;name\u0026#39;] record.update( user_id=user[\u0026#39;Username\u0026#39;], user_name=attrs[0], status=user[\u0026#39;Enabled\u0026#39;] ) groups = client.admin_list_groups_for_user( UserPoolId=USERPOOL_ID, Username=user[\u0026#39;Username\u0026#39;] ) record.update( authority=groups[\u0026#39;Groups\u0026#39;][0][\u0026#39;GroupName\u0026#39;], ) yield record if \u0026#39;PaginationToken\u0026#39; in response: yield from _user_list(response.get(\u0026#39;PaginationToken\u0026#39;)) try: yield from _user_list() except Exception: raise def add_user(username, userid, user_auth, status, password): \u0026#34;\u0026#34;\u0026#34;Cognitoおよびエンティティにユーザ情報を登録する。 Args: username: Cognitoの標準属性name userid: ユーザID user_auth: ユーザグループ（admin,referrer,updaterより選択） status: ユーザの有効（True）、無効（False）を指定 password: ユーザパスワード Returns: 処理結果（True／False） \u0026#34;\u0026#34;\u0026#34; try: # ユーザ作成 client.admin_create_user( UserPoolId=USERPOOL_ID, Username=userid, UserAttributes=[ { \u0026#39;Name\u0026#39;: \u0026#39;name\u0026#39;, \u0026#39;Value\u0026#39;: username, }, ], TemporaryPassword=password, MessageAction=\u0026#39;SUPPRESS\u0026#39;, ) # パスワード適用（アカウントステータスをCONFIRMEDに変更） client.admin_set_user_password( UserPoolId=USERPOOL_ID, Username=userid, Password=password, Permanent=True, ) # グループ追加 client.admin_add_user_to_group( UserPoolId=USERPOOL_ID, Username=userid, GroupName=user_auth, ) # ユーザステータス変更 if not status: client.admin_disable_user( UserPoolId=USERPOOL_ID, Username=userid, ) except Exception: return False return True def modify_user(event, username, userid, user_auth, status): \u0026#34;\u0026#34;\u0026#34;Cognitoおよびエンティティのユーザ情報を更新する。 Args: event: イベントオブジェクト username: Cognitoの標準属性name userid: ユーザID user_auth: ユーザグループ（admin,referrer,updaterより選択） status: ユーザの有効（True）、無効（False）を指定 Returns: 処理結果（True／False） \u0026#34;\u0026#34;\u0026#34; try: client.admin_update_user_attributes( UserPoolId=USERPOOL_ID, Username=userid, UserAttributes=[ { \u0026#39;Name\u0026#39;: \u0026#39;name\u0026#39;, \u0026#39;Value\u0026#39;: username, }, ] ) # グループ追加 client.admin_add_user_to_group( UserPoolId=USERPOOL_ID, Username=userid, GroupName=user_auth, ) # ユーザステータス変更 if not status: client.admin_disable_user( UserPoolId=USERPOOL_ID, Username=userid, ) else: client.admin_enable_user( UserPoolId=USERPOOL_ID, Username=userid, ) except Exception: return False return True def create_random_password(number_digits): \u0026#34;\u0026#34;\u0026#34;ユーザ登録用のランダムパスワードを生成する。 Args: number_digits:パスワード桁数 Returns: 生成されたランダムパスワード（大文字英字、小文字英字、数字を必ず含む） \u0026#34;\u0026#34;\u0026#34; while True: punctuation = \u0026#39;^$*.[]{}()?-\u0026#34;!@#%\u0026amp;/\\\\,\u0026gt;\u0026lt;\\\u0026#39;:;|_~`\u0026#39; # 特殊文字の要件に\u0026#39;+=\u0026#39;が含まれていないためstring.punctuationは未使用 words = string.ascii_letters + string.digits + punctuation password = \u0026#39;\u0026#39;.join(secrets.choice(words) for i in range(number_digits)) if (any(c.isdigit() for c in password) and any(c.isupper() for c in password) and any(c.islower() for c in password) and any((c in punctuation) for c in password)): break return password def delete_disable_user(): \u0026#34;\u0026#34;\u0026#34; Cognitoで無効（Disable）状態のユーザを削除する。 Returns: 削除したユーザのリスト \u0026#34;\u0026#34;\u0026#34; def _del_user_name_list(pagination_token=None): \u0026#34;\u0026#34;\u0026#34;　Cognitoの無効ユーザーリストの再帰取得 Args: pagination_token: 前回呼び出しトークン Returns:client ユーザ情報（ユーザーID） \u0026#34;\u0026#34;\u0026#34; if pagination_token is None: response = client.list_users( UserPoolId=USERPOOL_ID, ) else: response = client.list_users( UserPoolId=USERPOOL_ID, PaginationToken=pagination_token, ) for user in response[\u0026#39;Users\u0026#39;]: if not user[\u0026#39;Enabled\u0026#39;]: yield user[\u0026#39;Username\u0026#39;] if \u0026#39;PaginationToken\u0026#39; in response: yield from _del_user_name_list(response.get(\u0026#39;PaginationToken\u0026#39;)) try: user_name_list = _del_user_name_list() for user_name in user_name_list: client.admin_delete_user( UserPoolId=USERPOOL_ID, Username=user_name, ) except Exception: raise def set_user_password(user_id, password): \u0026#34;\u0026#34;\u0026#34;Cognitoユーザーパスワードを更新する。 Args: user_id: ユーザID password: ユーザパスワード Returns: 処理結果（True／False） \u0026#34;\u0026#34;\u0026#34; try: # パスワード適用 client.admin_set_user_password( UserPoolId=USERPOOL_ID, Username=user_id, Password=password, Permanent=True, ) except Exception: return False return True def change_password(old_password, new_password, access_token): \u0026#34;\u0026#34;\u0026#34;指定されたユーザーIDのパスワードを変更する。 Args: old_password: 旧パスワード new_password: 新パスワード access_token: アクセストークン \u0026#34;\u0026#34;\u0026#34; try: client.change_password( PreviousPassword=old_password, ProposedPassword=new_password, AccessToken=access_token, ) except Exception: raise def get_group_list(): \u0026#34;\u0026#34;\u0026#34;ユーザープールに登録されているすべてのグループの名前を一覧で取得する。 Returns: グループ名（リスト） \u0026#34;\u0026#34;\u0026#34; def _group_list(next_token=None): if next_token is None: response = client.list_groups( UserPoolId=USERPOOL_ID, ) else: response = client.list_groups( UserPoolId=USERPOOL_ID, NextToken=next_token, ) for group in response[\u0026#39;Groups\u0026#39;]: yield group[\u0026#39;GroupName\u0026#39;] if response.get(\u0026#39;NextToken\u0026#39;): yield from _group_list(response.get(\u0026#39;NextToken\u0026#39;)) try: yield from _group_list() except Exception: raise 参考 https://knowstechnic.blogspot.com/2022/12/pythonaws-lambda-util.html\nhttps://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cognito-idp.html\n","permalink":"https://seiri-blog.github.io/posts/aws-lambda-common-user-operation-util-in-python/","summary":"目的 boto3 ラブライブを利用して、AWS Coginit での操作 Utitl 作成方法を共有します。 実装 # -*- coding: utf-8 -*- import secrets import string import boto3 USERPOOL_ID = \u0026#39;USERPOOL_ID\u0026#39; client = boto3.client(\u0026#39;cognito-idp\u0026#39;) def show_user_list(): \u0026#34;\u0026#34;\u0026#34;","title":"PythonでのAWS Lambda共通ユーザ操作Util"},{"content":"実装方法 Python の boto3 ライブラリを使用して AWS Step Functions を実行するには、以下の手順に従います。\n boto3 モジュールをインポートします。  import boto3 Step Functions クライアントを作成します。  sfn = boto3.client(\u0026#39;stepfunctions\u0026#39;) Step Functions の実行には、ステートマシンの ARN（Amazon Resource Name）が必要です。ステートマシンの ARN を取得するためには、AWS Step Functions コンソールでステートマシンを作成し、その ARN を確認する必要があります。 start_execution メソッドを使用してステートマシンを実行します。  # -*- coding: utf-8 -*- import boto3 sfn = boto3.client(\u0026#39;stepfunctions\u0026#39;) def execute(state_machine_arn, input_message_body): \u0026#34;\u0026#34;\u0026#34;StepFunctionsを呼び出す関数 Args: state_machine_arn: 呼び出したいStepFunctionsの名前 input_message_body: StepFunctionsを呼び出す際のメッセージ \u0026#34;\u0026#34;\u0026#34; response = sfn.start_execution( stateMachineArn=state_machine_arn, input=input_message_body, ) execution_arn = response.get(\u0026#39;executionArn\u0026#39;) print(f\u0026#39;Started Step Function execution: {execution_arn}\u0026#39;) # ステートマシンの実行結果の取得 execution_output = sfn.describe_execution( executionArn=execution_arn ) print(execution_output) # ステートマシンの実行状態の監視 while execution_output[\u0026#39;status\u0026#39;] == \u0026#39;RUNNING\u0026#39;: execution_output = sfn.describe_execution( executionArn=execution_arn ) print(f\u0026#39;Execution status: {execution_output[\u0026#34;status\u0026#34;]}\u0026#39;) 上記の例では、describe_execution メソッドを使用してステートマシンの実行結果を取得し、実行状態を監視しています。ステートマシンが実行中の場合は、status がRUNNINGとなります。\n注意点 Lambda 関数から直接 Step Functions を実行する場合、Lambda 関数の IAM ロールには適切なアクセス権限が必要です。ステートマシンの実行に必要なアクセス権限を IAM ロールに付与しておく必要があります。\n参考 https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/stepfunctions.html#SFN.Client.start_execution\n","permalink":"https://seiri-blog.github.io/posts/python-execute-stepfunction/","summary":"実装方法 Python の boto3 ライブラリを使用して AWS Step Functions を実行するには、以下の手順に従います。 boto3 モジュールをインポートします。 import boto3 Step Functions クライアントを作成しま","title":"PythonでStepFunctionを実行する方法(boto3)"},{"content":"実装方法 Python で AWS Lambda からキューにメッセージを送信するには、以下の手順に従います。\n boto3モジュールをインポートします。  import boto3 SQS (Simple Queue Service) クライアントを作成します。  sqs = boto3.client(\u0026#39;sqs\u0026#39;)  メッセージを送信するためのキューの URL を取得します。キューの URL は、AWS Management Console や AWS CLI、または AWS SDK の他のメソッドを使用して取得できます。\n  send_messageメソッドを使用してメッセージを送信します。\n  import boto3 sqs_client = boto3.client(\u0026#39;sqs\u0026#39;) def push_message(message_body): \u0026#34;\u0026#34;\u0026#34;SQSの特定キューにメッセージをPUSHする Args: message_body: PUSHするメッセージ Returns: sqsメッセージ送信時のレスポンス \u0026#34;\u0026#34;\u0026#34; queue_url = \u0026#34;https://sqs.ap-northeast-1.amazonaws.com/XXXXXXXXXXXX/my-sqs\u0026#34; response = sqs_client.send_message( QueueUrl=queue_url, MessageBody=message_body ) message_id = response[\u0026#39;MessageId\u0026#39;] print(f\u0026#39;Message sent with ID: {message_id}\u0026#39;) 上記の例では、send_message メソッドを使用してメッセージを送信しています。QueueUrl パラメータには送信先のキューの URL を指定します。MessageBody パラメータには送信するメッセージの本文を指定します。\n必要に応じて、メッセージの送信結果を取得したり、エラーハンドリングを行ったりすることができます。  import boto3 sqs_client = boto3.client(\u0026#39;sqs\u0026#39;) def push_message(message_body): \u0026#34;\u0026#34;\u0026#34;SQSの特定キューにメッセージをPUSHする Args: message_body: PUSHするメッセージ Returns: sqsメッセージ送信時のレスポンス \u0026#34;\u0026#34;\u0026#34; try: queue_url = \u0026#34;https://sqs.ap-northeast-1.amazonaws.com/XXXXXXXXXXXX/my-sqs\u0026#34; response = sqs_client.send_message( QueueUrl=queue_url, MessageBody=message_body ) message_id = response[\u0026#39;MessageId\u0026#39;] print(f\u0026#39;Message sent with ID: {message_id}\u0026#39;) except Exception as e: print(f\u0026#39;Error sending message: {str(e)}\u0026#39;) 上記の例では、send_message メソッドの呼び出しで発生した例外をキャッチして、エラーメッセージを表示しています。エラーハンドリングには、適切な方法を選択してください。\n以上の手順に従って、AWS Lambda からキューにメッセージを送信できます。送信先のキューの URL とメッセージの内容を適切に指定してください。\n参考 https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/sqs.html#SQS.Client.send_message\n","permalink":"https://seiri-blog.github.io/posts/aws-lambda-queue-send-in-python/","summary":"実装方法 Python で AWS Lambda からキューにメッセージを送信するには、以下の手順に従います。 boto3モジュールをインポートします。 import boto3 SQS (Simple Queue Service) クライアント","title":"PythonでのAWS Lambdaキュー送信"},{"content":"実装方法 以下に、Python で AWS Lambda 内で共通的に使用されるログ出力のためのユーティリティクラスの例を示します。このクラスを使用すると、Lambda 関数のログを簡単に出力することができます。\nimport logging import sys from datetime import datetime from pytz import timezone LOG_LEVEL = \u0026#39;INFO\u0026#39; class LogUtils: def __init__(self): self._logger = logging.getLogger(__name__) self._logger.setLevel(LOG_LEVEL) self._logger.propagate = False for h in self._logger.handlers: self._logger.removeHandler(h) h = logging.StreamHandler(sys.stdout) # ロガーのフォーマット指定 FORMAT = \u0026#39;%(asctime)s.%(msecs)-3d[%(request_id)s] %(levelname)s\u0026#39; datefmt = \u0026#39;%y/%m/%d%H:%M:%S\u0026#39; formatter = logging.Formatter(fmt=FORMAT, datefmt=datefmt) # ロガーの時間指定（タイムゾーンがLambda環境でもAsia/Tokyoになるようにするため） formatter.converter = this._customTime h.setFormatter(formatter) self._logger.addHandler(h) def _customTime(self, *args): \u0026#34;\u0026#34;\u0026#34;ログ用の時間出力 Returns: 現在時間（Asia/Tokyo） \u0026#34;\u0026#34;\u0026#34; return datetime.now(timezone(\u0026#39;Asia/Tokyo\u0026#39;)).timetuple() def info(self, message): \u0026#34;\u0026#34;\u0026#34;情報ログ出力 Args: message: メッセージ \u0026#34;\u0026#34;\u0026#34; self._logger.info(f\u0026#39;: {message}\u0026#39;) def warning(self, message): \u0026#34;\u0026#34;\u0026#34;警告ログ出力 Args: message: メッセージ \u0026#34;\u0026#34;\u0026#34; self._logger.warning(f\u0026#39;: {message}\u0026#39;) def error(self, message, ex=None): \u0026#34;\u0026#34;\u0026#34;エラーログ出力 Args: message: メッセージ ex: 例外オブジェクト \u0026#34;\u0026#34;\u0026#34; if ex is not None and isinstance(ex, Exception): self._logger.exception(f\u0026#39;: {message}\u0026#39;) else: self. _logger.error(f\u0026#39;: {message}\u0026#39;) def debug(self, message): \u0026#34;\u0026#34;\u0026#34;ディバグログ出力 Args: message: メッセージ \u0026#34;\u0026#34;\u0026#34; self._logger.debug(f\u0026#39;: {message}\u0026#39;) 上記の例では、LogUtils というクラスが定義されています。このクラスはログ出力の共通操作を提供します。\n__init__メソッドでは、logging モジュールを使用してルートロガーを取得し、ログレベルを設定します。この例では INFO レベルに設定していますが、必要に応じて変更してください。\n以下のメソッドが提供されています:\n info: INFO レベルのログメッセージを出力します。 warning: WARNING レベルのログメッセージを出力します。 error: ERROR レベルのログメッセージを出力します。 exception: 例外情報を含む ERROR レベルのログメッセージを出力します。 debug: DEBUG レベルのログメッセージを出力します  これらのメソッドを使用するには、Lambda 関数内でインスタンスを作成し、適切なメソッドを呼び出すことができます。\n例えば、以下のような使い方ができます:\ndef lambda_handler(event, context): logger = LogUtils() logger.info(\u0026#39;This is an informational message\u0026#39;) logger.warning(\u0026#39;This is a warning message\u0026#39;) logger.error(\u0026#39;This is an error message\u0026#39;) try: result = 1 / 0 except Exception as e: logger.exception(\u0026#39;An exception occurred\u0026#39;) 上記の例では、logger インスタンスを作成し、異なるレベルのログメッセージを出力しています。また、例外が発生した場合には exception メソッドを使用して例外情報をログ出力しています。\nログは Lambda 関数の実行結果やデバッグ情報の重要な一部であるため、適切なログ出力を行うことが推奨されます。この例のログ出力方法を基にして、必要に応じてカスタマイズや追加の操作を行ってください。\n参考 https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/python-logging.html\nhttps://docs.python.org/ja/3/howto/logging.html\n","permalink":"https://seiri-blog.github.io/posts/aws-lambda-common-logging-util-in-python/","summary":"実装方法 以下に、Python で AWS Lambda 内で共通的に使用されるログ出力のためのユーティリティクラスの例を示します。このクラスを使用すると、Lamb","title":"PythonでのAWS Lambda共通ログ出力Util"},{"content":"実装方法 Cognito User Pool を使用するためのユーティリティクラスの例を示します。このクラスは、AWS SDK の boto3 を使用して Cognito User Pool とのインタラクションを簡素化します。\nimport boto3 class CognitoUtils: def __init__(self, user_pool_id, client_id): self.user_pool_id = user_pool_id self.client_id = client_id self.cognito_client = boto3.client(\u0026#39;cognito-idp\u0026#39;) def sign_up_user(self, username, password, attributes=None): user_attributes = [ {\u0026#39;Name\u0026#39;: attr_name, \u0026#39;Value\u0026#39;: attr_value} for attr_name, attr_value in attributes.items() ] if attributes else [] response = self.cognito_client.sign_up( ClientId=self.client_id, Username=username, Password=password, UserAttributes=user_attributes ) return response def confirm_sign_up(self, username, confirmation_code): response = self.cognito_client.confirm_sign_up( ClientId=self.client_id, Username=username, ConfirmationCode=confirmation_code ) return response def initiate_auth(self, username, password): response = self.cognito_client.initiate_auth( ClientId=self.client_id, AuthFlow=\u0026#39;USER_PASSWORD_AUTH\u0026#39;, AuthParameters={ \u0026#39;USERNAME\u0026#39;: username, \u0026#39;PASSWORD\u0026#39;: password } ) return response 上記の例では、CognitoUtilsというクラスが定義されています。このクラスは Cognito User Pool との操作をラップしています。\n以下のメソッドが提供されています:\n sign_up_user: ユーザーのサインアップを行います。ユーザー名、パスワード、およびオプションの属性情報を受け取ります。 confirm_sign_up: ユーザーのサインアップ確認を行います。ユーザー名と確認コードを受け取ります。 initiate_auth: ユーザーの認証を開始します。ユーザー名とパスワードを受け取ります。  これらのメソッドを使用するには、CognitoUtils クラスのインスタンスを作成し、必要なメソッドを呼び出します。\n例えば、以下のような使い方ができます:\ndef lambda_handler(event, context): user_pool_id = \u0026#39;your-user-pool-id\u0026#39; client_id = \u0026#39;your-client-id\u0026#39; cognito_utils = CognitoUtils(user_pool_id, client_id) # ユーザーのサインアップ response = cognito_utils.sign_up_user( username=\u0026#39;user@example.com\u0026#39;, password=\u0026#39;password\u0026#39;, attributes={ \u0026#39;given_name\u0026#39;: \u0026#39;John\u0026#39;, \u0026#39;family_name\u0026#39;: \u0026#39;Doe\u0026#39; } ) # サインアップ確認 confirmation_code = \u0026#39;123456\u0026#39; confirm_response = cognito_utils.confirm_sign_up( username=\u0026#39;user@example.com\u0026#39;, confirmation_code=confirmation_code ) # ユーザーの認証 auth_response = cognito_utils.initiate 参考 https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cognito-idp.html\nhttps://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cognito-identity.html\n","permalink":"https://seiri-blog.github.io/posts/aws-lambda-common-authorization-util-in-python/","summary":"実装方法 Cognito User Pool を使用するためのユーティリティクラスの例を示します。このクラスは、AWS SDK の boto3 を使用して Cognito User Pool とのインタラクションを簡素化しま","title":"PythonでのAWS Lambda 共通認証Util"},{"content":"共通レスポンス Util 以下に、Python で AWS Lambda 内で共通的に使用されるレスポンスのためのユーティリティクラスの例を示します。このクラスを使用すると、Lambda 関数のレスポンスを簡単に作成および返却することができます。\nimport decimal import json class ResponseUtils: class DecimalEncoder(json.JSONEncoder): \u0026#34;\u0026#34;\u0026#34;DecimalEncoder クラス Decimal クラスを使用して保存された数値を出力するために使用されます(Amazon DynamoDBの数値を保持します) \u0026#34;\u0026#34;\u0026#34; def default(self, o): if isinstance(o, decimal.Decimal): if o % 1 \u0026gt; 0: return float(o) else: return int(o) return super(DecimalEncoder, self).default(o) def response_200(self, body, **kargs): \u0026#34;\u0026#34;\u0026#34;ステータス200返す Args: body: ボディー kargs: dumpsに設定する変数 Returns: ステータス: 200 \u0026#34;\u0026#34;\u0026#34; body = body or { \u0026#39;message\u0026#39;: \u0026#39;OK.\u0026#39;, } eturn self.create_response(200, body, kargs) def response_400(self, body=None, **kargs): \u0026#34;\u0026#34;\u0026#34;ステータス400返す Args: body: ボディー kargs: dumpsに設定する変数 Returns: ステータス: 400 \u0026#34;\u0026#34;\u0026#34; body = body or { \u0026#39;message\u0026#39;: \u0026#39;Bad Request.\u0026#39;, } eturn self.create_response(400, body, kargs) def response_401(self, body=None, **kargs): \u0026#34;\u0026#34;\u0026#34;ステータス401返す Args: body: ボディー kargs: dumpsに設定する変数 Returns: ステータス: 401 \u0026#34;\u0026#34;\u0026#34; body = body or { \u0026#39;message\u0026#39;: \u0026#39;Unauthorized.\u0026#39;, } eturn self.create_response(401, body, kargs) def response_403(self, body=None, **kargs): \u0026#34;\u0026#34;\u0026#34;ステータス403返す Args: body: ボディー kargs: dumpsに設定する変数 Returns: ステータス: 403 \u0026#34;\u0026#34;\u0026#34; body = body or { \u0026#39;message\u0026#39;: \u0026#39;Forbidden.\u0026#39;, } eturn self.create_response(403, body, kargs) def response_404(self, body=None, **kargs): \u0026#34;\u0026#34;\u0026#34;ステータス404返す Args: body: ボディー kargs: dumpsに設定する変数 Returns: ステータス: 404 \u0026#34;\u0026#34;\u0026#34; body = body or { \u0026#39;message\u0026#39;: \u0026#39;Not Found.\u0026#39;, } return self.create_response(404, body, kargs) def response_500(self, body=None, **kargs): \u0026#34;\u0026#34;\u0026#34;ステータス500返す Args: body: ボディー kargs: dumpsに設定する変数 Returns: ステータス: 500 \u0026#34;\u0026#34;\u0026#34; body = body or { \u0026#39;message\u0026#39;: \u0026#39;Internal Server Error.\u0026#39;, } return self.create_response(500, body, kargs) def response_503(self, body=None, **kargs): \u0026#34;\u0026#34;\u0026#34;ステータス503返す Args: body: ボディー kargs: dumpsに設定する変数 Returns: ステータス: 503 \u0026#34;\u0026#34;\u0026#34; body = body or { \u0026#39;message\u0026#39;: \u0026#39;Service Unavailable.\u0026#39;, } return self.create_response(503, body, kargs) def create_response(self, status_code, body=None, **kargs): \u0026#34;\u0026#34;\u0026#34;レスポンス返す Args: status_code: ステータスコード body: ボディー kargs: dumpsに設定する変数 Returns: レスポンス \u0026#34;\u0026#34;\u0026#34; response = { \u0026#39;statusCode\u0026#39;: status_code, \u0026#39;headers\u0026#39;: {\u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;}, \u0026#39;body\u0026#39;: body if type(body) is str else json.dumps(body, cls=DecimalEncoder, **kargs), } return response 上記の例では、ResponseUtils というクラスが定義されています。このクラスはレスポンスの共通操作を提供します。\n例えば、以下のような使い方ができます:\ndef lambda_handler(event, context): response_utils = ResponseUtils() # 成功レスポンスの作成 success_response = response_utils.response_200({\u0026#39;message\u0026#39;: \u0026#39;Success\u0026#39;}) return success_response # 失敗レスポンスの作成 error_response = response_utils.response_500({\u0026#39;error\u0026#39;: \u0026#39;Internal Server Error\u0026#39;}) return error_response 上記の例では、response_utils インスタンスを作成し、response_200とresponse_500メソッドを使用して成功および失敗のレスポンスを作成しています。\ncreate_response メソッドは、AWS Lambda のレスポンスイベントと互換性があります。したがって、このメソッドで作成されたレスポンスは、AWS Lambda から直接返されることができます。\n必要に応じて、レスポンスの形式や内容をカスタマイズできます。また、HTTP ステータスコードやボディの内容は、Lambda 関数の処理結果や要件に応じて適切に設定できます。\n参考 https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/python-handler.html\n","permalink":"https://seiri-blog.github.io/posts/aws-lambda-common-response-util-in-python/","summary":"共通レスポンス Util 以下に、Python で AWS Lambda 内で共通的に使用されるレスポンスのためのユーティリティクラスの例を示します。このクラスを使用すると","title":"PythonでのAWS Lambda共通レスポンスUtil"},{"content":"JavaScript日付フォーマット方法 JavaScript 日付フォーマット方法を紹介します。\n方法 1 JavaScript での日付フォーマットは正規表現と Date 型のgetFullYear、getMonth、getDate、getHours、getMinutesとgetSecondsメソッドで日付をフォーマットできます。\n実装例 export const dateFormat = (date, fmt = \u0026#34;YYYY/mm/dd\u0026#34;) =\u0026gt; { let ret; const opt = { \u0026#34;Y+\u0026#34;: date.getFullYear().toString(), // 年  \u0026#34;m+\u0026#34;: (date.getMonth() + 1).toString(), // 月  \u0026#34;d+\u0026#34;: date.getDate().toString(), // 日  \u0026#34;H+\u0026#34;: date.getHours().toString(), // 時  \u0026#34;M+\u0026#34;: date.getMinutes().toString(), // 分  \u0026#34;S+\u0026#34;: date.getSeconds().toString(), // 秒  }; for (let k in opt) { ret = new RegExp(\u0026#34;(\u0026#34; + k + \u0026#34;)\u0026#34;).exec(fmt); if (ret) { fmt = fmt.replace( ret[1], ret[1].length == 1 ? opt[k] : opt[k].padStart(ret[1].length, \u0026#34;0\u0026#34;) ); } } return fmt; }; 方法 2 Intl.DateTimeFormatオブジェクトを使用することで、日付フォーマットことができます。\n実装例 const date = new Date(); const dateFormat = new Intl.DateTimeFormat(\u0026#34;ja-JP\u0026#34;, { year: \u0026#34;numeric\u0026#34;, month: \u0026#34;2-digit\u0026#34;, day: \u0026#34;2-digit\u0026#34;, hour: \u0026#34;2-digit\u0026#34;, minute: \u0026#34;2-digit\u0026#34;, second: \u0026#34;2-digit\u0026#34;, }).format(date); console.log(dateFormat); 方法 3 toLocaleString()は JavaScript の Date オブジェクトに含まれるメソッドで、日付フォーマットことができます。\n実装例 //標準的な使用方法は次のようになります。 //下記により、「yyyy/mm/dd hh:mm:ss」形式の日付文字列が出力されます。 const date = new Date(); console.log(date.toLocaleString()); //また、toLocaleString()には引オプションを渡すことができます。 //下記により、「yyyy年mm月dd日」形式で日付文字列が出力されます。 const date = new Date(); console.log( date.toLocaleString(\u0026#34;ja-JP\u0026#34;, { year: \u0026#34;numeric\u0026#34;, month: \u0026#34;numeric\u0026#34;, day: \u0026#34;numeric\u0026#34;, }) ); 方法 4 toLocaleDateString()は JavaScript の Date オブジェクトに含まれるメソッドで、日付フォーマットことができます。\n実装例 //標準的な使用方法は次のようになります。 //下記により、「yyyy/mm/dd」形式の日付文字列が出力されます。 const date = new Date(); console.log(date.toLocaleDateString()); //また、toLocaleDateString()には、オプションを渡すことができます。 //下記により、「yyyy年m月dd日」形式で日付文字列が出力されます。 const date = new Date(); console.log( date.toLocaleDateString(\u0026#34;ja-JP\u0026#34;, { year: \u0026#34;numeric\u0026#34;, month: \u0026#34;long\u0026#34;, day: \u0026#34;numeric\u0026#34;, }) ); 方法 5 toLocaleTimeString()は JavaScript の Date オブジェクトに含まれるメソッドで、日付フォーマットことができます。\n実装例 //標準的な使用方法は次のようになります。 //下記により、現在のローカルのフォーマットでの時刻文字列が出力されます。 const date = new Date(); console.log(date.toLocaleTimeString()); //また、toLocaleTimeString()には、オプションを渡すことができます。 //下記により、「hh時mm分ss秒」形式で時刻文字列が出力されます。 const date = new Date(); console.log( date.toLocaleTimeString(\u0026#34;ja-JP\u0026#34;, { hour: \u0026#34;numeric\u0026#34;, minute: \u0026#34;numeric\u0026#34;, second: \u0026#34;numeric\u0026#34;, }) ); ","permalink":"https://seiri-blog.github.io/posts/js-date-format/","summary":"JavaScript日付フォーマット方法 JavaScript 日付フォーマット方法を紹介します。 方法 1 JavaScript での日付フォーマットは正規表現と Date 型のgetFullYe","title":"JavaScript日付フォーマット"},{"content":"実装例 /** * パラーメタの取得 * @param {string} name パラメータ名 * @param {string} url URL * @returns {string} 取得パラメータ */ export const getParam = (name, url) =\u0026gt; { if (!url) url = window.location.href; name = name.replace(/[\\[\\]]/g, \u0026#39;\\\\$\u0026amp;\u0026#39;); let regex = new RegExp(\u0026#39;[?\u0026amp;]\u0026#39; + name + \u0026#39;(=([^\u0026amp;#]*)|\u0026amp;|#|$)\u0026#39;), results = regex.exec(url); if (!results) return null; if (!results[2]) return \u0026#39;\u0026#39;; return decodeURIComponent(results[2].replace(/\\+/g, \u0026#39; \u0026#39;)); } #　参考文献\nhttps://www-creators.com/archives/4463\n","permalink":"https://seiri-blog.github.io/posts/js-get-url-parameter/","summary":"実装例 /** * パラーメタの取得 * @param {string} name パラメータ名 * @param {string} url URL * @returns {string} 取得パラメータ */ export const getParam = (name, url) =\u0026gt; { if (!url) url = window.location.href; name = name.replace(/[\\[\\]]/g, \u0026#39;\\\\$\u0026amp;\u0026#39;); let regex = new RegExp(\u0026#39;[?\u0026amp;]\u0026#39; + name + \u0026#39;(=([^\u0026amp;#]*)|\u0026amp;|#|$)\u0026#39;), results = regex.exec(url); if (!results)","title":"JSでのURLパラメータ取得"},{"content":"javascript でファイルサイズを変換する関数を作成するには、以下のようなコードを使用できます。 /** * ファイルサイズ変換 * @param {*} sizeInBytes バイト * @returns 変換後のサイズ */ function convertFileSize(sizeInBytes) { const units = [\u0026#34;bytes\u0026#34;, \u0026#34;KB\u0026#34;, \u0026#34;MB\u0026#34;, \u0026#34;GB\u0026#34;, \u0026#34;TB\u0026#34;]; const base = 1024; const size = Math.abs(sizeInsizeInBytesBytes); const i = size === 0 ? 0 : Math.floor(Math.log(size) / Math.log(base)); const convertedSize = parseFloat((size / Math.pow(base, i)).toFixed(2)); return convertedSize + \u0026#34; \u0026#34; + units[i]; } この関数はバイト単位のファイルサイズを受け取り、適切な単位（バイト、キロバイト、メガバイト、ギガバイト、テラバイト）に変換して返します。例えば、convertFileSize(2048)を呼び出すと、2.00 KBが返されます。\n使用例:\nconst fileSize = 3456789; const convertedSize = convertFileSize(fileSize); console.log(convertedSize); // \u0026#34;3.30 MB\u0026#34; このコードでは、sizeInBytes が負の値の場合でも正の値として処理します。また、小数点以下第 2 位までの精度でファイルサイズを表します。必要に応じてこの関数を調整して、より適切なフォーマットや単位を返すようにカスタマイズできます。\n","permalink":"https://seiri-blog.github.io/posts/js-file-size-convert/","summary":"javascript でファイルサイズを変換する関数を作成するには、以下のようなコードを使用できます。 /** * ファイルサイズ変換 * @param {*} sizeInBytes バイト * @returns 変換後のサイズ */ function","title":"JSでのファイルサイズ変換関数"},{"content":"実装例 def padding_formatter(item, padding, data_type): \u0026#34;\u0026#34;\u0026#34; 引数で指定された桁数までデータを埋める 埋める内容は以下の通り ・データ型[numeric: 数字] 先頭0埋め ・データ型[half: 半角] 後ろ半角スペース埋め ・データ型[full: 全角] 後ろ全角スペース埋め Args: item: 項目 padding: 桁数(byte数ではない) 例 全角で64byte項目の場合は「32」桁を指定 data_type: データ型[numeric: 数字, half: 半角, full: 全角] Returns: 固定長分埋めた項目 \u0026#34;\u0026#34;\u0026#34; out_item = str(item) if data_type == \u0026#39;numeric\u0026#39;: out_item = str(item).zfill(padding) elif data_type == \u0026#39;half\u0026#39;: out_item = str(item).ljust(padding, \u0026#39; \u0026#39;) elif data_type == \u0026#39;full\u0026#39;: out_item = str(item).ljust(padding, \u0026#39;　\u0026#39;) return out_item #参考文献\nhttps://note.nkmk.me/python-zero-padding/\nhttps://note.nkmk.me/python-rjust-center-ljust/\n","permalink":"https://seiri-blog.github.io/posts/python-fill-data/","summary":"実装例 def padding_formatter(item, padding, data_type): \u0026#34;\u0026#34;\u0026#34; 引数で指定された桁数までデータを埋める 埋める内容は以下の通り ・データ型[numeric: 数字] 先頭0埋め ・データ型[half","title":"Pythonでのデータ埋める方法"},{"content":"SQLAlchemy とは SQLAlchemy とは、python の中では最もよく利用されている ORM の一つです。\nORM 以外にも以下の機能を持ちます。\n 1.データベースへの接続、SQL の実行 2.メタデータ\n3.SQL Expression Language\n4.ORM\n SQLAlchemy は様々なデータベースに対して接続して SQL を実行することができます。\nサポートする DBMS は以下のとおりです。有名どころは大抵利用可能です。\n 1.Firebird\n2.Microsoft SQL Server\n3.MySQL\n4.Oracle\n5.PostgreSQL\n6.SQLite\n7.Sybase\n 環境 Windows 10\npython 3.8.10\nSQLAlchemy のインストール pip install sqlalchemy\n実装 from sqlalchemy import create_engine, event as sqlalchemy_event from sqlalchemy.orm import sessionmaker, make_transient def db_engine(): \u0026#34;\u0026#34;\u0026#34;DBセッション生成するクラスを取得する(非公開) データベースエンジンの設定情報を取得する Returns: データベースエンジンの設定情報 \u0026#34;\u0026#34;\u0026#34; # データベース名はSecretsManagerから取得前提 return create_engine( f\u0026#39;postgresql://{username}:{password}@{host}:{port}/{dbname}\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;, echo=LOG_LEVEL == \u0026#39;DEBUG\u0026#39;, # ログレベルがDEBUGの場合、発行するSQLをログ出力する ) def _session_cls(): \u0026#34;\u0026#34;\u0026#34;DBセッション生成するクラスを取得する(非公開) データベースエンジンの設定情報を取得する Returns: データベースエンジンの設定情報 \u0026#34;\u0026#34;\u0026#34; return sessionmaker( autocommit=False, autoflush=True, bind=db_engine(), ) class DBSession: \u0026#34;\u0026#34;\u0026#34;DB接続クラス 使い方)正常終了時はCommit,例外発生時はRollbackを実施する with DBSession() as new_session: new_session.query().... 使い方)Modelを定義する場合(検索) with DBSession() as new_session: for model_object in new_session.query(ModelName).order_by(ModelName.field_name): xxxx(model_object) 使い方)生のSQLを利用する場合(検索) from sqlalchemy import text stmt = text(\u0026#39;SELECT * FROM TableName WHERE xxxx = :name ORDER BY field_name\u0026#39;).columns(yyyy, zzzz) with DBSession() as new_session: for model_object in new_session.query(ModelName).from_statement(stmt).params(name=\u0026#39;hoge\u0026#39;).all(): xxxx(model_object) Args: for_update: 検索したオブジェクトに対して更新（削除）を実施するかどうかのフラグ（デフォルト：False） Attributes: session:DBセッション \u0026#34;\u0026#34;\u0026#34; def __init__(self, for_update=False): self.session = _session_cls()() if not for_update: # セッションにオブジェクトロード時（検索）のイベント処理を追加 @sqlalchemy_event.listens_for(self.session, \u0026#39;loaded_as_persistent\u0026#39;) def _object_make_transient(session, obj): # オブジェクトの永続性を初期化する make_transient(obj) def __enter__(self): return self.session def __exit__(self, exc_type, exc_val, exc_tb): if exc_type is None and exc_val is None and exc_tb is None: self.commit() else: self.rollback() def commit(self): self.session.commit() def rollback(self): self.session.rollback() 参考文献 https://knowstechnic.blogspot.com/2022/12/sqlalchemydbsession.html\nhttps://docs.sqlalchemy.org/en/14/orm/events.html\n","permalink":"https://seiri-blog.github.io/posts/python-dbsession-class/","summary":"SQLAlchemy とは SQLAlchemy とは、python の中では最もよく利用されている ORM の一つです。 ORM 以外にも以下の機能を持ちます。 1.データベースへの接続、SQL の実行","title":"PythonでのDBSessionクラス"},{"content":"実装例 export class EventEmitter { constructor() { this.registry = {}; } on(name, listener) { this.registry[name] = this.registry[name] || []; this.registry[name].push(listener); return this; } once(name, listener) { const doOnce = function () { listener.apply(null, arguments); this.removeListener(name, doOnce); }.bind(this); this.on(name, doOnce); return this; } emit(name) { const args = Array.prototype.slice.call(arguments, 1); const listeners = this.registry[name]; let count = 0; if (listeners) { listeners.forEach((listener) =\u0026gt; { count += 1; listener.apply(null, args); }); } return count \u0026gt; 0; } removeListener(name, listener) { const listeners = this.registry[name]; if (listeners) { for (let i = 0, len = listeners.length; i \u0026lt; len; i += 1) { if (listeners[i] === listener) { listeners.splice(i, 1); return this; } } } return this; } } ","permalink":"https://seiri-blog.github.io/posts/js-event-util/","summary":"実装例 export class EventEmitter { constructor() { this.registry = {}; } on(name, listener) { this.registry[name] = this.registry[name] || []; this.registry[name].push(listener); return this; } once(name, listener) { const doOnce = function () { listener.apply(null, arguments); this.removeListener(name, doOnce); }.bind(this); this.on(name, doOnce); return this; } emit(name) { const args = Array.prototype.slice.call(arguments, 1); const listeners = this.registry[name]; let count = 0; if (listeners) { listeners.forEach((listener) =\u0026gt; { count += 1; listener.apply(null, args);","title":"JSでのイベントUtil作成"},{"content":"1.説明 セッションストレージとロカールストレージ Util の作成方法を共有します。\n2.ソース /** * セッション */ export const session = { /** * セッションストレージ設定 * @param {string} key キー * @param {string} value 設定値 * @param {integer} expires 有効時間 */ set(key, value, expires) { // 有効時間はミリ秒  let params = { key, value, expires }; if (expires) { // 有効時間を追加  const data = Object.assign(params, { expiresStartTime: new Date().getTime() }); sessionStorage.setItem(key, JSON.stringify(data)); } else { if (value instanceof Object || Array.isArray(value)) { value = JSON.stringify(value); } sessionStorage.setItem(key, value); } }, /** * セッションストレージ取得 * @param {string} key キー * @returns {string} セッションストレージデータ */ get(key) { let item = sessionStorage.getItem(key); try { item = JSON.parse(item); } catch (error) { console.error(error); } // 有効期間チェック  if (item \u0026amp;\u0026amp; item.expiresStartTime) { // 失効  if (new Date().getTime() - item.expiresStartTime \u0026gt; item.expires) { sessionStorage.removeItem(key); return false; } else { return item.value; } } else { return item; } }, /** * セッションストレージ削除 * @param {string} key キー */ remove(key) { sessionStorage.removeItem(key); }, /** * セッションストレージをクリア */ clear() { sessionStorage.clear(); } } /** * ロカール */ export const local = { /** * セッションストレージ設定 * @param {string} key キー * @param {string} value 設定値 * @param {integer} expires 有効時間 */ set(key, value, expires) { // 有効時間はミリ秒  let params = { key, value, expires }; if (expires) { // 有効時間を追加  const data = Object.assign(params, { expiresStartTime: new Date().getTime() }); localStorage.setItem(key, JSON.stringify(data)); } else { if (value instanceof Object || Array.isArray(value)) { value = JSON.stringify(value); } localStorage.setItem(key, value); } }, /** * セッションストレージ取得 * @param {string} key キー * @returns {string} セッションストレージデータ */ get(key) { let item = localStorage.getItem(key); try { item = JSON.parse(item); } catch (error) { console.error(error); } // 有効期間チェック  if (item \u0026amp;\u0026amp; item.expiresStartTime) { // 失効  if (new Date().getTime() - item.expiresStartTime \u0026gt; item.expires) { localStorage.removeItem(key); return false; } else { return item.value; } } else { return item; } }, /** * セッションストレージ削除 * @param {string} key キー */ remove(key) { localStorage.removeItem(key); }, /** * セッションストレージをクリア */ clear() { localStorage.clear(); } } 3.参考 https://developer.mozilla.org/ja/docs/Web/API/Window/sessionStorage\nhttps://developer.mozilla.org/ja/docs/Web/API/Window/localStorage\n","permalink":"https://seiri-blog.github.io/posts/js-storage-util/","summary":"1.説明 セッションストレージとロカールストレージ Util の作成方法を共有します。 2.ソース /** * セッション */ export const session = { /** * セッションストレージ設定 *","title":"JSでのストレージUtil作成"},{"content":"1.目的 レスポンスクラスハンドラーの作成方法を共有します。\n2.ソース /** * リクエストの結果をハンドリングする. * @param {Promiss} promiss * @return reponse レスポンス =\u0026gt; {success: XXX, data: XXX, message: XXX} */ export const handleResponse = async(promiss) =\u0026gt; { const response = await promiss; if (response.success \u0026amp;\u0026amp; !response.error) { //成功  return { success: response.success, message: response.message, data: response.data }; } else { if (!response.error) { //警告  return { success: response.success, message: response.message, data: response.data, }; } else { //システムエラー  //システムエラーメッセージをスロー  console.error(response.message); throw new Error(response.message); } } } /** * エラーメッセージ取得 * @param error エラーオブジェクト * @return Error messages */ export const getErrorMessage = (error) =\u0026gt; { // UI API DML, Apex and network errors  if (error.body \u0026amp;\u0026amp; typeof error.body.message === \u0026#39;string\u0026#39;) { return error.body.message; } // JS errors  else if (typeof error.message === \u0026#39;string\u0026#39;) { return error.message; } // Unknown error shape so try HTTP status text  else if (error.statusText){ return error.statusText; } return \u0026#39;\u0026#39;; } ","permalink":"https://seiri-blog.github.io/posts/response-class-handler-creating-on-js/","summary":"1.目的 レスポンスクラスハンドラーの作成方法を共有します。 2.ソース /** * リクエストの結果をハンドリングする. * @param {Promiss} promiss * @return reponse レスポンス =\u0026gt; {success: XXX, data:","title":"JSでのレスポンスクラスハンドラーの作成"},{"content":"LWC での Toast メッセージ   LWC で Toast メッセージを表示するために、共通の Util クラスを作成することができます。\n  Toast メッセージのタイトル、メッセージ、種類(success, warning, error)などを指定することができます。\n  Toast メッセージを表示するために必要な import を記述する。\n  実装例 以下は、Toast メッセージを表示する共通の Util\nimport { ShowToastEvent } from \u0026#34;lightning/platformShowToastEvent\u0026#34;; /** * メッセージ表示 * @param {window} that * @param {string} title タイトール * @param {string} message メッセージ * @param {string} variant タイプ info、success、warning、error */ export const showToast = (that, title, message, variant) =\u0026gt; { const event = new ShowToastEvent({ title: title, message: message, variant: variant, }); that.dispatchEvent(event); }; /** * 情報メッセージを表示 * @param {*} that this * @param {*} message メッセージ */ export const showInfoToast = (that, message) =\u0026gt; { showToast(that, \u0026#34;Info\u0026#34;, message, \u0026#34;info\u0026#34;); }; /** * 成功メッセージを表示 * @param {*} that this * @param {*} message メッセージ */ export const showSuccessToast = (that, message) =\u0026gt; { showToast(that, \u0026#34;Success\u0026#34;, message, \u0026#34;success\u0026#34;); }; /** *エラーメッセージを表示 * @param {*} that this * @param {*} message メッセージ */ export const showErrorToast = (that, message) =\u0026gt; { showToast(that, \u0026#34;Error\u0026#34;, message, \u0026#34;error\u0026#34;); }; /** * ワーニングメッセージを表示 * @param {*} that this * @param {*} message メッセージ */ export const showWarningToast = (that, message) =\u0026gt; { showToast(that, \u0026#34;Warning\u0026#34;, message, \u0026#34;warning\u0026#34;); }; ","permalink":"https://seiri-blog.github.io/posts/salesforce-lwc-toast-message-common-util/","summary":"LWC での Toast メッセージ LWC で Toast メッセージを表示するために、共通の Util クラスを作成することができます。 Toast メッセージのタイトル、メッセージ、種類(suc","title":"【Salesforce】LWC 共通 Toast Util"},{"content":"共通モーダル画面作成方法説明   共通モーダルはモーダルを開くための API を持ち、他のコンポーネントから呼び出すことができます。\n  他のコンポーネントで、共通モーダル画面を表示するための API を呼び出します。この API は、共通モーダル画面を表示するために必要なデータを受け取ります。\n  共通モーダル画面のコンポーネントは、受け取ったデータを使用して、モーダルを表示します。\n  共通モーダル画面のコンポーネントは、モーダルを閉じるための API を持ち、他のコンポーネントから呼び出すことができます。\n  他のコンポーネントで、共通モーダル画面を閉じるための API を呼び出します。\n  実装例 構成図：\nmodal .slds-modal__content.slds-p-around_medium { text-align: center !important; } \u0026lt;template\u0026gt; \u0026lt;!--Use template if:true to display/hide popup based on isModalOpen value--\u0026gt; \u0026lt;template if:true=\u0026#34;{_isModalOpen}\u0026#34;\u0026gt; \u0026lt;!-- Modal/Popup Box LWC starts here --\u0026gt; \u0026lt;section role=\u0026#34;dialog\u0026#34; tabindex=\u0026#34;-1\u0026#34; aria-labelledby=\u0026#34;modal-heading-01\u0026#34; aria-modal=\u0026#34;true\u0026#34; class=\u0026#34;slds-modal slds-fade-in-open\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;slds-modal__container\u0026#34;\u0026gt; \u0026lt;!-- Modal/Popup Box LWC header here --\u0026gt; \u0026lt;header class=\u0026#34;slds-modal__header\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;slds-button slds-button_icon slds-modal__close slds-button_icon-inverse\u0026#34; title=\u0026#34;Close\u0026#34; onclick=\u0026#34;{closeModal}\u0026#34; \u0026gt; \u0026lt;lightning-icon icon-name=\u0026#34;utility:close\u0026#34; alternative-text=\u0026#34;close\u0026#34; variant=\u0026#34;inverse\u0026#34; size=\u0026#34;small\u0026#34; \u0026gt;\u0026lt;/lightning-icon\u0026gt; \u0026lt;span class=\u0026#34;slds-assistive-text\u0026#34;\u0026gt;Close\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;h2 class=\u0026#34;slds-text-heading_medium slds-hyphenate\u0026#34;\u0026gt;{title}\u0026lt;/h2\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;!-- Modal/Popup Box LWC body starts here --\u0026gt; \u0026lt;div class=\u0026#34;slds-modal__content slds-p-around_medium\u0026#34;\u0026gt; \u0026lt;lightning-formatted-rich-text value=\u0026#34;{content}\u0026#34; \u0026gt;\u0026lt;/lightning-formatted-rich-text\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- Modal/Popup Box LWC footer starts here --\u0026gt; \u0026lt;footer class=\u0026#34;slds-modal__footer\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;slds-button slds-button_neutral\u0026#34; onclick=\u0026#34;{closeModal}\u0026#34; \u0026gt; いいえ \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;slds-button slds-button_brand\u0026#34; onclick=\u0026#34;{confirmHandle}\u0026#34; \u0026gt; はい \u0026lt;/button\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;div class=\u0026#34;slds-backdrop slds-backdrop_open\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, track, api } from \u0026#34;lwc\u0026#34;; export default class Modal extends LightningElement { @api name; //表示フラグ  @track _isModalOpen; //タイトル  @track _title; //コンテンツ  @track _content; @api openModal() { this._isModalOpen = true; } /** * クローズ */ closeModal(e) { e.preventDefault(); this._isModalOpen = false; let changenEvent = new CustomEvent(\u0026#34;confirm\u0026#34;, { detail: false, composed: true, bubbles: true, cancelable: true, }); this.dispatchEvent(changenEvent); } /** * 「はい」ボタン押下 */ confirmHandle(e) { e.preventDefault(); this._isModalOpen = false; let changenEvent = new CustomEvent(\u0026#34;confirm\u0026#34;, { detail: true, composed: true, bubbles: true, cancelable: true, }); this.dispatchEvent(changenEvent); } @api get title() { return this._title; } set title(val) { this._title = val; } @api get content() { return this._content; } set content(val) { this._content = val; } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;false\u0026lt;/isExposed\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt; ","permalink":"https://seiri-blog.github.io/posts/lwc-common-modal/","summary":"共通モーダル画面作成方法説明 共通モーダルはモーダルを開くための API を持ち、他のコンポーネントから呼び出すことができます。 他のコンポーネントで、","title":"【Salesforce】LWCモーダル画面自分で作る"},{"content":"目的 JavaScript でブラウザを判断する方法を共有します。\n実行方法 export const isIE11 = isIE11Test(navigator); export const isChrome = isChromeTest(navigator); export const isSafari = isSafariTest(navigator); export function isIE11Test(navigator) { return /Trident.*rv[ :]*11\\./.test(navigator.userAgent); } export function isChromeTest(navigator) { return ( /Chrome/.test(navigator.userAgent) \u0026amp;\u0026amp; /Google Inc/.test(navigator.vendor) ); } export function isSafariTest(navigator) { return /^((?!chrome|android).)*safari/i.test(navigator.userAgent); } ","permalink":"https://seiri-blog.github.io/posts/js-judge-browser/","summary":"目的 JavaScript でブラウザを判断する方法を共有します。 実行方法 export const isIE11 = isIE11Test(navigator); export const isChrome = isChromeTest(navigator); export const isSafari = isSafariTest(navigator); export function isIE11Test(navigator) { return /Trident.*rv[ :]*11\\./.test(navigator.userAgent); } export function isChromeTest(navigator) { return ( /Chrome/.test(navigator.userAgent) \u0026amp;\u0026amp; /Google Inc/.test(navigator.vendor) ); } export function isSafariTest(navigator) { return /^((?!chrome|android).)*safari/i.test(navigator.userAgent); }","title":"ブラウザを判断する方法"},{"content":"Apex共通レスポンス基底クラス作成方法 LWC で Apex クラスを呼出す基底クラスを作成する方法を共有します。\nLWC で Apex クラスを呼出すときの返却値は主に正常系、警告系と異常系がありますので、\nそのパターンにより共通レスポンス基底クラスを作成します。\n実装 共通レスポンスクラスを作成します。\npublic abstract class BaseClass { /** * LWCへのレスポンス. */ public virtual class Response { //成功フラグ  @AuraEnabled public Boolean success { get; set; } //エラーフラグ  @AuraEnabled public Boolean error { get; set; } //メッセージ  @AuraEnabled public String message { get; set; } //返却データ  @AuraEnabled public Object data { get; set; } } /** * 成功時のレスポンス. */ public class SuccessResponse extends Response { /** * メッセージなしの成功レスポンス. * @param {Object} data データ */ public SuccessResponse(Object data) { this.success = true; this.error = false; this.message = null; this.data = data; } /** * メッセージ付きの成功レスポンス. * @param {Object} data データ * @param {String} message メッセージ */ public SuccessResponse(Object data, String message) { this.success = true; this.error = false; this.message = message; this.data = data; } } /** * 警告のレスポンス. */ public class WarnResponse extends Response { /** * データなしの警告レスポンス. * @param {String} message メッセージ */ public WarnResponse(String message) { this.success = false; this.error = false; this.message = message; this.data = null; } /** * データ付きの警告レスポンス. * @param {Object} data データ * @param {String} message メッセージ */ public WarnResponse(Object data, String message) { this.success = false; this.error = false; this.message = message; this.data = data; } } /** * エラーのレスポンス. */ public class ErrorResponse extends Response { /** * データなしのエラーレスポンス. * @param {String} message メッセージ */ public ErrorResponse(String message) { this.success = false; this.error = true; this.message = message; this.data = null; } /** * データ付きのエラーレスポンス. * @param {Object} data データ * @param {String} message メッセージ */ public ErrorResponse(Object data, String message) { this.success = false; this.error = true; this.message = message; this.data = data; } } } 共通レスポンス呼び出す\npublic with sharing class Demo extends BaseClass{ @AuraEnabled public static Response demoMethod(String test) { try { Integer count = [SELECT count() FROM User]; if (count \u0026gt; 0) { List\u0026lt;User\u0026gt; result = [SELECT Id, Name FROM User]; return new SuccessResponse(result, \u0026#39;検索に成功しました。\u0026#39;); } else { return new WarnResponse(\u0026#39;データが存在しません。\u0026#39;); } } catch (Exception e) { return new ErrorResponse(\u0026#39;予期せぬエラーが発生しました。システム管理者へお問い合わせください。 \u0026#39;); } } } ","permalink":"https://seiri-blog.github.io/posts/salesforce-apex-common-response-superclass/","summary":"Apex共通レスポンス基底クラス作成方法 LWC で Apex クラスを呼出す基底クラスを作成する方法を共有します。 LWC で Apex クラスを呼出すときの返却値は主に正常","title":"【Salesforce】Apex共通レスポンス基底クラス"},{"content":"実装例 /** * 配列の比較 * @param array1 配列1 * @param array2 配列2 * @returns 同じの場合：True、その他の場合：False */ export const arraysEqual = (array1, array2) =\u0026gt; { if (!array1 || !array2) { return false; } if (array1.length !== array2.length) { return false; } for (let index = 0; index \u0026lt; array1.length; index++) { if (array1[index] instanceof Array \u0026amp;\u0026amp; array2[index] instanceof Array) { if (!arraysEqual(array1[index], array2[index])) { return false; } } else if (array1[index] !== array2[index]) { return false; } } return true; } ","permalink":"https://seiri-blog.github.io/posts/js-by-array-diff/","summary":"実装例 /** * 配列の比較 * @param array1 配列1 * @param array2 配列2 * @returns 同じの場合：True、その他の場合：False */ export const arraysEqual = (array1, array2) =\u0026gt; { if (!array1 || !array2) { return false; } if (array1.length !== array2.length) { return","title":"JavaScriptで配列を比較する方法"},{"content":"実行例 /** * オブジェクトをコピー * @param obj 対象オブジェクト * @return 新しいオブジェクト */ export const deepCopy = (obj) =\u0026gt; { if (Object(obj) !== obj) { return obj; } if (obj instanceof Set) { return new Set(obj); } if (obj instanceof Date) { return new Date(obj); } if (typeof obj === \u0026#39;function\u0026#39;) { return obj.bind({}); } if (Array.isArray(obj)) { const obj2 = []; const len = obj.length; for (let i = 0; i \u0026lt; len; i++) { obj2.push(deepCopy(obj[i])); } return obj2; } const result = Object.create({}); let keys = Object.keys(obj); if (obj instanceof Error) { keys = Object.getOwnPropertyNames(obj); } const len = keys.length; for (let i = 0; i \u0026lt; len; i++) { const key = keys[i]; result[key] = deepCopy(obj[key]); } return result; } ","permalink":"https://seiri-blog.github.io/posts/js-object-copy/","summary":"実行例 /** * オブジェクトをコピー * @param obj 対象オブジェクト * @return 新しいオブジェクト */ export const deepCopy = (obj) =\u0026gt; { if (Object(obj) !== obj) { return obj; } if (obj instanceof Set) { return new Set(obj); } if (obj instanceof Date) { return new Date(obj);","title":"JavaScriptでオブジェクトをコピーする方法"},{"content":"UUID 説明 UUID（Universally Unique Identifier）は、一意の識別子を生成するための規格です。UUID は 128 ビットの値で表され、通常は 32 桁の 16 進数表記（8-4-4-4-12 の 5 つのグループに区切られた形式）で表現されます。\nUUID は、時間、ネットワークアドレス、ハードウェア情報、ランダム性などの要素を組み合わせて生成されます。そのため、理論的には同じ UUID が生成される確率は非常に低いです。\nUUID は広く使われており、様々な目的で利用されます。主な用途としては、データベースの主キーや一意の識別子として使用されることが挙げられます。UUID はグローバルに一意であるため、複数のシステムやデータベース間でのデータの一意性を確保するのに適しています。\nパッケージ使う UUID 作成方法 JavaScript で UUID を生成するためには、多くのライブラリが提供されています。例えば、uuid や uuidv4 といったライブラリがあります。これらのライブラリを使用することで、簡単に UUID を生成することができます。\n以下は、uuid ライブラリを使用して UUID を生成する JavaScript の例です：\nimport { v4 as uuidv4 } from \u0026#34;uuid\u0026#34;; const uniqueId = uuidv4(); console.log(uniqueId); パッケージ使わずに UUID 作成方法 JavaScript でパッケージを使用せずに UUID を生成する場合、以下の方法を検討することができます。\nfunction guid() { const s4 = () =\u0026gt; { return Math.floor((1 + Math.random()) * 0x10000) .toString(16) .substring(1); }; return ( s4() + s4() + \u0026#34;-\u0026#34; + s4() + \u0026#34;-\u0026#34; + s4() + \u0026#34;-\u0026#34; + s4() + \u0026#34;-\u0026#34; + s4() + s4() + s4() ); } タイムスタンプとランダムな文字列の組み合わせ:\nタイムスタンプを基にした一意の ID を生成し、ランダムな文字列を追加する方法です。\n下記の例では、現在のタイムスタンプを文字列として取得し、Math.random()を使用してランダムな文字列を生成しています。\nfunction guid() { const timestamp = new Date().getTime().toString(); // 現在のタイムスタンプ  const randomString = Math.random().toString(36).substr(2, 9); // ランダムな文字列  return timestamp + randomString; } カウンターを使用した方法:\nグローバルなカウンターを使用して連続した数値を生成する方法です。\n下記の例では、グローバルなカウンター変数をインクリメントし、数値を文字列に変換しています。\nlet counter = 0; function generateUniqueId() { counter++; return counter.toString(); } これらの方法を使用して UUID を生成することができます。ただし、パッケージを使用せずに実装する場合、生成される ID の一意性は限定的な範囲になる可能性があるため、注意が必要です。サーバーサイドでの一意性の確保や、より高度なアルゴリズムを使用することが推奨されます。\n","permalink":"https://seiri-blog.github.io/posts/generating-unique-id/","summary":"UUID 説明 UUID（Universally Unique Identifier）は、一意の識別子を生成するための規格です。UUID は 128 ビットの値で表され、通常","title":"JavaSrcriptでパッケージを使わずにUUIDを生成する方法"},{"content":"署名付き URL の説明 署名付き URL は、AWS S3（Simple Storage Service）のリソースに対して一時的なアクセス許可を付与するための URL です。通常、S3 バケット内のオブジェクト（ファイル）に対して生成されます。\n一般的な使用例は、以下のような場合です：\n ユーザーがプライベートな S3 オブジェクトに直接アクセスできるようにする場合（ダウンロード、表示など）。 S3 オブジェクトに対して一時的なアップロードポリシーを提供する場合。  署名付き URL は、AWS の認証情報（アクセスキー、シークレットアクセスキー）に基づいて生成されます。これにより、リクエストが認証され、許可された期間内に限定されます。また、HTTPS 経由でアクセスされるため、セキュアな通信が確保されます。\n署名付き URL の生成には、以下の要素が含まれます：\n リクエストの HTTP メソッド（GET、PUT、DELETE など） リクエストのヘッダー（任意） リクエストのパラメーター（任意） リソース（S3 オブジェクト）のパス アクセスキー、シークレットアクセスキー  これらの要素を使用して、署名付き URL を生成するための署名アルゴリズムが適用されます。この署名アルゴリズムは、AWS アカウントの認証情報に基づいて計算され、リクエストに付加されます。\n署名付き URL は、一時的なアクセス許可を持つため、有効期限が設定されます。有効期限が切れると、その URL は無効になります。\n生成された署名付き URL を使用すると、ユーザーは有効期限内に S3 オブジェクトにアクセスできます。これにより、AWS アクセスキーとシークレットアクセスキーを直接公開せずに、セキュアなファイルの共有や制御が可能になります。\n署名付き URL アップロード制限 AWS S3 における署名付き URL の最大アップロードサイズは、1 回の PUT リクエストでの制限に依存します。一般的に、署名付き URL を使用してアップロードするファイルのサイズには最大サイズが 5GB となっています。そのため、署名付き URL を使用してファイルをアップロードする場合も、1 つのファイルのサイズは 5GB 以下に制限されます。\n大容量のファイルを S3 にアップロードする場合、複数のパートに分割してアップロードするマルチパートアップロードという方法を使用することが一般的です。マルチパートアップロードを使用すると、大きなファイルを分割し、並行してアップロードすることができます。この場合、各パートの最小サイズは 5MB、最大サイズは 5GB となります。\nしたがって、署名付き URL を使用して S3 にファイルをアップロードする場合、1 回の PUT リクエストでの最大サイズは 5GB です。大容量のファイルをアップロードする際は、マルチパートアップロードを検討することをおすすめします。\n署名付き URL ダウンロード制限 AWS S3 の署名付き URL を使用してファイルをダウンロードする際の制限は、特定の制約はありません。ただし、以下の点に留意する必要があります。\n  有効期限: 署名付き URL には有効期限が設定されます。有効期限が切れた URL はアクセスできなくなります。有効期限は生成時に指定され、期限が切れると URL は無効になります。\n  アクセス許可: ダウンロード対象のオブジェクトに対して、アクセス許可が必要です。オブジェクトがプライベートである場合、ダウンロードするためには署名付き URL を持つユーザーに対して適切なアクセス許可が必要です。\n  ダウンロードサイズ: S3 のダウンロード制限は、署名付き URL に直接関連するものではありません。S3 のダウンロードには一般的に特定の制限はありませんが、ネットワークの帯域幅やダウンロード元・ダウンロード先の制約によって制限が発生する可能性があります。\n  署名付付き URL 発行方法 以下は、Apex で署名付き URL を生成するためのコード例です。\npublic class AwsS3Util { private static final String AMZ_ALGORITHM = \u0026#39;AWS4-HMAC-SHA256\u0026#39;; private static final String ACCESS_KEY = \u0026#39;アクセスキー\u0026#39;; private static final String SECRET_KEY = \u0026#39;シークレットキー\u0026#39;; private static final String BUCKET_NAME = \u0026#39;バケット名\u0026#39;; private static final String REGION = \u0026#39;地域\u0026#39;; private static final String EXPIRES = \u0026#39;有効時間(ms)\u0026#39;; //請求メソッド  public enum RequestMethod { GET, PUT } /** * S3の署名付きURLを生成 * @param {RequestMethod} method アップロードの場合 : PUT, ダウンロードの場合 : GET * @param {String} fileName ファイル名 * @return 署名付きURL */ public static String generateS3PreSignedURL(RequestMethod method, String fileName) { String s3key = fileName.replaceAll(\u0026#39;\\\\s+\u0026#39;, \u0026#39;\u0026#39;); Datetime currentDateTime = Datetime.now(); String dateOnly = currentDateTime.formatGmt(\u0026#39;yyyyMMdd\u0026#39;); String req = dateOnly + \u0026#39;/\u0026#39; + REGION + \u0026#39;/s3/aws4_request\u0026#39;; String xAmzCredentialStr = ACCESS_KEY + \u0026#39;/\u0026#39; + req; String xAmzDate = currentDateTime.formatGmt(\u0026#39;yyyyMMdd\\\u0026#39;T\\\u0026#39;HHmmss\\\u0026#39;Z\\\u0026#39;\u0026#39;); String xAmzSignedHeaders = \u0026#39;host\u0026#39;; String host = BUCKET_NAME + \u0026#39;.s3.\u0026#39; + REGION + \u0026#39;.amazonaws.com\u0026#39;; String canonicalRequest = method.name() + \u0026#39;\\n\u0026#39; + \u0026#39;/\u0026#39; + // UriEncode(s3key, false) +  EncodingUtil.urlEncode(s3key, \u0026#39;UTF-8\u0026#39;) + \u0026#39;\\n\u0026#39; + UriEncode(\u0026#39;X-Amz-Algorithm\u0026#39;, true) + \u0026#39;=\u0026#39; + UriEncode(AMZ_ALGORITHM, true) + \u0026#39;\u0026amp;\u0026#39; + UriEncode(\u0026#39;X-Amz-Credential\u0026#39;, true) + \u0026#39;=\u0026#39; + UriEncode(xAmzCredentialStr, true) + \u0026#39;\u0026amp;\u0026#39; + UriEncode(\u0026#39;X-Amz-Date\u0026#39;, true) + \u0026#39;=\u0026#39; + UriEncode(xAmzDate, true) + \u0026#39;\u0026amp;\u0026#39; + UriEncode(\u0026#39;X-Amz-Expires\u0026#39;, true) + \u0026#39;=\u0026#39; + UriEncode(EXPIRES, true) + \u0026#39;\u0026amp;\u0026#39; + UriEncode(\u0026#39;X-Amz-SignedHeaders\u0026#39;, true) + \u0026#39;=\u0026#39; + UriEncode(xAmzSignedHeaders, true) + \u0026#39;\\n\u0026#39; + \u0026#39;host:\u0026#39; + host + \u0026#39;\\n\\n\u0026#39; + \u0026#39;host\\n\u0026#39; + \u0026#39;UNSIGNED-PAYLOAD\u0026#39;; String stringToSign = AMZ_ALGORITHM + \u0026#39;\\n\u0026#39; + xAmzDate + \u0026#39;\\n\u0026#39; + req + \u0026#39;\\n\u0026#39; + EncodingUtil.convertToHex(Crypto.generateDigest(\u0026#39;SHA-256\u0026#39;, Blob.valueOf(canonicalRequest))); Blob dateKey = Crypto.generateMac( \u0026#39;hmacSHA256\u0026#39;, Blob.valueOf(dateOnly), Blob.valueOf(\u0026#39;AWS4\u0026#39; + SECRET_KEY)); Blob dateRegionKey = Crypto.generateMac( \u0026#39;hmacSHA256\u0026#39;, Blob.valueOf(REGION), dateKey); Blob dateRegionServiceKey = Crypto.generateMac( \u0026#39;hmacSHA256\u0026#39;, Blob.valueOf(\u0026#39;s3\u0026#39;), dateRegionKey); Blob signingKey = Crypto.generateMac( \u0026#39;hmacSHA256\u0026#39;, Blob.valueOf(\u0026#39;aws4_request\u0026#39;), dateRegionServiceKey); Blob signature = Crypto.generateMac( \u0026#39;hmacSHA256\u0026#39;, Blob.valueOf(stringToSign), signingKey); String signatureStr = EncodingUtil.convertToHex(signature); return \u0026#39;https://\u0026#39; +  host + \u0026#39;/\u0026#39; + s3key + \u0026#39;?X-Amz-Algorithm=\u0026#39; + AMZ_ALGORITHM + \u0026#39;\u0026amp;X-Amz-Credential=\u0026#39; + EncodingUtil.urlEncode(xAmzCredentialStr, \u0026#39;UTF-8\u0026#39;) + \u0026#39;\u0026amp;X-Amz-Date=\u0026#39; + xAmzDate + \u0026#39;\u0026amp;X-Amz-Expires=\u0026#39; + String.valueOf(EXPIRES) + \u0026#39;\u0026amp;X-Amz-Signature=\u0026#39; + signatureStr + \u0026#39;\u0026amp;X-Amz-SignedHeaders=host\u0026#39;; } /** * UriEncode変換 * @param {String} input * @param {Boolean} encodeSlash * @return 変換後のUriEncode */ private static String UriEncode(String input, Boolean encodeSlash) { String result = \u0026#39;\u0026#39;; for (Integer i = 0; i \u0026lt; input.length(); i++) { String ch = input.substring(i, i + 1); if ( (ch \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;Z\u0026#39;) || (ch \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;z\u0026#39;) || (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) || ch == \u0026#39;_\u0026#39; || ch == \u0026#39;-\u0026#39; || ch == \u0026#39;~\u0026#39; || ch == \u0026#39;.\u0026#39; ) { result += ch; } else if (ch == \u0026#39;/\u0026#39;) { result += encodeSlash ? \u0026#39;%2F\u0026#39; : ch; } else { String hexValue = EncodingUtil.convertToHex(Blob.valueOf(ch)) .toUpperCase(); if (hexValue.length() == 2) { result += \u0026#39;%\u0026#39; + hexValue; } else if (hexValue.length() == 4) { result += \u0026#39;%\u0026#39; + hexValue.substring(0, 2) + \u0026#39;%\u0026#39; + hexValue.substring(2); } } } return result; } } 参考 https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html##query-string-auth-v4-signing-example\nhttps://sandyghai.github.io/AWS-S3-Multipart-Upload-Using-Presigned-Url/\nhttps://mtr-design.com/news/how-to-create-a-presigned-url-for-aws-s3-using-apex\n","permalink":"https://seiri-blog.github.io/posts/apex-create-aws-s3-sign-with-url/","summary":"署名付き URL の説明 署名付き URL は、AWS S3（Simple Storage Service）のリソースに対して一時的なアクセス許可を付与するための URL です。通常、","title":"ApexでAWS S3署名付きURL発行"},{"content":"作成方法 Apex REST API コールアウトユーティリティ（Apex REST API Callouts Utility）を作成するには、以下の手順を参考にしてください。\n  Apex クラスの作成: 新しい Apex クラスを作成し、Callout ユーティリティのメソッドを含めます。例えば、「APIUtility」という名前のクラスを作成します。\n  HTTP リクエストの作成: Callout メソッドを作成して、HTTP リクエストを構築します。\n  public class APIUtility { public static HttpResponse sendGetRequest(String endpoint) { HttpRequest request = new HttpRequest(); request.setEndpoint(endpoint); request.setMethod(\u0026#39;GET\u0026#39;); // ヘッダーの設定などが必要な場合は追加してください  Http http = new Http(); HttpResponse response = http.send(request); return response; } } HTTP レスポンスの処理: レスポンスを受け取るメソッドを作成し、レスポンスを処理します。  public class APIUtility { public static HttpResponse sendGetRequest(String endpoint) { // ...  HttpResponse response = http.send(request); return response; } public static String processResponse(HttpResponse response) { if (response.getStatusCode() == 200) { return response.getBody(); } else { // エラー処理などを行う場合は追加してください  return null; } } } ユーザーコードでの使用: Callout ユーティリティを使用するために、適切なエンドポイントを指定してメソッドを呼び出します。  String endpoint = \u0026#39;https://api.example.com/data\u0026#39;; HttpResponse response = APIUtility.sendGetRequest(endpoint); String responseBody = APIUtility.processResponse(response); // responseBodyを適切に処理するコードを追加してください  上記の例では、GET リクエストの送信とレスポンスの処理を行っていますが、必要に応じて POST や PUT などの他の HTTP メソッドをサポートするメソッドを追加することもできます。\nまたヘッダーやパラメータを指定することができます。  public class APIUtility{ /**リクエストメソッド */ private enum RequestMethod { GET, POST, PUT } /** * GETリクエストを出す * @param {String} endpoint URL * @param {Map} mapHeader ヘッダー * @param {Map} mapParam パラメータ * @return {HttpResponse} レスポンス */ public static HttpResponse sendGetReqeust(String endpoint, Map\u0026lt;String, Object\u0026gt; mapHeader, Map\u0026lt;String, Object\u0026gt; mapParam) { return sendRequest(endpoint, RequestMethod.GET, mapHeader, mapParam); } /** * POSTリクエストを出す * @param {String} endpoint URL * @param {Map} mapHeader ヘッダー * @param {Map} mapParam パラメーラ * @return {HttpResponse} レスポンス */ public static HttpResponse sendPostReqeust(String endpoint, Map\u0026lt;String, Object\u0026gt; mapHeader, Map\u0026lt;String, Object\u0026gt; mapParam) { return sendRequest(endpoint, RequestMethod.POST, mapHeader, mapParam); } /** * PUTリクエストを出す * @param {String} endpoint URL * @param {Map} mapHeader ヘッダー * @param {Map} mapParam パラメータ * @return {HttpResponse} レスポンス */ public static HttpResponse sendPutReqeust(String endpoint, Map\u0026lt;String, Object\u0026gt; mapHeader, Map\u0026lt;String, Object\u0026gt; mapParam) { return sendRequest(url, RequestMethod.PUT, mapHeader, mapParam); } /** * リクエストを出す * @param url endpoint URL * @param {RequestMethod} method 請求メソッド * @param {Map} mapHeader ヘッダー * @param {Map} mapParam パラメータ * @return {HttpResponse} レスポンス */ private static HttpResponse sendRequest(String endpoint, RequestMethod method, Map\u0026lt;String, Object\u0026gt; mapHeader, Map\u0026lt;String, Object\u0026gt; mapParam) { //リクエスト作成  HttpRequest request = new HttpRequest(); if (method.equals(RequestMethod.GET)) { // パラメータ設定  List \u0026lt;String\u0026gt; paramList = new List \u0026lt;String\u0026gt;(); for (String key : mapParam.keySet()) { paramList.add(key + \u0026#39;=\u0026#39; + EncodingUtil.urlEncode(String.valueOf(mapParam.get(key)), \u0026#39;UTF-8\u0026#39;)); } if (paramList.size() \u0026gt; 0) { String param = \u0026#39;?\u0026#39; + String.join(paramList, \u0026#39;\u0026amp;\u0026#39;); url += param; } } else { String param = JSON.serialize(mapParam); request.setBody(param); } //ヘッダー設定  for (String key : mapHeader.keySet()) { request.setHeader(key, (String)mapHeader.get(key)); } //請求メソッドを設定  request.setMethod(method.name()); //エンドポイント設定  request.setEndpoint(endpoint); Http http = new Http(); HttpResponse response = http.send(request); // エラー無しの場合レスポンスを返却  return response; } /** * レスポンスのボディーを取得 * @param {HttpResponse} response 請求メソッド * @return {String} レスポンスのボディー */ public static String processResponse(HttpResponse response) { if (response.getStatusCode() == 200) { return response.getBody(); } else { // エラー処理などを行う場合は追加してください  return null; } } } 参考 https://trailhead.salesforce.com/ja/content/learn/modules/apex_integration_services/apex_integration_rest_callouts\nhttps://developer.salesforce.com/docs/atlas.ja-jp.apexcode.meta/apexcode/apex_classes_restful_http_httprequest.htm\nhttps://developer.salesforce.com/docs/atlas.ja-jp.apexcode.meta/apexcode/apex_classes_restful_http_httpresponse.htm\n","permalink":"https://seiri-blog.github.io/posts/apex-rest-api-callouts-util-creation/","summary":"作成方法 Apex REST API コールアウトユーティリティ（Apex REST API Callouts Utility）を作成するには、以下の手順を参考にしてください。 Apex クラスの作成: 新し","title":"Apex REST API コールアウトユーティリティ"},{"content":"目的 LWC でのファイルダウンロード方法を共有します。\nソース構成図 force-app └─main └─default ├─classes │ ├─GetFileDemoController │ └─GetFileDemoController.java-meta.xml └─lwc └─fileDownload  class:GetFileDemoController\n  public with sharing class GetFileDemoController { /** * ファイル一覧を取得 */ @AuraEnabled public static List\u0026lt;ContentVersion\u0026gt; getFileList(){ try { List\u0026lt;ContentVersion\u0026gt; contentVersions = [SELECT Id, Title, FileExtension, ContentSize FROM ContentVersion ]; if(contentVersions.size() \u0026gt; 0) return contentVersions; return null; } catch (Exception e) { throw new AuraHandledException(e.getMessage()); } } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;ApexClass xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;status\u0026gt;Active\u0026lt;/status\u0026gt; \u0026lt;/ApexClass\u0026gt;  LWC:fileDownload\n  \u0026lt;template\u0026gt; \u0026lt;template if:true={loading}\u0026gt; \u0026lt;lightning-spinner alternative-text=\u0026#34;Loading\u0026#34; size=\u0026#34;medium\u0026#34;\u0026gt;\u0026lt;/lightning-spinner\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;lightning-card\u0026gt; \u0026lt;div slot=\u0026#34;footer\u0026#34;\u0026gt; \u0026lt;lightning-datatable hide-checkbox-column key-field=\u0026#34;Id\u0026#34; columns={columns} data={datas} onrowaction={handleRowAction}\u0026gt; \u0026lt;/lightning-datatable\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/lightning-card\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, track } from \u0026#39;lwc\u0026#39;; import { ShowToastEvent } from \u0026#39;lightning/platformShowToastEvent\u0026#39;; import getFileList from \u0026#39;@salesforce/apex/GetFileDemoController.getFileList\u0026#39;; export default class FileZipDemo extends LightningElement { @track columns; @track datas; @track loading; /** * メッセージ表示 * @param {window} that * @param {string} title タイトール * @param {string} message メッセージ * @param {string} variant タイプ info、success、warning、error */ showToast(title, message, variant) { const event = new ShowToastEvent({ title: title, message: message, variant: variant, }); this.dispatchEvent(event); } /** * ファイルサイズ変換 * @param {*} size バイト * @returns 変換後のサイズ */ fileSizeUnit(size) { // 1 KB = 1024 Byte  const kb = 1024 const mb = Math.pow(kb, 2) const gb = Math.pow(kb, 3) const tb = Math.pow(kb, 4) const pb = Math.pow(kb, 5) const round = (size, unit) =\u0026gt; { return Math.round(size / unit * 100.0) / 100.0 } if (size \u0026gt;= pb) { return round(size, pb) + \u0026#39;PB\u0026#39; } else if (size \u0026gt;= tb) { return round(size, tb) + \u0026#39;TB\u0026#39; } else if (size \u0026gt;= gb) { return round(size, gb) + \u0026#39;GB\u0026#39; } else if (size \u0026gt;= mb) { return round(size, mb) + \u0026#39;MB\u0026#39; } else if (size \u0026gt;= kb) { return round(size, kb) + \u0026#39;KB\u0026#39; } return size + \u0026#39;バイト\u0026#39; } /** * デートフォマート * @param {Date} date date * @param {string} fmt format * @returns {string} StringDate */ dateFormat(date, fmt = \u0026#39;YYYY/mm/dd\u0026#39;) { let ret; const opt = { \u0026#39;Y+\u0026#39;: date.getFullYear().toString(), // 年  \u0026#39;m+\u0026#39;: (date.getMonth() + 1).toString(), // 月  \u0026#39;d+\u0026#39;: date.getDate().toString(), // 日  \u0026#39;H+\u0026#39;: date.getHours().toString(), // 時  \u0026#39;M+\u0026#39;: date.getMinutes().toString(), // 分  \u0026#39;S+\u0026#39;: date.getSeconds().toString() // 秒  }; for (let k in opt) { ret = new RegExp(\u0026#39;(\u0026#39; + k + \u0026#39;)\u0026#39;).exec(fmt); if (ret) { fmt = fmt.replace(ret[1], (ret[1].length == 1) ? (opt[k]) : (opt[k].padStart(ret[1].length, \u0026#39;0\u0026#39;))) }; }; return fmt; } /** * ファイルダウンロード */ async downloadFile(Id) { try { this.loading = true; window.location.href = `/sfc/servlet.shepherd/version/download/${Id}` } catch (err) { console.error(\u0026#34;Error: \u0026#34; + err); this.showToast(\u0026#39;\u0026#39;, err.body.message, \u0026#39;error\u0026#39;); } finally { this.loading = false } } /** * RowAction * @param {*} event */ async handleRowAction(event) { const action = event.detail.action; const row = event.detail.row; switch (action.name) { case \u0026#39;download\u0026#39;: await this.downloadFile(row.Id); break; default: break; } } /** * 初期化 */ async connectedCallback() { this.columns = [ { label: \u0026#39;Id\u0026#39;, fieldName: \u0026#39;Id\u0026#39;, }, { label: \u0026#39;ファイル名\u0026#39;, fieldName: \u0026#39;Title\u0026#39; }, { label: \u0026#39;拡張子\u0026#39;, fieldName: \u0026#39;FileExtension\u0026#39; }, { label: \u0026#39;ファイルサイズ\u0026#39;, fieldName: \u0026#39;ContentSize\u0026#39; }, { type: \u0026#39;action\u0026#39;, typeAttributes: { rowActions: [ { label: \u0026#39;ダウンロード\u0026#39;, name: \u0026#39;download\u0026#39; }, ], menuAlignment: \u0026#39;auto\u0026#39; } } ]; this.datas = await getFileList(); this.datas = this.datas.map((e, i) =\u0026gt; { return {...e, ContentSize: this.fileSizeUnit(e.ContentSize) } }) } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;true\u0026lt;/isExposed\u0026gt; \u0026lt;targets\u0026gt; \u0026lt;target\u0026gt;lightning__Tab\u0026lt;/target\u0026gt; \u0026lt;/targets\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt; Salesforce 側動作確認   Salesforce 側 Lightning コンポーネントタブを作成\n\n  タブを開いて、ファイルダウンロードする\n\n\n  参考 https://salesforce.stackexchange.com/questions/203030/content-document-download-url-params\nhttps://cafeforce.com/mass-attachments-documents-download-salesforce-lwc/\n","permalink":"https://seiri-blog.github.io/posts/file-download-in-lwc/","summary":"目的 LWC でのファイルダウンロード方法を共有します。 ソース構成図 force-app └─main └─default ├─classes │ ├─GetFileDemoC","title":"LWCでのファイルダウンロード"},{"content":"目的 今回 Classic モードで Visualforce に LWC のでファイル一括ダウンロードする方法を共有します。\n前提 jszip.js を静的リソースにアップロードする\n\nソース構成図 force-app └─main └─default ├─aura │　└─LWCContainer │ ├─classes │ ├─CommonHandler.java │ └─CommonHandler.java-meta.xml ├─lwc │　└─fileZipDemo │ ├─pages ├─fileZipDemo.page └─fileZipDemo.page-meta.xml  Aura:LWCContainer\n  \u0026lt;aura:application access=\u0026quot;GLOBAL\u0026quot; extends=\u0026quot;ltng:outApp\u0026quot;\u0026gt; \u0026lt;/aura:application\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;AuraDefinitionBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;50.0\u0026lt;/apiVersion\u0026gt; \u0026lt;description\u0026gt;A Lightning Application Bundle\u0026lt;/description\u0026gt; \u0026lt;/AuraDefinitionBundle\u0026gt; ({ myAction : function(component, event, helper) { } })  class:CommonHandler\n  public with sharing class CommonHandler { /** *セッションIdを取得 */ @AuraEnabled public static String getSessionId() { try{ return UserInfo.getSessionId(); } catch (Exception e) { throw new AuraHandledException(e.getMessage()); } } /** * 選択された一括ダウンロード * @param parameterJson: contentDocumentIds * @return results ダウンロード情報 */ @AuraEnabled public static List \u0026lt;Map \u0026lt;String, String\u0026gt;\u0026gt; doDownloadFile(String parameter){ List\u0026lt;Map\u0026lt;String, String\u0026gt;\u0026gt; results = new List\u0026lt;Map\u0026lt;String, String\u0026gt;\u0026gt;(); String tempalteUrl = \u0026#39;/services/data/v51.0/sobjects/ContentVersion/{0}/VersionData\u0026#39;;///sfc/servlet.shepherd/version/download/{0}  try { List\u0026lt;String\u0026gt; contentVersionIds = (List\u0026lt;String\u0026gt;) JSON.deserialize(parameter, List\u0026lt;String\u0026gt;.class); if (contentVersionIds.size() \u0026gt; 0){ List\u0026lt;ContentVersion\u0026gt; contentVersions = [SELECT Id, Title, FileExtension, ContentSize FROM ContentVersion WHERE Id IN :contentVersionIds AND IsLatest = true ]; for(ContentVersion contentVersion: contentVersions) { Map\u0026lt;String, String\u0026gt; obj = new Map\u0026lt;String, String\u0026gt;(); obj.put(\u0026#39;name\u0026#39;, contentVersion.Title + \u0026#39;.\u0026#39; + contentVersion.FileExtension); List\u0026lt;String\u0026gt; Ids = new List\u0026lt;String\u0026gt;(); Ids.add(contentVersion.Id); obj.put(\u0026#39;url\u0026#39;, String.format(tempalteUrl, Ids)); results.add(obj); } } if (results.size() \u0026gt; 0) return results; return null; } catch (Exception e) { throw new AuraHandledException(e.getMessage()); } } /** * ファイル一覧を取得 */ @AuraEnabled public static List\u0026lt;ContentVersion\u0026gt; getFileList(){ try { List\u0026lt;ContentVersion\u0026gt; contentVersions = [SELECT Id, Title, FileExtension, ContentSize FROM ContentVersion ]; if(contentVersions.size() \u0026gt; 0) return contentVersions; return null; } catch (Exception e) { throw new AuraHandledException(e.getMessage()); } } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;ApexClass xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;status\u0026gt;Active\u0026lt;/status\u0026gt; \u0026lt;/ApexClass\u0026gt;  LWC:fileZipDemo\n  \u0026lt;template\u0026gt; \u0026lt;template if:true={loading}\u0026gt; \u0026lt;lightning-spinner alternative-text=\u0026#34;Loading\u0026#34; size=\u0026#34;medium\u0026#34;\u0026gt;\u0026lt;/lightning-spinner\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;lightning-card\u0026gt; \u0026lt;div class=\u0026#34;slds-p-horizontal_small\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-form\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-form__row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-form__item\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;slds-button slds-button_brand\u0026#34; onclick={downloadFile}\u0026gt;一括ダウンロード\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div slot=\u0026#34;footer\u0026#34;\u0026gt; \u0026lt;lightning-datatable key-field=\u0026#34;Id\u0026#34; columns={columns} data={datas}\u0026gt; \u0026lt;/lightning-datatable\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/lightning-card\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, track } from \u0026#39;lwc\u0026#39;; import { ShowToastEvent } from \u0026#39;lightning/platformShowToastEvent\u0026#39;; import { loadScript } from \u0026#39;lightning/platformResourceLoader\u0026#39;; import jszip from \u0026#39;@salesforce/resourceUrl/jszip\u0026#39;; import getSessionId from \u0026#39;@salesforce/apex/CommonHandler.getSessionId\u0026#39;; import doDownloadFile from \u0026#39;@salesforce/apex/CommonHandler.doDownloadFile\u0026#39;; import getFileList from \u0026#39;@salesforce/apex/CommonHandler.getFileList\u0026#39;; const zipFileNamePrefix = \u0026#39;zipFileNamePrefix\u0026#39;; export default class FileZipDemo extends LightningElement { @track columns; @track datas; @track loading; /** * メッセージ表示 * @param {window} that * @param {string} title タイトール * @param {string} message メッセージ * @param {string} variant タイプ info、success、warning、error */ showToast(title, message, variant) { const event = new ShowToastEvent({ title: title, message: message, variant: variant, }); this.dispatchEvent(event); } /** * ファイルサイズ変換 * @param {*} size バイト * @returns 変換後のサイズ */ fileSizeUnit(size) { // 1 KB = 1024 Byte  const kb = 1024 const mb = Math.pow(kb, 2) const gb = Math.pow(kb, 3) const tb = Math.pow(kb, 4) const pb = Math.pow(kb, 5) const round = (size, unit) =\u0026gt; { return Math.round(size / unit * 100.0) / 100.0 } if (size \u0026gt;= pb) { return round(size, pb) + \u0026#39;PB\u0026#39; } else if (size \u0026gt;= tb) { return round(size, tb) + \u0026#39;TB\u0026#39; } else if (size \u0026gt;= gb) { return round(size, gb) + \u0026#39;GB\u0026#39; } else if (size \u0026gt;= mb) { return round(size, mb) + \u0026#39;MB\u0026#39; } else if (size \u0026gt;= kb) { return round(size, kb) + \u0026#39;KB\u0026#39; } return size + \u0026#39;バイト\u0026#39; } /** * デートフォマート * @param {Date} date date * @param {string} fmt format * @returns {string} StringDate */ dateFormat(date, fmt = \u0026#39;YYYY/mm/dd\u0026#39;) { let ret; const opt = { \u0026#39;Y+\u0026#39;: date.getFullYear().toString(), // 年  \u0026#39;m+\u0026#39;: (date.getMonth() + 1).toString(), // 月  \u0026#39;d+\u0026#39;: date.getDate().toString(), // 日  \u0026#39;H+\u0026#39;: date.getHours().toString(), // 時  \u0026#39;M+\u0026#39;: date.getMinutes().toString(), // 分  \u0026#39;S+\u0026#39;: date.getSeconds().toString() // 秒  }; for (let k in opt) { ret = new RegExp(\u0026#39;(\u0026#39; + k + \u0026#39;)\u0026#39;).exec(fmt); if (ret) { fmt = fmt.replace(ret[1], (ret[1].length == 1) ? (opt[k]) : (opt[k].padStart(ret[1].length, \u0026#39;0\u0026#39;))) }; }; return fmt; } /** * 添付ファイルダウンロード */ async downloadFile(e) { try { e.preventDefault(); this.loading = true; //画面選択項目のレコードIdを取得  let targets = this.template.querySelector(\u0026#39;lightning-datatable\u0026#39;).getSelectedRows(); if (targets.length \u0026gt; 0) { let targetIds = []; targets.forEach(e =\u0026gt; { targetIds.push(e.Id) }) let results = await doDownloadFile({ parameter: JSON.stringify(targetIds) }); if (results) await this.allDownload(results); else this.showToast(\u0026#39;\u0026#39;, \u0026#39;添ファイルが存在しません。\u0026#39;, \u0026#39;warning\u0026#39;); } else { this.showToast(\u0026#39;\u0026#39;, \u0026#39;ファイルを選択してください。\u0026#39;, \u0026#39;warning\u0026#39;); } } catch (err) { console.error(\u0026#34;Error: \u0026#34; + err); this.showToast(\u0026#39;\u0026#39;, err.body.message, \u0026#39;error\u0026#39;); } finally { this.loading = false } } /** * resultsにより、ファイルを一括ダウンロード * @param {*} results */ async allDownload(results) { try { let sessionId = await getSessionId(); console.time(\u0026#39;downloadtime\u0026#39;); let result = await this.getNameContentPairsFrom(results, sessionId); console.timeEnd(\u0026#39;downloadtime\u0026#39;); console.time(\u0026#39;ziptime\u0026#39;); let zipBlob = await this.generateZipBlob(result); console.timeEnd(\u0026#39;ziptime\u0026#39;); this.saveBlob(zipBlob, `${zipFileNamePrefix}${this.dateFormat(new Date(), \u0026#39;YYYYmmddHHMMSS\u0026#39;)}.zip`); } catch (e) { console.timeEnd(\u0026#39;downloadtime\u0026#39;); console.error(e); } } /** * ファイル圧縮 * @param {*} nameContentPairs */ generateZipBlob(nameContentPairs) { let zip = new JSZip(); nameContentPairs.forEach((nameContentPair) =\u0026gt; { zip.file(nameContentPair.name, nameContentPair.content); }); return zip.generateAsync({ type: \u0026#39;blob\u0026#39;, compression: \u0026#34;DEFLATE\u0026#34;, compressionOption: { level: 1 } }); }; /** * RESTAPIにリクエストを出し、ファイル情報を取得 * @param {object} results * @param {string} sessionId セッションID */ async getNameContentPairsFrom(results, sessionId) { let promises = results.map(async(result) =\u0026gt; { let name = result.name; let response = await fetch( result.url, { headers: { Authorization: `Bearer ${sessionId}`, }, }, ); let content = await response.blob(); return { name, content }; }); let pairs = []; for (let promise of promises) { pairs.push(await promise); } return pairs; }; /** * ファイル保存 * @param {*} blob ファイルの中身 * @param {*} name ファイル名 */ saveBlob(blob, name = undefined) { if (window.navigator.msSaveBlob) { if (name) window.navigator.msSaveBlob(blob, name); else window.navigator.msSaveBlob(blob); } else { let a = document.createElement(\u0026#39;a\u0026#39;); a.href = URL.createObjectURL(blob); if (name) a.download = name; a.style.display = \u0026#39;none\u0026#39;; document.body.appendChild(a); a.click(); document.body.removeChild(a); } }; /** * 初期化 */ async connectedCallback() { this.columns = [ { label: \u0026#39;Id\u0026#39;, fieldName: \u0026#39;Id\u0026#39;, }, { label: \u0026#39;ファイル名\u0026#39;, fieldName: \u0026#39;Title\u0026#39; }, { label: \u0026#39;拡張子\u0026#39;, fieldName: \u0026#39;FileExtension\u0026#39; }, { label: \u0026#39;ファイルサイズ\u0026#39;, fieldName: \u0026#39;ContentSize\u0026#39; }, ]; this.datas = await getFileList(); this.datas = this.datas.map((e, i) =\u0026gt; { return {...e, ContentSize: this.fileSizeUnit(e.ContentSize) } }) } /** * jszipロード */ renderedCallback() { if (this.jsinit) return; this.jsinit = true; Promise.all([ loadScript(this, jszip), ]) .then(() =\u0026gt; { console.log(\u0026#39;ライブラリロード成功\u0026#39;); }) .catch(error =\u0026gt; { this.showToast(\u0026#39;\u0026#39;, \u0026#39;JSライブラリロードに失敗しました\u0026#39;, \u0026#39;error\u0026#39;) }); } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;true\u0026lt;/isExposed\u0026gt; \u0026lt;targets\u0026gt; \u0026lt;target\u0026gt;lightning__Tab\u0026lt;/target\u0026gt; \u0026lt;/targets\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt;  page:FileZipDemo\n  \u0026lt;apex:page standardStylesheets=\u0026quot;false\u0026quot; sidebar=\u0026quot;false\u0026quot; applyBodyTag=\u0026quot;false\u0026quot; docType=\u0026quot;html-5.0\u0026quot;\u0026gt; \u0026lt;!-- lightning Design System --\u0026gt; \u0026lt;apex:includeLightning /\u0026gt; \u0026lt;div id=\u0026quot;lwc-container\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; $Lightning.use(\u0026quot;c:LWCContainer\u0026quot;, function () {//AuraAppContainer $Lightning.createComponent(\u0026quot;c:fileZipDemo\u0026quot;,//LWCコンポネント {},//lwcコンポネントに渡すパラメータ \u0026quot;lwc-container\u0026quot;,//divのid function (cmp) {//コールバック関数 console.log('Load Success:' + cmp); } ); }); \u0026lt;/script\u0026gt; \u0026lt;/apex:page\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;ApexPage xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;availableInTouch\u0026gt;false\u0026lt;/availableInTouch\u0026gt; \u0026lt;confirmationTokenRequired\u0026gt;false\u0026lt;/confirmationTokenRequired\u0026gt; \u0026lt;label\u0026gt;FileZipDemo\u0026lt;/label\u0026gt; \u0026lt;/ApexPage\u0026gt; Salesforce 側動作確認   Salesforce 側 Visualforce タブを作成\n\n  タブを開いて、ファイルを一括ダウンロードする\n\n\n\n  参考 https://stuk.github.io/jszip/documentation/examples.html\nhttps://stuk.github.io/jszip/documentation/examples/download-zip-file.html\nhttps://github.com/Stuk/jszip/issues/617\n","permalink":"https://seiri-blog.github.io/posts/lwc-file-bulk-download/","summary":"目的 今回 Classic モードで Visualforce に LWC のでファイル一括ダウンロードする方法を共有します。 前提 jszip.js を静的リソースにアップロードする ソース構成図 force-app └─main └","title":"LWCでのファイル一括ダウンロード方法"},{"content":"ClassモードでVFページにLWCを使う方法 Lightning Outの使用 提供されたコードはLightning Outを使用していますが、Classicモードの開発では、従来のVisualforceの方法を使用することもできます。Lightning Outを使用する理由がある場合は、それに合った方法としていますが、シンプルなファイルアップロードの場合、Visualforceページ内にフォームを作成してファイルをアップロードすることもできます。\n前提準備 LWC用のライブラリ forcetk-lwc.js を静的リソースにアップロードする\n\nファイルアップロードのためのコード force-app └─main └─default ├─aura │　└─LWCContainer │ ├─classes │ ├─CommonHandler.java │ └─CommonHandler.java-meta.xml ├─lwc │　└─lightningOutFileUpload │ ├─pages ├─LightningOutFileUpload.page └─LightningOutFileUpload.page-meta.xml  Aura:LWCContainer\n  \u0026lt;aura:application access=\u0026quot;GLOBAL\u0026quot; extends=\u0026quot;ltng:outApp\u0026quot;\u0026gt; \u0026lt;/aura:application\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;AuraDefinitionBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;50.0\u0026lt;/apiVersion\u0026gt; \u0026lt;description\u0026gt;A Lightning Application Bundle\u0026lt;/description\u0026gt; \u0026lt;/AuraDefinitionBundle\u0026gt; ({ myAction : function(component, event, helper) { } })  class:CommonHandler\n  public with sharing class CommonHandler { /** *セッションIdを取得 */ @AuraEnabled public static String getSessionId() { try{ return UserInfo.getSessionId(); } catch (Exception e) { throw new AuraHandledException(e.getMessage()); } } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;ApexClass xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;status\u0026gt;Active\u0026lt;/status\u0026gt; \u0026lt;/ApexClass\u0026gt;  lwc:lightningOutFileUpload\n  \u0026lt;template\u0026gt; \u0026lt;lightning-input type=\u0026#34;file\u0026#34; variant=\u0026#34;label-hidden\u0026#34; onchange={handleUpload} required={required} message-when-value-missing=\u0026#34;添付ファイルを選択してください。\u0026#34;\u0026gt; \u0026lt;/lightning-input\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement } from \u0026#39;lwc\u0026#39;; import { loadScript } from \u0026#39;lightning/platformResourceLoader\u0026#39;; import forcetk_lwc from \u0026#39;@salesforce/resourceUrl/forcetk_lwc\u0026#39;; import getSessionId from \u0026#39;@salesforce/apex/CommonHandler.getSessionId\u0026#39;; export default class LightningOutFileUpload extends LightningElement { /** * ファイルアップロード * @param {*} event */ handleUpload(event) { let input = event.target; if (input.files.length \u0026gt; 0) { let file = input.files[0]; this.client.createBlob(\u0026#39;ContentVersion\u0026#39;, { Origin: \u0026#39;H\u0026#39;, // \u0026#39;H\u0026#39; for Chatter File, \u0026#39;C\u0026#39; for Content Document  PathOnClient: file.name }, file.name, \u0026#39;VersionData\u0026#39;, file, (response) =\u0026gt; { console.log(response); }, (request, status, response) =\u0026gt; { console.log(status); }); } } /** * forcetk_lwcロード */ renderedCallback() { if (this.jsinit) return; this.jsinit = true; Promise.all([ loadScript(this, forcetk_lwc), ]) .then(async () =\u0026gt; { this.client = new forcetk.Client(); let sessionId = await getSessionId(); this.client.setSessionToken(sessionId); }) .catch(error =\u0026gt; { showToast(this, \u0026#39;JSライブラリロードに失敗しました\u0026#39;, error.message, \u0026#39;error\u0026#39;) }); } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;false\u0026lt;/isExposed\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt;  page:LightningOutFileUpload\n  \u0026lt;apex:page standardStylesheets=\u0026#34;false\u0026#34; sidebar=\u0026#34;false\u0026#34; applyBodyTag=\u0026#34;false\u0026#34; docType=\u0026#34;html-5.0\u0026#34;\u0026gt; \u0026lt;!-- lightning Design System --\u0026gt; \u0026lt;apex:includeLightning /\u0026gt; \u0026lt;div id=\u0026#34;lwc-container\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; $Lightning.use(\u0026#34;c:LWCContainer\u0026#34;, function () {//AuraAppContainer  $Lightning.createComponent(\u0026#34;c:lightningOutFileUpload\u0026#34;,//LWCコンポネント  {},//lwcコンポネントに渡すパラメータ  \u0026#34;lwc-container\u0026#34;,//divのid  function (cmp) {//コールバック関数  console.log(\u0026#39;Load Success:\u0026#39; + cmp); } ); }); \u0026lt;/script\u0026gt; \u0026lt;/apex:page\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;ApexPage xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;label\u0026gt;LightningOutFileUpload\u0026lt;/label\u0026gt; \u0026lt;/ApexPage\u0026gt; Salesforce 側動作確認   Salesforce 側 Visualforce タブを作成\n\n  タブを開いて、ファイルをアップロードする\n\n  アップロードしたファイル確認\n\n  ","permalink":"https://seiri-blog.github.io/posts/vfpage-lwc-file-upload/","summary":"ClassモードでVFページにLWCを使う方法 Lightning Outの使用 提供されたコードはLightning Outを使用していますが、Classicモー","title":"VFページにファイルアップロード方法"},{"content":"VF ページに LWC を表示する方法説明 基本的な考え方は VF ページに LightningOut という仕組みを利用して、LWC を表示すると思います。\nLightningOut の仕組み VF ⇒ Aura ⇒ LWCというルートで LWC の内容を表示でます。\nVF ページに$Lightning.use()と$Lightning.createComponent()を利用して、Aura コンテナを経由して、LWC コンポーネントを動的に VF ページの DOM に追加するイメージで LWC の内容を表示する。\n実装例  ソース構成図  force-app └─main └─default ├─aura │ └─LWCContainer ├─lwc │ └─lightningOutDemoComponent └─pages ├─LightningOutDemo.page └─LightningOutDemo.page-meta.xml  Aura:LWCContainer(コンテナ)  \nLWCContainer.app\n\u0026lt;aura:application access=\u0026#34;GLOBAL\u0026#34; extends=\u0026#34;ltng:outApp\u0026#34;\u0026gt; \u0026lt;/aura:application\u0026gt; LWCContainer.app-meta.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;AuraDefinitionBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;50.0\u0026lt;/apiVersion\u0026gt; \u0026lt;description\u0026gt;A Lightning Application Bundle\u0026lt;/description\u0026gt; \u0026lt;/AuraDefinitionBundle\u0026gt;  LWC:lightningOutDemoComponent  \nlightningOutDemoComponent.html\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;slds-box\u0026#34;\u0026gt; \u0026lt;p\u0026gt;ここはLightning Web Componentです。\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; lightningOutDemoComponent.js\nimport { LightningElement } from \u0026#34;lwc\u0026#34;; export default class LightningOutDemoComponent extends LightningElement {} lightningOutDemoComponent.js-meta.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;false\u0026lt;/isExposed\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt;  pages:LightningOutDemo  \nLightningOutDemo.page\n\u0026lt;apex:page standardStylesheets=\u0026#34;false\u0026#34; sidebar=\u0026#34;false\u0026#34; applyBodyTag=\u0026#34;false\u0026#34; docType=\u0026#34;html-5.0\u0026#34; \u0026gt; \u0026lt;!-- lightning Design System --\u0026gt; \u0026lt;apex:includeLightning /\u0026gt; \u0026lt;div id=\u0026#34;lwc-container\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; $Lightning.use(\u0026#34;c:LWCContainer\u0026#34;, function () { //AuraAppContainer  $Lightning.createComponent( \u0026#34;c:lightningOutDemoComponent\u0026#34;, //LWCコンポネント  {}, //lwcコンポネントに渡すパラメータ  \u0026#34;lwc-container\u0026#34;, //divのid  function (cmp) { //コールバック関数  console.log(\u0026#34;Load Success:\u0026#34; + cmp); } ); }); \u0026lt;/script\u0026gt; \u0026lt;/apex:page\u0026gt; LightningOutDemo.page-meta.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;ApexPage xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;label\u0026gt;LightningOutDemo\u0026lt;/label\u0026gt; \u0026lt;/ApexPage\u0026gt; Salesforce 側動作確認  Salesforce 側 Visualforce タブを作成  \n タブを開く  \n Classic モードで確認  \n","permalink":"https://seiri-blog.github.io/posts/salesforce-vfpage-display-lwc/","summary":"VF ページに LWC を表示する方法説明 基本的な考え方は VF ページに LightningOut という仕組みを利用して、LWC を表示すると思います。 LightningOut の仕組み VF ⇒ Aura ⇒ LWCという","title":"【Salesforce】VFページにLWCを表示する方法"},{"content":"1.目的 今回 LWC 中に AWS の SDK for javascript で S3 と連携する方法を共有します。\n2.前提  2.1.AWS S3 バケット Cross-Origin Resource Sharing (CORS)の設定  [ { \u0026#34;AllowedHeaders\u0026#34;: [\u0026#34;*\u0026#34;], \u0026#34;AllowedMethods\u0026#34;: [\u0026#34;HEAD\u0026#34;, \u0026#34;GET\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;DELETE\u0026#34;], \u0026#34;AllowedOrigins\u0026#34;: [\u0026#34;*\u0026#34;], \u0026#34;ExposeHeaders\u0026#34;: [\u0026#34;ETag\u0026#34;] } ]   2.2.Salesforce 側静的リソースに AWS の SDK をアップロードする\n\n  2.3.Salesforce 側 CSP 信頼済みサイトの設定\n\n  3.ソース構成図 lwc ├─fileuploadMock ├─fileuploadModal ├─progressbar └─utils  fileuploadMock\n  .container { background-color: #fff; min-height: 100%; } .wrapper { background-color: #cecece; overflow: scroll; width: 100%; } \u0026lt;template\u0026gt; \u0026lt;template if:true=\u0026#34;{loading}\u0026#34;\u0026gt; \u0026lt;lightning-spinner alternative-text=\u0026#34;Loading\u0026#34; size=\u0026#34;medium\u0026#34; \u0026gt;\u0026lt;/lightning-spinner\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;c-progressbar upload-file-name=\u0026#34;{uploadFileName}\u0026#34; progress=\u0026#34;{progress}\u0026#34; onabort=\u0026#34;{Abort}\u0026#34; \u0026gt; \u0026lt;/c-progressbar\u0026gt; \u0026lt;c-fileupload-modal title=\u0026#34;ファイル追加\u0026#34; onselect=\u0026#34;{uploadHandler}\u0026#34; onfolderchange=\u0026#34;{folderchangeHandler}\u0026#34; \u0026gt;\u0026lt;/c-fileupload-modal\u0026gt; \u0026lt;lightning-card\u0026gt; \u0026lt;div class=\u0026#34;slds-p-horizontal_small\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-form\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-form__row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-form__item\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;slds-button slds-button_brand\u0026#34; onclick=\u0026#34;{fileSelectorHandler}\u0026#34; \u0026gt; ファイル追加 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div slot=\u0026#34;footer\u0026#34;\u0026gt; \u0026lt;lightning-datatable hide-checkbox-column key-field=\u0026#34;key\u0026#34; columns=\u0026#34;{columns}\u0026#34; data=\u0026#34;{objectlist}\u0026#34; onrowaction=\u0026#34;{handleRowAction}\u0026#34; \u0026gt; \u0026lt;/lightning-datatable\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/lightning-card\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, track } from \u0026#34;lwc\u0026#34;; import { NavigationMixin } from \u0026#34;lightning/navigation\u0026#34;; import { loadScript } from \u0026#34;lightning/platformResourceLoader\u0026#34;; import AWS_SDK from \u0026#34;@salesforce/resourceUrl/aws_sdk\u0026#34;; import { showToast, dateFormat, fileSizeUnit } from \u0026#34;c/utils\u0026#34;; const bucketName = \u0026#34;bucket-name\u0026#34;; //バケット名 const region = \u0026#34;ap-northeast-1\u0026#34;; //地域 const accessKeyId = \u0026#34;accessKeyId \u0026#34;; //アクセスID const secretAccessKey = \u0026#34;secretAccessKey\u0026#34;; //アクセスキー  export default class FileuploadMock extends NavigationMixin(LightningElement) { //ファイル非活性  @track fileDisable; @track datas; @track objectlist = []; @track folder; @track loading; @track uploadFileName; @track progress; /** * 初期化AWS */ async initAWS() { AWS.config.update({ region: region, accessKeyId: accessKeyId, secretAccessKey: secretAccessKey, }); this.s3 = new AWS.S3({ apiVersion: \u0026#34;2006-03-01\u0026#34;, params: { Bucket: bucketName }, }); await this.listObjects(); } /** * ファイルアップロード * @param {*} event */ async uploadHandler(event) { let input = event.detail; let files = input.files; if (files.length \u0026gt; 0) { try { // let result = await this.upload(files[0]);  let result = await this.managedUpload(files[0], (progress) =\u0026gt; { this.uploadFileName = files[0].name; this.progress = Math.floor((progress.loaded / progress.total) * 100); this.template.querySelector(\u0026#34;c-progressbar\u0026#34;).open(); }); // console.log(result);  this.template.querySelector(\u0026#34;c-progressbar\u0026#34;).close(); await this.listObjects(); showToast(this, \u0026#34;\u0026#34;, \u0026#34;成功にアップロードしました\u0026#34;, \u0026#34;success\u0026#34;); } catch (err) { showToast(this, \u0026#34;\u0026#34;, err.message, \u0026#34;error\u0026#34;); console.error(\u0026#34;Error:\u0026#34;, err); } } } /** * ファイルアップロードキャンセル */ async Abort() { await this.request.abort(); } /** * ファイルダウンロード * @param {*} event */ async fileDownload(fileKey) { try { this.loading = true; await this.downloadFile(fileKey); } catch (err) { showToast(this, \u0026#34;\u0026#34;, err.message, \u0026#34;error\u0026#34;); console.error(\u0026#34;Error:\u0026#34;, err); } finally { this.loading = false; } } /** * ファイル削除 * @param {string} fileKey */ async deleteFile(fileKey) { try { this.loading = true; await this.deleteObject(fileKey); await this.listObjects(); showToast(this, \u0026#34;\u0026#34;, \u0026#34;成功に削除しました\u0026#34;, \u0026#34;success\u0026#34;); } catch (err) { showToast(this, \u0026#34;\u0026#34;, err.message, \u0026#34;error\u0026#34;); console.error(\u0026#34;Error:\u0026#34;, err); } finally { this.loading = false; } } /** * ファイルリスト取得 */ async listObjects() { let data = await this.s3.listObjects().promise(); console.log(data); this.objectlist = []; data.Contents.forEach((e) =\u0026gt; { let key = e.Key; let folder; let fileName; if (e.Size === 0) return; if (key.lastIndexOf(\u0026#34;/\u0026#34;) \u0026gt; -1) { fileName = key.substring(key.lastIndexOf(\u0026#34;/\u0026#34;) + 1, key.length); folder = \u0026#34;./\u0026#34; + key.replace(fileName, \u0026#34;\u0026#34;); } else { folder = \u0026#34;./\u0026#34;; fileName = key; } let fileType = fileName.split(\u0026#34;.\u0026#34;)[1]; this.objectlist.push({ key: key, folder: folder, fileName: fileName, fileType: fileType, LastModified: dateFormat(e.LastModified, \u0026#34;YYYY/mm/dd HH:MM:SS\u0026#34;), Owner: e.Owner.DisplayName, Size: fileSizeUnit(e.Size), StorageClass: e.StorageClass, }); }); } /** * ファイル取得処理 * @param {string} fileKey キー * @param {string} fileName ファイル名 */ async downloadFile(fileKey) { let url = await this.getSignedUrlPromise(\u0026#34;getObject\u0026#34;, { Bucket: bucketName, Key: fileKey, Expires: 1, }); console.log(url); window.location.href = url; } /** * オブジェクト取得 * @param {*} fileKey キー */ getObject(fileKey) { return this.s3.getObject({ Key: fileKey }).promise(); } /** * ファイル保存処理 * @param {File(blob)} file ファイル */ putObject(file) { const { folder } = this; let fileName = file.name; let fileKey; if (folder || folder === 0) fileKey = `${folder}/${fileName}`; else fileKey = fileName; return this.s3.putObject({ Key: fileKey, Body: file }).promise(); } /** * ファイル削除処理 * @param {string} fileKey ファイルキー */ deleteObject(fileKey) { return this.s3.deleteObject({ Key: fileKey }).promise(); } /** * ファイル保存処理(ビッグサイズ用) * @param {File(blob)} file ファイル */ upload(file) { const { folder } = this; let fileName = file.name; let fileKey; if (folder || folder === 0) fileKey = `${folder}/${fileName}`; else fileKey = fileName; return this.s3.upload({ Key: fileKey, Body: file }).promise(); } /** * URL発行 * @param {*} action アクション：getObject,putObject,deleteObject * @param {*} fileKey ファイルキー */ getSignedUrlPromise(action, params) { return this.s3.getSignedUrlPromise(action, params); } /** * マルチファイルアップロード管理 * @param {*} file */ managedUpload(file, progressCallBack) { const { folder } = this; let fileName = file.name; let fileKey; if (folder || folder === 0) fileKey = `${folder}/${fileName}`; else fileKey = fileName; this.request = new AWS.S3.ManagedUpload({ partSize: 100 * 1024 * 1024, queueSize: 1, params: { Bucket: bucketName, Key: fileKey, Body: file }, }); this.request.on(\u0026#34;httpUploadProgress\u0026#34;, (progress) =\u0026gt; { if (progressCallBack) progressCallBack(progress); else console.log( \u0026#34;progress:\u0026#34;, Math.floor((progress.loaded / progress.total) * 100) ); }); this.request.send((err, data) =\u0026gt; { if (err) console.error(err); console.info(data); }); return this.request.promise(); } /** * ファイル選択 * @param {*} event */ fileSelectorHandler(event) { event.preventDefault(); this.template.querySelector(\u0026#34;c-fileupload-modal\u0026#34;).open(); } /** * フォルダ選択 * @param {*} event */ folderchangeHandler(event) { this.folder = event.detail; } /** * RowAction * @param {*} event */ async handleRowAction(event) { const action = event.detail.action; const row = event.detail.row; switch (action.name) { case \u0026#34;download\u0026#34;: await this.fileDownload(row.key); break; case \u0026#34;delete\u0026#34;: await this.deleteFile(row.key); break; } } /** * 初期化 */ connectedCallback() { this.columns = [ { label: \u0026#34;フォルダー名\u0026#34;, fieldName: \u0026#34;folder\u0026#34; }, { label: \u0026#34;ファイル名\u0026#34;, fieldName: \u0026#34;fileName\u0026#34; }, { label: \u0026#34;タイプ\u0026#34;, fieldName: \u0026#34;fileType\u0026#34; }, { label: \u0026#34;最新更新日\u0026#34;, fieldName: \u0026#34;LastModified\u0026#34; }, { label: \u0026#34;所有者\u0026#34;, fieldName: \u0026#34;Owner\u0026#34; }, { label: \u0026#34;サイズ\u0026#34;, fieldName: \u0026#34;Size\u0026#34; }, { label: \u0026#34;ストレージクラス\u0026#34;, fieldName: \u0026#34;StorageClass\u0026#34; }, { type: \u0026#34;action\u0026#34;, typeAttributes: { rowActions: [ { label: \u0026#34;ダウンロード\u0026#34;, name: \u0026#34;download\u0026#34; }, { label: \u0026#34;削除\u0026#34;, name: \u0026#34;delete\u0026#34; }, ], menuAlignment: \u0026#34;auto\u0026#34;, }, }, ]; } /** * aws-sdkロード */ renderedCallback() { if (this.jsinit) return; this.jsinit = true; Promise.all([loadScript(this, AWS_SDK)]) .then(async () =\u0026gt; { await this.initAWS(); }) .catch((error) =\u0026gt; { showToast( this, \u0026#34;JSライブラリロードに失敗しました\u0026#34;, error.message, \u0026#34;error\u0026#34; ); }); } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;true\u0026lt;/isExposed\u0026gt; \u0026lt;targets\u0026gt; \u0026lt;target\u0026gt;lightning__Tab\u0026lt;/target\u0026gt; \u0026lt;/targets\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt;  fileuploadModal\n  \u0026lt;template\u0026gt; \u0026lt;!--Use template if:true to display/hide popup based on isModalOpen value--\u0026gt; \u0026lt;template if:true=\u0026#34;{_isModalOpen}\u0026#34;\u0026gt; \u0026lt;!-- Modal/Popup Box LWC starts here --\u0026gt; \u0026lt;section role=\u0026#34;dialog\u0026#34; tabindex=\u0026#34;-1\u0026#34; aria-modal=\u0026#34;true\u0026#34; class=\u0026#34;slds-modal slds-fade-in-open\u0026#34; style=\u0026#34;z-index:9001\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;slds-modal__container\u0026#34; style=\u0026#34;width: auto;max-width: fit-content;\u0026#34; \u0026gt; \u0026lt;!-- Modal/Popup Box LWC header here --\u0026gt; \u0026lt;header class=\u0026#34;slds-modal__header\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;slds-button slds-button_icon slds-modal__close slds-button_icon-inverse\u0026#34; title=\u0026#34;Close\u0026#34; onclick=\u0026#34;{close}\u0026#34; \u0026gt; \u0026lt;lightning-icon icon-name=\u0026#34;utility:close\u0026#34; alternative-text=\u0026#34;close\u0026#34; variant=\u0026#34;inverse\u0026#34; size=\u0026#34;small\u0026#34; \u0026gt; \u0026lt;/lightning-icon\u0026gt; \u0026lt;span class=\u0026#34;slds-assistive-text\u0026#34;\u0026gt;Close\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;h2 class=\u0026#34;slds-text-heading_medium slds-hyphenate\u0026#34;\u0026gt;{title}\u0026lt;/h2\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;!-- Modal/Popup Box LWC body starts here --\u0026gt; \u0026lt;div class=\u0026#34;slds-modal__content slds-p-around_medium\u0026#34; style=\u0026#34;height:50%\u0026#34; \u0026gt; \u0026lt;lightning-input label=\u0026#34;パス\u0026#34; name=\u0026#34;path\u0026#34; onchange=\u0026#34;{commonChange}\u0026#34; \u0026gt;\u0026lt;/lightning-input\u0026gt; \u0026lt;lightning-input type=\u0026#34;file\u0026#34; label=\u0026#34;ファイルアップロード\u0026#34; onchange=\u0026#34;{uploadHandler}\u0026#34; \u0026gt; \u0026lt;/lightning-input\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- Modal/Popup Box LWC footer starts here --\u0026gt; \u0026lt;footer class=\u0026#34;slds-modal__footer\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;slds-button slds-button_neutral\u0026#34; onclick=\u0026#34;{close}\u0026#34;\u0026gt; キャンセル \u0026lt;/button\u0026gt; \u0026lt;!-- \u0026lt;button class=\u0026#34;slds-button slds-button_brand\u0026#34; onclick={confirmHandle}\u0026gt;ファイル追加\u0026lt;/button\u0026gt; --\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;div class=\u0026#34;slds-backdrop slds-backdrop_open\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, track, api } from \u0026#34;lwc\u0026#34;; export default class FileUploadModal extends LightningElement { @api name; @track path; //表示フラグ  @track _isModalOpen; /** * 共通Change処理 * @param {*} event */ commonChange(event) { let name = event.target.name; let value = event.target.value; this[name] = value; this.dispatchEvent( new CustomEvent(\u0026#34;folderchange\u0026#34;, { detail: value, composed: true, bubbles: true, cancelable: true, }) ); } /** * ファイルアップロード * @param {*} event */ uploadHandler(event) { let changenEvent = new CustomEvent(\u0026#34;select\u0026#34;, { detail: event.target, composed: true, bubbles: true, cancelable: true, }); this.dispatchEvent(changenEvent); } /** * モーダル開く */ @api open() { this._isModalOpen = true; } /** * モーダル閉じる */ close(e) { e.preventDefault(); this._isModalOpen = false; } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;false\u0026lt;/isExposed\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt;  progressbar\n  \u0026lt;template\u0026gt; \u0026lt;template if:true=\u0026#34;{isShow}\u0026#34;\u0026gt; \u0026lt;section role=\u0026#34;dialog\u0026#34; tabindex=\u0026#34;-1\u0026#34; class=\u0026#34;slds-modal slds-fade-in-open\u0026#34; aria-modal=\u0026#34;true\u0026#34; style=\u0026#34;z-index:9002\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;slds-modal__container\u0026#34; style=\u0026#34;width: auto;max-width: 50rem;\u0026#34;\u0026gt; \u0026lt;header class=\u0026#34;slds-modal__header\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;slds-button slds-button_icon slds-modal__close slds-button_icon-inverse\u0026#34; title=\u0026#34;Close\u0026#34; onclick=\u0026#34;{cancel}\u0026#34; \u0026gt; \u0026lt;lightning-icon icon-name=\u0026#34;utility:close\u0026#34; alternative-text=\u0026#34;close\u0026#34; variant=\u0026#34;inverse\u0026#34; size=\u0026#34;small\u0026#34; \u0026gt; \u0026lt;/lightning-icon\u0026gt; \u0026lt;span class=\u0026#34;slds-assistive-text\u0026#34;\u0026gt;Close\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;h2 class=\u0026#34;slds-modal__title slds-hyphenate\u0026#34;\u0026gt; ファイルをアップロード \u0026lt;/h2\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;div class=\u0026#34;slds-modal__content slds-p-around_medium\u0026#34; style=\u0026#34;display: grid;grid-template-columns: 0.5fr 3fr 3fr 0.5fr; height: 5rem;overflow-y: hidden;\u0026#34; \u0026gt; \u0026lt;div style=\u0026#34;align-self: center;\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;slds-icon_container slds-icon-doctype-xml\u0026#34;\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;align-self: center;\u0026#34;\u0026gt; \u0026lt;span\u0026gt;{uploadFileName} \u0026lt;br /\u0026gt;\u0026lt;b\u0026gt;{progress}%\u0026lt;/b\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;slds-progress-bar slds-progress-bar_circular\u0026#34; style=\u0026#34;align-self: center;height: 0.6rem;width: 20rem;\u0026#34; \u0026gt; \u0026lt;span class=\u0026#34;slds-progress-bar__value\u0026#34; style=\u0026#34;{barStyle}\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;align-self: center;margin-left: 0.2rem;\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;{barClass}\u0026#34;\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;footer class=\u0026#34;slds-modal__footer\u0026#34;\u0026gt; \u0026lt;span style=\u0026#34;float: left;\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;button class=\u0026#34;slds-button slds-button_brand\u0026#34; onclick=\u0026#34;{cancel}\u0026#34;\u0026gt; キャンセル \u0026lt;/button\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;div class=\u0026#34;slds-backdrop slds-backdrop_open\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, track, api } from \u0026#34;lwc\u0026#34;; const bar_cancel_class = \u0026#34;slds-icon_container slds-icon_container_circle slds-icon-action-description slds-icon-standard-password\u0026#34;; const bar_success_class = \u0026#34;slds-icon_container slds-icon_container_circle slds-icon-action-description slds-icon-text-success\u0026#34;; export default class Fileupload extends LightningElement { @api uploadFileName; @api progress = 0; @track isShow; /** * ProgressBar */ get barStyle() { return `width:${this.progress}%`; } get barClass() { return this.progress \u0026gt;= 100 ? bar_success_class : bar_cancel_class; } /** * キャンセル */ cancel(e) { e.preventDefault(); this.dispatchEvent( new CustomEvent(\u0026#34;abort\u0026#34;, { detail: true, }) ); this.close(); } @api close() { this.isShow = false; } @api open() { this.isShow = true; } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;false\u0026lt;/isExposed\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt;  utils\n  import { ShowToastEvent } from \u0026#34;lightning/platformShowToastEvent\u0026#34;; /** * メッセージ表示 * @param {window} that * @param {string} title タイトール * @param {string} message メッセージ * @param {string} variant タイプ info、success、warning、error */ export const showToast = (that, title, message, variant) =\u0026gt; { const event = new ShowToastEvent({ title: title, message: message, variant: variant, }); that.dispatchEvent(event); }; /** * デートフォマート * @param {Date} date date * @param {string} fmt format * @returns {string} StringDate */ export const dateFormat = (date, fmt = \u0026#34;YYYY/mm/dd\u0026#34;) =\u0026gt; { let ret; const opt = { \u0026#34;Y+\u0026#34;: date.getFullYear().toString(), // 年  \u0026#34;m+\u0026#34;: (date.getMonth() + 1).toString(), // 月  \u0026#34;d+\u0026#34;: date.getDate().toString(), // 日  \u0026#34;H+\u0026#34;: date.getHours().toString(), // 時  \u0026#34;M+\u0026#34;: date.getMinutes().toString(), // 分  \u0026#34;S+\u0026#34;: date.getSeconds().toString(), // 秒  }; for (let k in opt) { ret = new RegExp(\u0026#34;(\u0026#34; + k + \u0026#34;)\u0026#34;).exec(fmt); if (ret) { fmt = fmt.replace( ret[1], ret[1].length == 1 ? opt[k] : opt[k].padStart(ret[1].length, \u0026#34;0\u0026#34;) ); } } return fmt; }; /** * YYYY/MM/DD ⇒ Mon Nov 27 2017 20:30:00 GMT+0900 (JST)に変換 * @param {string} dataStr stringDate * @returns {Date} Date */ export const datePrase = (dataStr) =\u0026gt; { return new Date(dataStr); }; /** * デートフォマート * @param {string} date strData * @param {string} fmt format * @returns {string} StringDate */ export const strDateFormat = (strData, fmt = \u0026#34;YYYY/mm/dd HH:MM:SS\u0026#34;) =\u0026gt; { return dateFormat(datePrase(strData), fmt); }; /** * ファイルサイズ変換 * @param {*} size バイト * @returns 変換後のサイズ */ export const fileSizeUnit = (size) =\u0026gt; { // 1 KB = 1024 Byte  const kb = 1024; const mb = Math.pow(kb, 2); const gb = Math.pow(kb, 3); const tb = Math.pow(kb, 4); const pb = Math.pow(kb, 5); const round = (size, unit) =\u0026gt; { return Math.round((size / unit) * 100.0) / 100.0; }; if (size \u0026gt;= pb) { return round(size, pb) + \u0026#34;PB\u0026#34;; } else if (size \u0026gt;= tb) { return round(size, tb) + \u0026#34;TB\u0026#34;; } else if (size \u0026gt;= gb) { return round(size, gb) + \u0026#34;GB\u0026#34;; } else if (size \u0026gt;= mb) { return round(size, mb) + \u0026#34;MB\u0026#34;; } else if (size \u0026gt;= kb) { return round(size, kb) + \u0026#34;KB\u0026#34;; } return size + \u0026#34;バイト\u0026#34;; }; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;false\u0026lt;/isExposed\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt; 4.Salesforce 側動作確認   4.1.Salesforce 側 Lightning コンポーネントタブを作成\n\n  4.2.タブを開く\n\n  4.3.ファイル追加\n\n  4.4.ファイルダウンロード\n\n  4.5.ファイル削除\n\n  5.参考 https://github.com/aws/aws-sdk-js\nhttps://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/getting-started-browser.html\nhttps://docs.aws.amazon.com/ja_jp/AmazonS3/latest/userguide/ManageCorsUsing.html\nhttps://developer.salesforce.com/docs/component-library/bundle/lightning-platform-resource-loader/documentation\nhttps://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html\n","permalink":"https://seiri-blog.github.io/posts/lwc-by-aws-3-and-operation/","summary":"1.目的 今回 LWC 中に AWS の SDK for javascript で S3 と連携する方法を共有します。 2.前提 2.1.AWS S3 バケット Cross-Origin Resource Sharing (CORS)の設定 [ { \u0026#34;AllowedHeaders\u0026#34;: [\u0026#34;*\u0026#34;], \u0026#34;AllowedMethods\u0026#34;: [\u0026#34;HEAD\u0026#34;, \u0026#34;GET\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;DELETE\u0026#34;], \u0026#34;AllowedOrigins\u0026#34;: [\u0026#34;*\u0026#34;], \u0026#34;ExposeHeaders\u0026#34;: [\u0026#34;ETag\u0026#34;] } ] 2.2.Salesforce 側","title":"LWCでAWS S3と連携する方法"},{"content":"1.目的 LWC での DatePicker の作成方法を共有します。\n2.ソース構成図 lwc ├─datePicker └─datePickerContainer  datePicker\n  .select-box { background-color: rgb(255, 255, 255); border: 1px solid rgb(192, 192, 192); border-radius: 0.25rem; transition: border 0.1s linear, background-color 0.1s linear; height: calc(1.875rem + (1px * 2)); } .select-box[disabled] { background-color: rgb(233, 234, 236); border-color: rgb(196, 198, 202); cursor: not-allowed; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } .inpS { width: 70%; margin: 0 0.5rem 0 0; text-align:center; text-align-last:center; } .error-message { color: var(--lwc-colorTextError, rgb(194, 57, 52)); } .select-has-error { background-color: var(--lwc-colorBackgroundInput, rgb(255, 255, 255)); border-color: var(--lwc-colorBorderError, rgb(194, 57, 52)); box-shadow: var(--lwc-colorBorderError, rgb(194, 57, 52)) 0 0 0 var(--lwc-borderWidthThin, 1px) inset; background-clip: padding-box; } \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;slds-form-element\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;slds-form-element__label\u0026#34; data-id=\u0026#34;label\u0026#34;\u0026gt;{label}\u0026lt;/label\u0026gt; \u0026lt;div class=\u0026#34;slds-form-element__control\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-grid slds-form_horizontal\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-col slds-col slds-size_1-of-3 slds-small-size_1-of-3 slds-medium-size_1-of-3\u0026#34;\u0026gt; \u0026lt;select class=\u0026#34;select-box inpS\u0026#34; data-id=\u0026#34;year\u0026#34; disabled={getdisable} onchange={yearBoxChange} required={getRequired}\u0026gt; \u0026lt;/select\u0026gt; 年 \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;slds-col slds-col slds-size_1-of-3 slds-small-size_1-of-3 slds-medium-size_1-of-3\u0026#34;\u0026gt; \u0026lt;select class=\u0026#34;select-box inpS\u0026#34; data-id=\u0026#34;month\u0026#34; disabled={getdisable} onchange={monthBoxChange} required={getRequired}\u0026gt; \u0026lt;/select\u0026gt; 月 \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;slds-col slds-col slds-size_1-of-3 slds-small-size_1-of-3 slds-medium-size_1-of-3\u0026#34;\u0026gt; \u0026lt;select class=\u0026#34;select-box inpS\u0026#34; data-id=\u0026#34;day\u0026#34; disabled={getdisable} onchange={dateBoxChange} required={getRequired}\u0026gt; \u0026lt;/select\u0026gt; 日 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div data-help-message=\u0026#34;true\u0026#34; role=\u0026#34;alert\u0026#34; class=\u0026#34;error-message\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, api, track } from \u0026#39;lwc\u0026#39;; export default class datePicker extends LightningElement { //開始年  @api startYear = 1901; //ラベル  @api label; //可用  @api disabled = false; //必須  @api required = false; //年  @track yearVal; //月  @track monthVal; //日  @track dayVal; //yearElement  yearBox; //monthElement  monthBox; //dateElement  dateBox; // 日付データ  today = new Date(); thisYear = this.today.getFullYear(); thisMonth = this.today.getMonth() + 1; thisDate = this.today.getDate(); datesOfYear = [31, this.countDatesOfFeb(this.thisYear), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; /** * 年月日の取得 * @return {string} YYYY/MM/DD */ @api get ymdval() { this.yearVal = this.yearBox.childNodes[this.yearBox.selectedIndex].value; this.monthVal = this.monthBox.childNodes[this.monthBox.selectedIndex].value; this.dayVal = this.dateBox.childNodes[this.dateBox.selectedIndex].value; let ymd = `${this.yearVal}/${this.monthVal}/${this.dayVal}`; if(ymd.length === 10) return ymd; return \u0026#39;\u0026#39;; } /** * 年月日の設定 * @param {string} val YYYY/MM/DDまたはYYYY-MM-DD */ set ymdval(val) { if (val \u0026amp;\u0026amp; val.length === 10) { this.yearVal = val.substring(0, 4); this.monthVal = val.substring(5, 7); this.dayVal = val.substring(8, 10); } else { this.yearVal = \u0026#39;\u0026#39;; this.monthVal = \u0026#39;\u0026#39;; this.dayVal = \u0026#39;\u0026#39;; } if (this.yearVal \u0026amp;\u0026amp; this.monthVal \u0026amp;\u0026amp; this.dayVal \u0026amp;\u0026amp; this.yearBox \u0026amp;\u0026amp; this.monthBox \u0026amp;\u0026amp; this.dateBox) { this.yearBox.innerHTML = \u0026#39;\u0026#39;;//年クリア  this.monthBox.innerHTML = \u0026#39;\u0026#39;;//月クリア  this.dateBox.innerHTML = \u0026#39;\u0026#39;;//日クリア  this.datesOfYear = [31, this.countDatesOfFeb(this.yearVal), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; this.createOption(this.yearBox, this.startYear, this.thisYear, this.yearVal);//年の設定  this.createOption(this.monthBox, 1, 12, this.monthVal);//月の設定  this.createOption(this.dateBox, 1, this.datesOfYear[this.monthVal - 1], this.dayVal);//日の設定  } } /** * 可用 */ get getdisable() { return this.disabled === \u0026#39;true\u0026#39; || this.disabled === true; } /** * 必須 */ get getRequired() { return this.required === \u0026#39;true\u0026#39; || this.required === true; } /** * 親から初期化 */ renderedCallback() { // console.log(\u0026#39;\u0026lt;=======DatePickerDebug=========\u0026gt;\u0026#39;);  this.yearBox = this.template.querySelector(\u0026#39;select[data-id=\u0026#34;year\u0026#34;]\u0026#39;); this.monthBox = this.template.querySelector(\u0026#39;select[data-id=\u0026#34;month\u0026#34;]\u0026#39;); this.dateBox = this.template.querySelector(\u0026#39;select[data-id=\u0026#34;day\u0026#34;]\u0026#39;); // 初期値を設定  if (!(this.yearBox.innerHTML \u0026amp;\u0026amp; this.monthBox.innerHTML \u0026amp;\u0026amp; this.dateBox.innerHTML)){ this.createOption(this.yearBox, this.startYear, this.thisYear, this.yearVal);//年の設定  this.createOption(this.monthBox, 1, 12, this.monthVal);//月の設定  this.createOption(this.dateBox, 1, this.datesOfYear[this.monthVal - 1], this.dayVal);//日の設定  } let labelElement = this.template.querySelector(\u0026#39;label[data-id=\u0026#34;label\u0026#34;]\u0026#39;); if (this.required === \u0026#39;true\u0026#39; || this.required === true) { labelElement.innerHTML = `\u0026lt;abbr lightning-input_input=\u0026#34;\u0026#34; title=\u0026#34;必須\u0026#34; class=\u0026#34;slds-required\u0026#34;\u0026gt;*\u0026lt;/abbr\u0026gt; ${this.label}`; }else{ labelElement.innerHTML = this.label; } } // 年イベント  yearBoxChange(e) { // this.monthBox.innerHTML = \u0026#39;\u0026#39;;//月クリア  this.yearVal = e.target.value; this.monthVal = this.monthBox.childNodes[this.monthBox.selectedIndex].value; this.dayVal = this.dateBox.childNodes[this.dateBox.selectedIndex].value; this.datesOfYear = [31, this.countDatesOfFeb(this.yearVal), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // this.createOption(this.monthBox, 1, 12, this.monthVal);  this.dateBox.innerHTML = \u0026#39;\u0026#39;;//日クリア  this.createOption(this.dateBox, 1, this.datesOfYear[this.monthVal ? this.monthVal - 1 : this.thisMonth -1], this.dayVal); const changenEvent = new CustomEvent(\u0026#39;change\u0026#39;, { detail: this.ymdval }); this.dispatchEvent(changenEvent); this.checkValidity(); } // 月イベント  monthBoxChange(e) { this.monthVal = e.target.value; this.yearVal = this.yearBox.childNodes[this.yearBox.selectedIndex].value; this.dayVal = this.dateBox.childNodes[this.dateBox.selectedIndex].value; this.dateBox.innerHTML = \u0026#39;\u0026#39;;//日クリア  this.createOption(this.dateBox, 1, this.datesOfYear[this.monthVal ? this.monthVal - 1 : this.thisMonth -1], this.dayVal); const changenEvent = new CustomEvent(\u0026#39;change\u0026#39;, { detail: this.ymdval }); this.dispatchEvent(changenEvent); this.checkValidity(); } // 日イベント  dateBoxChange(e) { this.dayVal = e.target.value; const changenEvent = new CustomEvent(\u0026#39;change\u0026#39;, { detail: this.ymdval }); this.dispatchEvent(changenEvent); this.checkValidity(); } // ライブラリ  /** * 任意の年が閏年であるかをチェックする * @param {number} year チェックしたい西暦年号 * @return {boolean} 閏年であるかを示す真偽値 */ isLeapYear(year) { return (year % 4 === 0) \u0026amp;\u0026amp; (year % 100 !== 0) || (year % 400 === 0); } /** * 任意の年の2月の日数を数える * @param {number} year チェックしたい西暦年号 * @return {number} その年の2月の日数 */ countDatesOfFeb(year) { return this.isLeapYear(year) ? 29 : 28; } /** * セレクトボックスの中にオプションを生成する * @param {string} dom セレクトボックスのDOMのid属性値 * @param {number} startNum オプションを生成する最初の数値 * @param {number} endNum オプションを生成する最後の数値 * @param {string} current 現在の日付にマッチする数値 */ createOption(dom, startNum, endNum, current) { let blankOption = document.createElement(\u0026#39;option\u0026#39;); dom.appendChild(blankOption); for (let j = startNum; j \u0026lt;= endNum; j++) { let option = document.createElement(\u0026#39;option\u0026#39;); if (j === Number(current)) { option.value = this.paddingFormat(j); option.innerHTML = this.paddingFormat(j); option.selected = true; } else { option.value = this.paddingFormat(j); option.innerHTML = this.paddingFormat(j); } dom.appendChild(option); } } /** * ゼロ埋まる * @param {string} i */ paddingFormat(i) { if (i.toString().length \u0026lt; 2) return \u0026#39;0\u0026#39; + i; return i; } /** * チェック結果 */ @api checkValidity() { let validity = true; let className = \u0026#39;select-has-error\u0026#39;; let errorbar = this.template.querySelector(\u0026#39;div[class = \u0026#34;error-message\u0026#34;]\u0026#39;); if (!this.disabled \u0026amp;\u0026amp; this.required \u0026amp;\u0026amp; (!this.ymdval || this.ymdval.length != 10)) { errorbar.innerHTML = \u0026#39;この項目を選択してください。\u0026#39; this.yearBox.classList.add(className); this.monthBox.classList.add(className); this.dateBox.classList.add(className); validity = false; } else { errorbar.innerHTML = \u0026#39;\u0026#39;; this.yearBox.classList.remove(className); this.monthBox.classList.remove(className); this.dateBox.classList.remove(className); validity = true; } return validity; } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;false\u0026lt;/isExposed\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt;  datePickerContainer\n  \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;slds-card\u0026#34; style=\u0026#34;height:500px;width:1200px;\u0026#34;\u0026gt; \u0026lt;div\u0026gt;{dateStr}\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;slds-col slds-size_3-of-12\u0026#34;\u0026gt; \u0026lt;c-date-picker label=\u0026#34;年月日：\u0026#34; required={required} onchange={dateChange}\u0026gt;\u0026lt;/c-date-picker\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;lightning-button label=\u0026#34;内容チェック\u0026#34; onclick={dateCheckHandler}\u0026gt;\u0026lt;/lightning-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, track } from \u0026#39;lwc\u0026#39;; export default class DatePickerContainer extends LightningElement { @track dateStr; @track required = true; /** * 日付選択 * @param {*} e */ dateChange(e) { e.preventDefault(); this.dateStr = e.detail; } /** * 日付チェック * @param {*} e */ dateCheckHandler(e) { e.preventDefault(); [...this.template.querySelectorAll(\u0026#39;c-date-picker\u0026#39;)].reduce((previousValue, currentValue) =\u0026gt; { return previousValue \u0026amp;\u0026amp; currentValue.checkValidity(); }, true) } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;false\u0026lt;/isExposed\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt; 3.ロカールで動作確認 datePickerContainer 中に右クリックし、SFDX:Preview Component Locallyを押下する\n\nUse Desktop Browserを選択する\n\nサーバを立ち上げて、ブラウザを自動的に開く\n\n","permalink":"https://seiri-blog.github.io/posts/lwc-custom-datepicker/","summary":"1.目的 LWC での DatePicker の作成方法を共有します。 2.ソース構成図 lwc ├─datePicker └─datePickerContainer datePicker .select-box { background-color: rgb(255, 255, 255); border:","title":"LWCでのDatePicker自分で作る"},{"content":"1.目的 今回 LWC での共通 Util の作成方法を共有します。\n2.ソース構成図 lwc ├─commonUtil └─commonUtilChild  commonUtil\n  /** * デートフォマート * @param {Date} date date * @param {string} fmt format * @returns {string} StringDate */ export const dateFormat = (date, fmt = \u0026#39;YYYY/mm/dd\u0026#39;) =\u0026gt; { let ret; const opt = { \u0026#39;Y+\u0026#39;: date.getFullYear().toString(), // 年  \u0026#39;m+\u0026#39;: (date.getMonth() + 1).toString(), // 月  \u0026#39;d+\u0026#39;: date.getDate().toString(), // 日  \u0026#39;H+\u0026#39;: date.getHours().toString(), // 時  \u0026#39;M+\u0026#39;: date.getMinutes().toString(), // 分  \u0026#39;S+\u0026#39;: date.getSeconds().toString() // 秒  }; for (let k in opt) { ret = new RegExp(\u0026#39;(\u0026#39; + k + \u0026#39;)\u0026#39;).exec(fmt); if (ret) { fmt = fmt.replace(ret[1], (ret[1].length == 1) ? (opt[k]) : (opt[k].padStart(ret[1].length, \u0026#39;0\u0026#39;))) }; }; return fmt; } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;false\u0026lt;/isExposed\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt;  commonUtilChild\n  \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;slds-card\u0026#34; style=\u0026#34;height:500px;width:1200px\u0026#34;\u0026gt;{dateStr}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, track } from \u0026#39;lwc\u0026#39;; import { dateFormat } from \u0026#39;c/commonUtil\u0026#39;; export default class CommonUtilChild extends LightningElement { @track dateStr; connectedCallback() { this.timer = setInterval(() =\u0026gt; { this.dateStr = dateFormat(new Date(), \u0026#39;YYYY/mm/dd HH:MM:SS\u0026#39;); }) } disconnectedCallback() { clearInterval(this.timer); } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;false\u0026lt;/isExposed\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt; 3.ロカールで動作確認 commonUtilChild 中に右クリックし、SFDX:Preview Component Locallyを押下する\n\nUse Desktop Browserを選択する\n\nサーバを立ち上げて、ブラウザを自動的に開く\n\n","permalink":"https://seiri-blog.github.io/posts/lwc-common-util/","summary":"1.目的 今回 LWC での共通 Util の作成方法を共有します。 2.ソース構成図 lwc ├─commonUtil └─commonUtilChild commonUtil /** * デートフォ","title":"LWCでの共通Util自分で作る"},{"content":"LWC 共通 CSS 方法説明   スタイルシートを使用して共通の CSS を定義し、それを複数のコンポーネントでインポートします。\n  CSS をグローバルに定義し、それをすべてのコンポーネントで使用します。\n  コンポーネントのスコープ内に CSS を定義し、それをそのコンポーネント内でのみ使用します。\n  CSS Modules を使用して、インポート済みのスタイルシートをスコープ化します。\n  ソース構成図 lwc ├─commonStyle └─commonStyleChild commonStyle commonStyle.css\n.commonCss { font-size: 30px; color: #fff; background-color: rgba(128, 129, 56, 0.5); border-radius: 2px; min-width: 100px; /** 真ん中 */ display: flex; justify-content: center; align-items: center; } commonStyle.js-meta.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;false\u0026lt;/isExposed\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt; commonStyleChild commonStyleChild.css\n@import \u0026#34;c/commonStyle\u0026#34;; /**ここ共通CSSをインポート*/ commonStyleChild.html\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;commonCss\u0026#34;\u0026gt;TEST\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; commonStyleChild.js\nimport { LightningElement } from \u0026#34;lwc\u0026#34;; export default class CommonStyleChild extends LightningElement {} commonStyleChild.js-meta.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;false\u0026lt;/isExposed\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt; ローカルで動作確認  commonStyleChild 中に右クリックし、SFDX:Preview Component Locallyを押下する   Use Desktop Browserを選択する   サーバを立ち上げて、ブラウザを自動的に開く  ","permalink":"https://seiri-blog.github.io/posts/lwc-common-css/","summary":"LWC 共通 CSS 方法説明 スタイルシートを使用して共通の CSS を定義し、それを複数のコンポーネントでインポートします。 CSS をグローバルに定義し、それをすべて","title":"【Salesforce】LWCでの共通CSS"},{"content":"1.目的 今回Lighting Desigin Systemで提供された標準デザインを変えようと思います。\n基本的にはスタイルフックを使って、標準のデザインを変えます。但しこの方法では Salesforce 側しか使えないので。使う時にご注意ください。\n2.ソース構成図 lwc └─stylingHooksDemo  stylingHooksDemo\n  .my-css { --sds-c-button-brand-color-background: #BB00FF; --sds-c-button-brand-color-background-hover: #8700B8; --sds-c-button-brand-color-border: #BB00FF; --sds-c-button-brand-color-border-hover: #8700B8; } \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;slds-card\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;slds-button slds-button_brand slds-m-bottom_medium\u0026#34;\u0026gt;Normal Button\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;slds-button slds-button_brand slds-m-bottom_medium my-css\u0026#34;\u0026gt;Styled Button\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement } from \u0026#39;lwc\u0026#39;; export default class StylingHooksDemo extends LightningElement {} \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;true\u0026lt;/isExposed\u0026gt; \u0026lt;targets\u0026gt; \u0026lt;target\u0026gt;lightning__Tab\u0026lt;/target\u0026gt; \u0026lt;/targets\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt; 3.Salesforce 側動作確認   Salesforce 側 Lightning コンポーネントタブを作成\n\n  タブを開く\n左は標準ボタンのデザイン、右はカスタマイズデザイン\n\n  4.参考 Lighting Design System Styling Hooks\nhttps://www.lightningdesignsystem.com/platforms/lightning/styling-hooks/#site-main-content\n","permalink":"https://seiri-blog.github.io/posts/lwc-styling-hooks/","summary":"1.目的 今回Lighting Desigin Systemで提供された標準デザインを変えようと思います。 基本的にはスタイルフックを使って、標準のデザインを変","title":"LWCでのStyling Hooks"},{"content":"再帰的なコンポーネント LWC（Lightning Web Component）で再帰的なコンポーネントを作成するには、コンポーネントが自身を呼び出す再帰的なパターンを設計する必要があります。再帰的なコンポーネントは、データ構造がツリー状にネストされている場合や、階層構造の要素を表示する場合に非常に便利です。以下は、LWCで再帰的なコンポーネントを作成する基本的なステップです。\n 以下は再帰的なコンポーネントの例です  lwc ├─menu ├─menuItem └─menuContainer  menu\n  \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;slds-dropdown-trigger slds-dropdown-trigger_click slds-is-open\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-dropdown slds-dropdown_left slds-dropdown_small\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;slds-dropdown__list\u0026#34;\u0026gt; \u0026lt;c-menu-item child-items={_items}\u0026gt; \u0026lt;/c-menu-item\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, api } from \u0026#39;lwc\u0026#39;; export default class Menu extends LightningElement { @api get items() { return this._items || []; } set items(value) { this._items = value; } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;false\u0026lt;/isExposed\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt;  menuItem\n  \u0026lt;template\u0026gt; \u0026lt;template for:each={_children} for:item=\u0026#34;it\u0026#34; for:index=\u0026#34;index\u0026#34;\u0026gt; \u0026lt;template if:false={it.items}\u0026gt; \u0026lt;li class=\u0026#34;slds-dropdown__item\u0026#34; role=\u0026#34;presentation\u0026#34; key={item}\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;slds-truncate\u0026#34; title={it.label}\u0026gt;{it.label}\u0026lt;/span\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template if:true={it.items}\u0026gt; \u0026lt;li class=\u0026#34;slds-dropdown__header slds-truncate\u0026#34; key={item}\u0026gt; \u0026lt;span title={it.label}\u0026gt;{it.label}\u0026lt;/span\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;c-menu-item child-items={it.items} key={item}\u0026gt;\u0026lt;/c-menu-item\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, api, track } from \u0026#39;lwc\u0026#39;; export default class MenuItem extends LightningElement { @track _children = []; /** * childItemsを取得 */ @api get childItems() { return this._children; } /** * childItemsを設定 * @param {any} value */ set childItems(value) { this._children = value || []; } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;false\u0026lt;/isExposed\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt;  menuContainer\n  \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;slds-card\u0026#34; style=\u0026#34;height:500px;width:1200px\u0026#34;\u0026gt; \u0026lt;c-menu items={items}\u0026gt;\u0026lt;/c-menu\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, track } from \u0026#39;lwc\u0026#39;; export default class MenuContainer extends LightningElement { @track items = [{ label: \u0026#39;メニュー1\u0026#39;, items: [{ label: \u0026#39;サブメニュー1-1\u0026#39;, }, { label: \u0026#39;サブメニュー1-2\u0026#39;, }, ], }, { label: \u0026#39;メニュー2\u0026#39;, items: [{ label: \u0026#39;サブメニュー2-1\u0026#39;, }, { label: \u0026#39;サブメニュー2-2\u0026#39;, }, ], }, ]; } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;52.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;false\u0026lt;/isExposed\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt;  ロカールで動作確認  menuContainer 中に右クリックし、SFDX:Preview Component Locallyを押下する\n\nUse Desktop Browserを選択する\n\nサーバを立ち上げて、ブラウザを自動的に開く\n\n参考 https://www.lightningdesignsystem.com/components/menus/#site-main-content\n","permalink":"https://seiri-blog.github.io/posts/lwc-recursive-component/","summary":"再帰的なコンポーネント LWC（Lightning Web Component）で再帰的なコンポーネントを作成するには、コンポーネントが自身を呼び出す","title":"LWCの再帰的なコンポーネントを作成する方法"},{"content":"1.目的 LWC でのループ回す方法は\u0026lt;template for:eatch={items} for:item=\u0026quot;item\u0026quot; for:index=\u0026quot;idx\u0026quot;\u0026gt;ですが、但しタグ中には\u0026lt;template if:true\u0026gt;でインデックスを判断できないため、今回\u0026lt;template for:eatch={items} for:item=\u0026quot;item\u0026quot; for:index=\u0026quot;idx\u0026quot;\u0026gt;でループ回す中にインデックスを判断する方法を紹介しようと思います。\n2.ソース構成図 lwc ├─groupButton └─groupButtonContainer  groupButton\n  \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;slds-button-group\u0026#34; role=\u0026#34;group\u0026#34;\u0026gt; \u0026lt;template for:each=\u0026#34;{buttonList}\u0026#34; for:item=\u0026#34;item\u0026#34; for:index=\u0026#34;index\u0026#34;\u0026gt; {getIndex} \u0026lt;template if:true=\u0026#34;{isActive}\u0026#34;\u0026gt; \u0026lt;button key=\u0026#34;{item.id}\u0026#34; class=\u0026#34;slds-button slds-button_brand\u0026#34; onclick=\u0026#34;{onClickHandler}\u0026#34; name=\u0026#34;{item.value}\u0026#34; \u0026gt; {item.value} \u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template if:false=\u0026#34;{isActive}\u0026#34;\u0026gt; \u0026lt;button key=\u0026#34;{item.id}\u0026#34; class=\u0026#34;slds-button slds-button_neutral\u0026#34; onclick=\u0026#34;{onClickHandler}\u0026#34; name=\u0026#34;{item.value}\u0026#34; \u0026gt; {item.value} \u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, api } from \u0026#34;lwc\u0026#34;; export default class GroupButton extends LightningElement { //インデックス  @api activeIndex; //ボタンリスト  @api buttonList; //インデックス初期化  id = -1; /** * インデックス取得 */ get getIndex() { this.id++; } /** * アクティブかを判断する */ get isActive() { return Number(this.activeIndex) === this.id; } /** * グループボタン押下 * @param {*} event */ onClickHandler(event) { let target = event.target; let clickedButton = this.template.querySelector(\u0026#34;.slds-button_brand\u0026#34;); clickedButton.classList.remove(\u0026#34;slds-button_brand\u0026#34;); clickedButton.classList.add(\u0026#34;slds-button_neutral\u0026#34;); target.classList.remove(\u0026#34;slds-button_neutral\u0026#34;); target.classList.add(\u0026#34;slds-button_brand\u0026#34;); // debugger;  this.dispatchEvent( new CustomEvent(\u0026#34;select\u0026#34;, { detail: target.name, }) ); } }  groupButtonContainer\n  \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;slds-card\u0026#34; style=\u0026#34;height: 300px;width:1200px\u0026#34;\u0026gt; \u0026lt;c-group-button button-list=\u0026#34;{buttonList}\u0026#34; active-index=\u0026#34;1\u0026#34; \u0026gt;\u0026lt;/c-group-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement } from \u0026#34;lwc\u0026#34;; export default class GroupButtonContainer extends LightningElement { buttonList = [ { id: 0, value: \u0026#34;ボタン1\u0026#34;, }, { id: 1, value: \u0026#34;ボタン2\u0026#34;, }, { id: 2, value: \u0026#34;ボタン3\u0026#34;, }, { id: 3, value: \u0026#34;ボタン4\u0026#34;, }, { id: 4, value: \u0026#34;ボタン5\u0026#34;, }, ]; } 3.ロカールで動作確認 groupButtonContainern 中に右クリックし、SFDX:Preview Component Locallyを押下する\n\nUse Desktop Browserを選択する\n\nサーバを立ち上げて、ブラウザを自動的に開く\n\n","permalink":"https://seiri-blog.github.io/posts/create-lwc-groupbutton-component-self/","summary":"1.目的 LWC でのループ回す方法は\u0026lt;template for:eatch={items} for:item=\u0026quot;item\u0026quot; for:index=\u0026quot;idx\u0026quot;\u0026gt;ですが、但しタグ中には\u0026","title":"LWC GroupButtonコンポーネント自分で作る"},{"content":"1.目的 LWC での条件判断はif:trueまたはif:falseしか判断できないので、今回trueやfalseをこだわらない、複雑の条件を判断できるコンポーネントを作成しようと思います。\n2.ソース構成図 lwc ├─conditionJudge └─conditionJudgeContainer  conditionJudge\n  \u0026lt;template\u0026gt; \u0026lt;template if:true=\u0026#34;{result}\u0026#34;\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, api, track } from \u0026#34;lwc\u0026#34;; export default class ConditionJudge extends LightningElement { // eq,noteq,gt:\u0026gt;,ge:\u0026gt;=,lt:\u0026lt;,le\u0026lt;:=,contains,not_contains  @api condition; @api leftParam; @api rightParam; @track result; connectedCallback() { const { condition, leftParam, rightParam } = this; try { // console.log(rightParam)  switch (condition) { case \u0026#34;eq\u0026#34;: this.result = parseInt(leftParam) === parseInt(rightParam); break; case \u0026#34;noteq\u0026#34;: this.result = parseInt(leftParam) !== parseInt(rightParam); break; case \u0026#34;gt\u0026#34;: this.result = parseInt(leftParam) \u0026gt; parseInt(rightParam); break; case \u0026#34;ge\u0026#34;: this.result = parseInt(leftParam) \u0026gt;= parseInt(rightParam); break; case \u0026#34;lt\u0026#34;: this.result = parseInt(leftParam) \u0026lt; parseInt(rightParam); break; case \u0026#34;le\u0026#34;: this.result = parseInt(leftParam) \u0026lt;= parseInt(rightParam); break; case \u0026#34;contains\u0026#34;: this.result = leftParam.split(\u0026#34;,\u0026#34;).indexOf(String(rightParam)) !== -1; break; case \u0026#34;not_contains\u0026#34;: this.result = leftParam.split(\u0026#34;,\u0026#34;).indexOf(String(rightParam)) === -1; break; default: break; } } catch (e) { console.error(e); } } }  conditionJudgeContainer\n  \u0026lt;template\u0026gt; \u0026lt;!-- 単一の判断 --\u0026gt; 単一の判断： \u0026lt;div class=\u0026#34;slds-card\u0026#34; style=\u0026#34;width:500px\u0026#34;\u0026gt; \u0026lt;c-condition-judge condition=\u0026#34;eq\u0026#34; left-param=\u0026#34;1\u0026#34; right-param=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-grid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-col\u0026#34; style=\u0026#34;background-color: aliceblue;\u0026#34;\u0026gt; 等しい条件 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/c-condition-judge\u0026gt; \u0026lt;c-condition-judge condition=\u0026#34;gt\u0026#34; left-param=\u0026#34;2\u0026#34; right-param=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-grid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-col\u0026#34; style=\u0026#34;background-color: aliceblue;\u0026#34;\u0026gt; 大きい条件 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/c-condition-judge\u0026gt; \u0026lt;c-condition-judge condition=\u0026#34;lt\u0026#34; left-param=\u0026#34;1\u0026#34; right-param=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-grid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-col\u0026#34; style=\u0026#34;background-color: aliceblue;\u0026#34;\u0026gt; 小さい条件 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/c-condition-judge\u0026gt; \u0026lt;c-condition-judge condition=\u0026#34;gt\u0026#34; left-param=\u0026#34;2\u0026#34; right-param=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-grid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-col\u0026#34; style=\u0026#34;background-color: aliceblue;\u0026#34;\u0026gt; 大きいまたは等しい条件 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/c-condition-judge\u0026gt; \u0026lt;c-condition-judge condition=\u0026#34;lt\u0026#34; left-param=\u0026#34;1\u0026#34; right-param=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-grid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-col\u0026#34; style=\u0026#34;background-color: aliceblue;\u0026#34;\u0026gt; 小さいまたは等しい条件 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/c-condition-judge\u0026gt; \u0026lt;c-condition-judge condition=\u0026#34;contains\u0026#34; left-param=\u0026#34;1,2,3,4\u0026#34; right-param=\u0026#34;2\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;slds-grid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-col\u0026#34; style=\u0026#34;background-color: aliceblue;\u0026#34;\u0026gt; 含む条件 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/c-condition-judge\u0026gt; \u0026lt;c-condition-judge condition=\u0026#34;contains\u0026#34; left-param=\u0026#34;1,2,3,4\u0026#34; right-param=\u0026#34;5\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;slds-grid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-col\u0026#34; style=\u0026#34;background-color: aliceblue;\u0026#34;\u0026gt; 含まない条件 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/c-condition-judge\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 複雑の判断 --\u0026gt; 複雑の判断： \u0026lt;div class=\u0026#34;slds-card\u0026#34; style=\u0026#34;width:500px\u0026#34;\u0026gt; \u0026lt;c-condition-judge condition=\u0026#34;noteq\u0026#34; left-param=\u0026#34;1\u0026#34; right-param=\u0026#34;{targetValue}\u0026#34; \u0026gt; \u0026lt;c-condition-judge condition=\u0026#34;lt\u0026#34; left-param=\u0026#34;12\u0026#34; right-param=\u0026#34;{targetValue}\u0026#34; \u0026gt; 12より小さい \u0026lt;/c-condition-judge\u0026gt; \u0026lt;c-condition-judge condition=\u0026#34;ge\u0026#34; left-param=\u0026#34;12\u0026#34; right-param=\u0026#34;{targetValue}\u0026#34; \u0026gt; 12より大きいまたは等しい \u0026lt;/c-condition-judge\u0026gt; \u0026lt;/c-condition-judge\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement } from \u0026#34;lwc\u0026#34;; export default class ConditionJudgeContainer extends LightningElement { targetValue = 12; } 3.ロカールで動作確認 conditionJudgeContainer 右クリックし、SFDX:Preview Component Locallyを押下する\n\nUse Desktop Browserを選択する\n\nサーバを立ち上げて、ブラウザを自動的に開く\n\n","permalink":"https://seiri-blog.github.io/posts/create-lwc-condition-judgement-component-self/","summary":"1.目的 LWC での条件判断はif:trueまたはif:falseしか判断できないので、今回trueやfalseをこだわらない、複雑の条件を判断で","title":"LWC 条件判断コンポーネント自分で作る"},{"content":"SalesforceのLWCでカスタムCalendarコンポーネントを作る方法を紹介します。\nhttps://www.lightningdesignsystem.com/components/datepickers/\n上記公式サイトのUIを基づいて、LWCでカスタムCalendarコンポーネントを作成する例です。\n.noclick { pointer-events: none; } .day { cursor: pointer; } \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;slds-datepicker slds-dropdown\u0026#34; role=\u0026#34;dialog\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-datepicker__filter slds-grid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-datepicker__filter_month slds-grid slds-grid_align-spread slds-grow\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;slds-align-middle\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;slds-button slds-button_icon slds-button_icon-container\u0026#34; title=\u0026#34;Previous Month\u0026#34; onclick=\u0026#34;{prev}\u0026#34; \u0026gt; \u0026lt;lightning-icon icon-name=\u0026#34;utility:left\u0026#34; size=\u0026#34;x-small\u0026#34;\u0026gt; \u0026lt;/lightning-icon\u0026gt; \u0026lt;span class=\u0026#34;slds-assistive-text\u0026#34;\u0026gt;Previous Month\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h2 class=\u0026#34;slds-align-middle\u0026#34;\u0026gt;{currentMonth}月\u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;slds-align-middle\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;slds-button slds-button_icon slds-button_icon-container\u0026#34; title=\u0026#34;Next Month\u0026#34; onclick=\u0026#34;{next}\u0026#34; \u0026gt; \u0026lt;lightning-icon icon-name=\u0026#34;utility:right\u0026#34; size=\u0026#34;x-small\u0026#34;\u0026gt; \u0026lt;/lightning-icon\u0026gt; \u0026lt;span class=\u0026#34;slds-assistive-text\u0026#34;\u0026gt;Next Month\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;slds-shrink-none\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slds-select_container\u0026#34;\u0026gt; \u0026lt;select class=\u0026#34;slds-select\u0026#34; onchange=\u0026#34;{yearSelectChange}\u0026#34;\u0026gt; \u0026lt;template for:each=\u0026#34;{selectYearList}\u0026#34; for:item=\u0026#34;item\u0026#34; for:index=\u0026#34;index\u0026#34; \u0026gt; \u0026lt;template if:true=\u0026#34;{item.selected}\u0026#34;\u0026gt; \u0026lt;option key=\u0026#34;{item.value}\u0026#34; value=\u0026#34;{item.value}\u0026#34; selected\u0026gt; {item.value} \u0026lt;/option\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template if:false=\u0026#34;{item.selected}\u0026#34;\u0026gt; \u0026lt;option key=\u0026#34;{item.value}\u0026#34; value=\u0026#34;{item.value}\u0026#34;\u0026gt; {item.value} \u0026lt;/option\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;table class=\u0026#34;slds-datepicker__month\u0026#34; role=\u0026#34;grid\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th scope=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;abbr title=\u0026#34;日曜日\u0026#34;\u0026gt;日\u0026lt;/abbr\u0026gt; \u0026lt;/th\u0026gt; \u0026lt;th scope=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;abbr title=\u0026#34;月曜日\u0026#34;\u0026gt;月\u0026lt;/abbr\u0026gt; \u0026lt;/th\u0026gt; \u0026lt;th scope=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;abbr title=\u0026#34;火曜日\u0026#34;\u0026gt;火\u0026lt;/abbr\u0026gt; \u0026lt;/th\u0026gt; \u0026lt;th scope=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;abbr title=\u0026#34;水曜日\u0026#34;\u0026gt;水\u0026lt;/abbr\u0026gt; \u0026lt;/th\u0026gt; \u0026lt;th scope=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;abbr title=\u0026#34;木曜日\u0026#34;\u0026gt;木\u0026lt;/abbr\u0026gt; \u0026lt;/th\u0026gt; \u0026lt;th scope=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;abbr title=\u0026#34;金曜日\u0026#34;\u0026gt;金\u0026lt;/abbr\u0026gt; \u0026lt;/th\u0026gt; \u0026lt;th scope=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;abbr title=\u0026#34;土曜日\u0026#34;\u0026gt;土\u0026lt;/abbr\u0026gt; \u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;template for:each=\u0026#34;{dayList}\u0026#34; for:item=\u0026#34;items\u0026#34; for:index=\u0026#34;index\u0026#34;\u0026gt; \u0026lt;tr key=\u0026#34;{items.id}\u0026#34;\u0026gt; \u0026lt;template for:each=\u0026#34;{items.value}\u0026#34; for:item=\u0026#34;item\u0026#34; for:index=\u0026#34;idx\u0026#34;\u0026gt; \u0026lt;template if:true=\u0026#34;{item.adjacentMonth}\u0026#34;\u0026gt; \u0026lt;td class=\u0026#34;slds-day_adjacent-month\u0026#34; key=\u0026#34;{item.day}\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;slds-day\u0026#34; data-value=\u0026#34;{item.value}\u0026#34; onclick=\u0026#34;{dateSelectChange}\u0026#34; \u0026gt; {item.day} \u0026lt;/span\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template if:false=\u0026#34;{item.adjacentMonth}\u0026#34;\u0026gt; \u0026lt;template if:true=\u0026#34;{item.today}\u0026#34;\u0026gt; \u0026lt;td class=\u0026#34;slds-is-today\u0026#34; key=\u0026#34;{item.day}\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;slds-day\u0026#34; data-value=\u0026#34;{item.value}\u0026#34; onclick=\u0026#34;{dateSelectChange}\u0026#34; \u0026gt; {item.day} \u0026lt;/span\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template if:false=\u0026#34;{item.today}\u0026#34;\u0026gt; \u0026lt;td key=\u0026#34;{item.day}\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;slds-day\u0026#34; data-value=\u0026#34;{item.value}\u0026#34; onclick=\u0026#34;{dateSelectChange}\u0026#34; \u0026gt; {item.day} \u0026lt;/span\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;button class=\u0026#34;slds-button slds-align_absolute-center slds-text-link\u0026#34; onclick=\u0026#34;{todayClickHandler}\u0026#34; \u0026gt; 今日 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, track } from \u0026#34;lwc\u0026#34;; const DAY_OF_WEEK = [\u0026#34;日\u0026#34;, \u0026#34;月\u0026#34;, \u0026#34;火\u0026#34;, \u0026#34;水\u0026#34;, \u0026#34;木\u0026#34;, \u0026#34;金\u0026#34;, \u0026#34;土\u0026#34;]; export default class Calendar extends LightningElement { //現在の日付  today = new Date(); // 月末だとずれる可能性があるため、1日固定で取得  showDate = new Date(this.today.getFullYear(), this.today.getMonth(), 1); @track selectYearList = []; @track dayList = []; @track currentYear = this.showDate.getFullYear(); @track currentMonth = this.showDate.getMonth() + 1; @track currentDay = this.showDate.getDate(); // 前の月表示  prev(e) { e.preventDefault(); this.showDate.setMonth(this.showDate.getMonth() - 1); this.currentMonth = this.showDate.getMonth() + 1; this.showProcess(this.showDate); } // 次の月表示  next(e) { e.preventDefault(); this.showDate.setMonth(this.showDate.getMonth() + 1); this.currentMonth = this.showDate.getMonth() + 1; this.showProcess(this.showDate); } // カレンダー表示  showProcess(date) { let year = date.getFullYear(); let month = date.getMonth(); this.createProcess(year, month); } // カレンダー作成  createProcess(year, month) { let count = 0; let startDayOfWeek = new Date(year, month, 1).getDay(); let endDate = new Date(year, month + 1, 0).getDate(); let lastMonthEndDate = new Date(year, month, 0).getDate(); let row = Math.ceil((startDayOfWeek + endDate) / DAY_OF_WEEK.length); this.dayList = []; // 1行ずつ設定  for (let i = 0; i \u0026lt; row; i++) { this.dayList.push({ value: [], id: i }); // 1colum単位で設定  for (let j = 0; j \u0026lt; DAY_OF_WEEK.length; j++) { if (i == 0 \u0026amp;\u0026amp; j \u0026lt; startDayOfWeek) { // 1行目で1日まで先月の日付を設定  this.dayList[i].value.push({ adjacentMonth: true, today: false, day: lastMonthEndDate - startDayOfWeek + j + 1, value: `${this.currentYear}-${this.currentMonth - 1}-${ lastMonthEndDate - startDayOfWeek + j + 1 }`, }); } else if (count \u0026gt;= endDate) { // 最終行で最終日以降、翌月の日付を設定  count++; this.dayList[i].value.push({ adjacentMonth: true, today: false, day: count - endDate, value: `${this.currentYear}-${this.currentMonth + 1}-${ count - endDate }`, }); } else { // 当月の日付を曜日に照らし合わせて設定  count++; if ( year == this.today.getFullYear() \u0026amp;\u0026amp; month == this.today.getMonth() \u0026amp;\u0026amp; count == this.today.getDate() ) { this.dayList[i].value.push({ adjacentMonth: false, today: true, day: count, value: `${this.currentYear}-${this.currentMonth}-${count}`, }); } else { this.dayList[i].value.push({ adjacentMonth: false, today: false, day: count, value: `${this.currentYear}-${this.currentMonth}-${count}`, }); } } } } } /** * セレクトボックスの中にオプションを生成する * @param {number} startNum オプションを生成する最初の数値 * @param {number} endNum オプションを生成する最後の数値 * @param {string} current 現在の日付にマッチする数値 */ createYearOption(startNum, endNum, current) { for (let j = startNum; j \u0026lt;= endNum; j++) { let selected; if (j === Number(current)) { selected = true; } else { selected = false; } this.selectYearList.push({ value: j, selected: selected, }); } } /** * 年を選択 * @param {*} e */ yearSelectChange(e) { e.preventDefault(); let selectedIndex = e.target.selectedIndex; this.currentYear = e.target.options[selectedIndex].value; let currentDate = new Date( this.currentYear, this.currentMonth - 1, this.currentDay ); this.showProcess(currentDate); } /** * スタイル削除 */ removeCurrentlySelectedDateAttributes() { const e = this.template.querySelector(\u0026#34;td[class*=\u0026#39;slds-is-selected\u0026#39;]\u0026#34;); e \u0026amp;\u0026amp; e.classList.remove(\u0026#34;slds-is-selected\u0026#34;); } /** * 日付を選択 * @param {*} e */ dateSelectChange(e) { e.preventDefault(); let target = e.target; this.removeCurrentlySelectedDateAttributes(); target.parentElement.classList.add(\u0026#34;slds-is-selected\u0026#34;); let dateStr = target.dataset.value; this.dispatchEvent( new CustomEvent(\u0026#34;select\u0026#34;, { detail: new Date(dateStr), }) ); } /** * 今日を選択 * @param {*} e */ todayClickHandler(e) { e.preventDefault(); this.showDate = new Date(); this.dispatchEvent( new CustomEvent(\u0026#34;select\u0026#34;, { detail: this.showDate, }) ); } connectedCallback() { this.showProcess(this.today); let thisYear = this.today.getFullYear(); this.createYearOption(thisYear - 100, thisYear + 100, thisYear); //年の設定  } }  動作  コンポーネント中に右クリックし、SFDX:Preview Component Locallyを押下する\n\nUse Desktop Browserを選択する\n\nサーバを立ち上げて、ブラウザを自動的に開く\n\n","permalink":"https://seiri-blog.github.io/posts/create-lwc-calendar-component/","summary":"SalesforceのLWCでカスタムCalendarコンポーネントを作る方法を紹介します。 https://www.lightningdesignsystem.com/components/datepickers/ 上記公式サイトのUIを基づいて、LWCでカスタ","title":"LWCでカスタムCalendarコンポーネントを作る"},{"content":"1.目的 今回 LWC で ContextMenu コンポーネントを作成しようと思います、\n基本的な考え方は右クリックをすると、カーソルの座標を取得し、\nその座標を使って、ContextMenu の位置を設定します。\n2.ソース構成 lwc ├─contextMenu └─contextMenuContainer  contextMenu\n  div { display: block; } .contextmenu { background-color: #fff; background-clip: padding-box; border: 1px solid rgba(0, 0, 0, 0.15); border-radius: 0.25rem; color: #373a3c; margin: 2px 0 0; min-width: 10em; outline: none; padding: 2px 0; /_ pointer-events: none; _/ text-align: left; transition: opacity 250ms ease !important; z-index: 9999; position: fixed; opacity: 1; } .contextmenu-item { background: 0 0; border: 0; color: #373a3c; cursor: pointer; font-weight: 400; line-height: 1.5; padding: 3px 20px; text-align: inherit; white-space: nowrap; } .contextmenu-item:active { outline: none; } .contextmenu-item:hover { background-color: rgb(78, 107, 235); color: #fff; } \u0026lt;template\u0026gt; \u0026lt;template if:true=\u0026#34;{_showMenu}\u0026#34;\u0026gt; \u0026lt;div role=\u0026#34;menu\u0026#34; tabindex=\u0026#34;-1\u0026#34; class=\u0026#34;contextmenu\u0026#34; style=\u0026#34;{position}\u0026#34; oncontextmenu=\u0026#34;{contextMenuHadler}\u0026#34; \u0026gt; \u0026lt;template for:each=\u0026#34;{_menuItem}\u0026#34; for:item=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;div key=\u0026#34;{item.id}\u0026#34; data-id=\u0026#34;{item.id}\u0026#34; data-name=\u0026#34;{item.name}\u0026#34; data-value=\u0026#34;{item.value}\u0026#34; onclick=\u0026#34;{clickHandler}\u0026#34; class=\u0026#34;contextmenu-item\u0026#34; role=\u0026#34;menuitem\u0026#34; tabindex=\u0026#34;-1\u0026#34; aria-disabled=\u0026#34;false\u0026#34; \u0026gt; {item.name} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, api, track } from \u0026#34;lwc\u0026#34;; export default class MenuComponent extends LightningElement { @track _positionX; @track _positionY; @track _showMenu; @track _menuItem; @api name; /** * スタイル取得 */ get position() { const { _positionX, _positionY } = this; if (_positionX \u0026amp;\u0026amp; _positionY) { // return `position:absolute;z-index: 999; top: ${_positionY}px; left:${_positionX}px`;  return `top: ${_positionY}px; left:${_positionX}px`; } else { this.closeMenu(); return \u0026#34;\u0026#34;; } } /** * 座標Xを取得 */ @api get positionX() { return this._positionX; } /** * 座標Xを設定 */ set positionX(val) { this._positionX = val; } /** * 座標Yを取得 */ @api get positionY() { return this._positionY; } /** * 座標Yを設定 */ set positionY(val) { this._positionY = val; } /** * メニューアイテムを取得 */ @api get menuItem() { return this._menuItem; } /** * メニューアイテムを設定 */ set menuItem(val) { this._menuItem = val || []; } /** * メニューアイテム押下 * @param {*} event */ clickHandler(event) { event.preventDefault(); event.stopPropagation(); let target = event.target; let id = target.dataset.id; let name = target.dataset.name; let value = target.dataset.value; this.closeMenu(); const clickEvent = new CustomEvent(\u0026#34;rightclick\u0026#34;, { detail: { id, name, value, }, }); this.dispatchEvent(clickEvent); } @api closeMenu() { this._showMenu = false; } @api openMenu() { this._showMenu = true; } /** * * @param {*} event * @returns */ contextMenuHadler(event) { event.preventDefault(); return false; } }  contextMenuContainer\n  \u0026lt;template\u0026gt; \u0026lt;c-context-menu position-x=\u0026#34;{positionX}\u0026#34; position-y=\u0026#34;{positionY}\u0026#34; menu-item=\u0026#34;{menuItem}\u0026#34; onrightclick=\u0026#34;{contextMenuClickHandler}\u0026#34; \u0026gt; \u0026lt;/c-context-menu\u0026gt; \u0026lt;div class=\u0026#34;slds-card\u0026#34; style=\u0026#34;width:100%;height:300px;\u0026#34; onmousedown=\u0026#34;{rightClick}\u0026#34; oncontextmenu=\u0026#34;{contextMenuHadler}\u0026#34; \u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, track } from \u0026#34;lwc\u0026#34;; export default class ContextMenuContainer extends LightningElement { @track positionX; @track positionY; //メニューアイテム設定  @track menuItem = [ { id: 0, name: \u0026#34;メニュー1\u0026#34;, value: \u0026#34;menu1\u0026#34;, }, { id: 1, name: \u0026#34;メニュー2\u0026#34;, value: \u0026#34;menu2\u0026#34;, }, ]; /** * 右クリック * @param {*} event */ rightClick(event) { if (event.which == 3) { this.positionX = event.clientX; this.positionY = event.clientY; //右クリックメニュー表示  this.template.querySelector(\u0026#34;c-context-menu\u0026#34;).openMenu(); } else { //右クリックメニュー閉じる  this.template.querySelector(\u0026#34;c-context-menu\u0026#34;).closeMenu(); } } /** * * @param {*} event * @returns */ contextMenuHadler(event) { event.preventDefault(); return false; } /** * 右クリックメニューハンドラー * @param {*} event */ contextMenuClickHandler(event) { let result = event.detail; const { id, name, value } = result; console.log(id, name, value); } } Salesforce 側動作確認   Salesforce 側 Lightning コンポーネントタブを作成\n\n  タブを開く\n右クリックすると、ContextMenu が表示します\n\n  ","permalink":"https://seiri-blog.github.io/posts/create-lwc-contextmenu-component-self/","summary":"1.目的 今回 LWC で ContextMenu コンポーネントを作成しようと思います、 基本的な考え方は右クリックをすると、カーソルの座標を取得し、 その座標を使って、Con","title":"LWC ContextMenuコンポーネント自分で作る"},{"content":"目的 今回自分で開発した Salesforce 側使える LWC での画面遷移方法を紹介します。\n構成図 lwc ├─router ├─myRouterContainer ├─pageA ├─pageB  router コンポーネント  \n\u0026lt;template\u0026gt; \u0026lt;template if:true=\u0026#34;{isCurrentPageName}\u0026#34;\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, api, wire } from \u0026#34;lwc\u0026#34;; import { CurrentPageReference, NavigationMixin } from \u0026#34;lightning/navigation\u0026#34;; export default class Router extends NavigationMixin(LightningElement) { //ルーターパス宣言  @api path; //現在のルーターパス  @wire(CurrentPageReference) currentPageReference; /** * 現在のページかを判断する */ get isCurrentPageName() { const { c__pageName } = this.currentPageReference.state; const { path } = this; return path === c__pageName; } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;51.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;false\u0026lt;/isExposed\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt;  myRouterContainer（ページのパスを定義する）  \n\u0026lt;template\u0026gt; \u0026lt;!-- デフォルトページ --\u0026gt; \u0026lt;c-router\u0026gt; \u0026lt;c-page-a\u0026gt;\u0026lt;/c-page-a\u0026gt; \u0026lt;/c-router\u0026gt; \u0026lt;!-- ページ --\u0026gt; \u0026lt;c-router path=\u0026#34;A\u0026#34;\u0026gt; \u0026lt;c-page-a\u0026gt;\u0026lt;/c-page-a\u0026gt; \u0026lt;/c-router\u0026gt; \u0026lt;c-router path=\u0026#34;B\u0026#34;\u0026gt; \u0026lt;c-page-b\u0026gt;\u0026lt;/c-page-b\u0026gt; \u0026lt;/c-router\u0026gt; \u0026lt;!-- ページ追加↑↑↑↑ --\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement } from \u0026#34;lwc\u0026#34;; export default class myRouterContainer extends LightningElement {} \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;51.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;true\u0026lt;/isExposed\u0026gt; \u0026lt;targets\u0026gt; \u0026lt;target\u0026gt;lightning__Tab\u0026lt;/target\u0026gt; \u0026lt;/targets\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt;  ページ A  \n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;slds-card\u0026#34; style=\u0026#34;height:300px\u0026#34;\u0026gt; \u0026lt;div\u0026gt;ここはページA\u0026lt;/div\u0026gt; \u0026lt;lightning-button onclick=\u0026#34;{navigateToB}\u0026#34; label=\u0026#34;ページBへ遷移\u0026#34; \u0026gt;\u0026lt;/lightning-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, wire } from \u0026#34;lwc\u0026#34;; import { NavigationMixin, CurrentPageReference } from \u0026#34;lightning/navigation\u0026#34;; export default class PageA extends NavigationMixin(LightningElement) { //現在のルーターパス  @wire(CurrentPageReference) currentPageReference; /** * 画面Bへ遷移 * @param {*} event */ navigateToB(event) { event.preventDefault(); this.navigateToNextPage(\u0026#34;B\u0026#34;); } /** * 画面遷移 * @param {*} pageName */ navigateToNextPage(pageName) { const { apiName } = this.currentPageReference.attributes; this[NavigationMixin.Navigate]({ type: \u0026#34;standard__webPage\u0026#34;, attributes: { url: `/lightning/n/${apiName}?c__pageName=${pageName}`, }, }); } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;51.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;false\u0026lt;/isExposed\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt;  ページ B  \n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;slds-card\u0026#34; style=\u0026#34;height:300px\u0026#34;\u0026gt; \u0026lt;div\u0026gt;ここはページB\u0026lt;/div\u0026gt; \u0026lt;lightning-button onclick=\u0026#34;{navigateToA}\u0026#34; label=\u0026#34;ページAへ遷移\u0026#34; \u0026gt;\u0026lt;/lightning-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; import { LightningElement, wire } from \u0026#34;lwc\u0026#34;; import { NavigationMixin, CurrentPageReference } from \u0026#34;lightning/navigation\u0026#34;; export default class PageB extends NavigationMixin(LightningElement) { //現在のルーターパス  @wire(CurrentPageReference) currentPageReference; /** * 画面Bへ遷移 * @param {*} event */ navigateToA(event) { event.preventDefault(); this.navigateToNextPage(\u0026#34;A\u0026#34;); } /** * 画面遷移 * @param {*} pageName */ navigateToNextPage(pageName) { const { apiName } = this.currentPageReference.attributes; this[NavigationMixin.Navigate]({ type: \u0026#34;standard__webPage\u0026#34;, attributes: { url: `/lightning/n/${apiName}?c__pageName=${pageName}`, }, }); } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;LightningComponentBundle xmlns=\u0026#34;http://soap.sforce.com/2006/04/metadata\u0026#34;\u0026gt; \u0026lt;apiVersion\u0026gt;51.0\u0026lt;/apiVersion\u0026gt; \u0026lt;isExposed\u0026gt;false\u0026lt;/isExposed\u0026gt; \u0026lt;/LightningComponentBundle\u0026gt; Salesforce 側動作確認  Salesforce 側 Lightning コンポーネントタブを作成  \n タブを開く\nデフォルトはページ A を表示する  \nページ B へ遷移ボタン押下すると、ページ A からページ B へ遷移する\n\nページ A へ遷移ボタン押下すると、ページ B からページ A へ遷移する\n\n","permalink":"https://seiri-blog.github.io/posts/salesforce-lwc-router/","summary":"目的 今回自分で開発した Salesforce 側使える LWC での画面遷移方法を紹介します。 構成図 lwc ├─router ├─myRouterContainer ├─pageA","title":"【Salesforce】LWC Router"}]